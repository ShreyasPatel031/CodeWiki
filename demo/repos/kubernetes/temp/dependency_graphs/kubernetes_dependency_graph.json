{
  "hack.boilerplate.boilerplate.get_refs": {
    "id": "hack.boilerplate.boilerplate.get_refs",
    "name": "get_refs",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [],
    "source_code": "def get_refs():\n    refs = {}\n\n    for path in glob.glob(os.path.join(args.boilerplate_dir, \"boilerplate.*.txt\")):\n        extension = os.path.basename(path).split(\".\")[1]\n\n        with open(path, \"r\") as ref_file:\n            refs[extension] = ref_file.read().splitlines()\n\n    return refs",
    "start_line": 49,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_refs",
    "component_id": "hack.boilerplate.boilerplate.get_refs"
  },
  "hack.boilerplate.boilerplate.is_generated_file": {
    "id": "hack.boilerplate.boilerplate.is_generated_file",
    "name": "is_generated_file",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [],
    "source_code": "def is_generated_file(data, regexs):\n    return regexs[\"generated\"].search(data)",
    "start_line": 61,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data",
      "regexs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_generated_file",
    "component_id": "hack.boilerplate.boilerplate.is_generated_file"
  },
  "hack.boilerplate.boilerplate.file_passes": {
    "id": "hack.boilerplate.boilerplate.file_passes",
    "name": "file_passes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [
      "hack.boilerplate.boilerplate.is_generated_file",
      "hack.boilerplate.boilerplate.file_extension"
    ],
    "source_code": "def file_passes(filename, refs, regexs):\n    try:\n        with open(filename) as stream:\n            data = stream.read()\n    except OSError as exc:\n        print(f\"Unable to open {filename}: {exc}\", file=verbose_out)\n        return False\n\n    # determine if the file is automatically generated\n    generated = is_generated_file(data, regexs)\n\n    basename = os.path.basename(filename)\n    extension = file_extension(filename)\n    if generated:\n        if extension == \"go\":\n            extension = \"generatego\"\n\n    if extension != \"\":\n        ref = refs[extension]\n    else:\n        ref = refs[basename]\n\n    # remove extra content from the top of files\n    if extension in (\"go\", \"generatego\"):\n        data, found = regexs[\"go_build_constraints\"].subn(\"\", data, 1)\n    elif extension in [\"sh\", \"py\"]:\n        data, found = regexs[\"shebang\"].subn(\"\", data, 1)\n\n    data = data.splitlines()\n\n    # if our test file is smaller than the reference it surely fails!\n    if len(ref) > len(data):\n        print(\n            f\"File {filename} smaller than reference ({len(data)} < {len(ref)})\",\n            file=verbose_out,\n        )\n        return False\n\n    # trim our file to the same number of lines as the reference file\n    data = data[: len(ref)]\n\n    if not generated:\n        # Remove all occurrences of the year (regex \"Copyright (2014|2015|2016|2017|2018) \")\n        pattern = regexs[\"date\"]\n        for i, line in enumerate(data):\n            data[i], found = pattern.subn(\"Copyright \", line)\n            if found != 0:\n                break\n\n    # if we don't match the reference at this point, fail\n    if ref != data:\n        print(f\"Header in {filename} does not match reference, diff:\", file=verbose_out)\n        if args.verbose:\n            print(file=verbose_out)\n            for line in difflib.unified_diff(\n                ref, data, \"reference\", filename, lineterm=\"\"\n            ):\n                print(line, file=verbose_out)\n            print(file=verbose_out)\n        return False\n\n    return True",
    "start_line": 65,
    "end_line": 126,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filename",
      "refs",
      "regexs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function file_passes",
    "component_id": "hack.boilerplate.boilerplate.file_passes"
  },
  "hack.boilerplate.boilerplate.file_extension": {
    "id": "hack.boilerplate.boilerplate.file_extension",
    "name": "file_extension",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [],
    "source_code": "def file_extension(filename):\n    return os.path.splitext(filename)[1].split(\".\")[-1].lower()",
    "start_line": 129,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function file_extension",
    "component_id": "hack.boilerplate.boilerplate.file_extension"
  },
  "hack.boilerplate.boilerplate.normalize_files": {
    "id": "hack.boilerplate.boilerplate.normalize_files",
    "name": "normalize_files",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [],
    "source_code": "def normalize_files(files):\n    newfiles = []\n    for pathname in files:\n        if any(x in pathname for x in skipped_names):\n            continue\n        newfiles.append(pathname)\n    for i, pathname in enumerate(newfiles):\n        if not os.path.isabs(pathname):\n            newfiles[i] = os.path.join(args.rootdir, pathname)\n    return newfiles",
    "start_line": 146,
    "end_line": 155,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalize_files",
    "component_id": "hack.boilerplate.boilerplate.normalize_files"
  },
  "hack.boilerplate.boilerplate.get_files": {
    "id": "hack.boilerplate.boilerplate.get_files",
    "name": "get_files",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [
      "hack.boilerplate.boilerplate.normalize_files",
      "hack.boilerplate.boilerplate.file_extension"
    ],
    "source_code": "def get_files(extensions):\n    files = []\n    if len(args.filenames) > 0:\n        files = args.filenames\n    else:\n        for root, dirs, walkfiles in os.walk(args.rootdir):\n            # don't visit certain dirs. This is just a performance improvement\n            # as we would prune these later in normalize_files(). But doing it\n            # cuts down the amount of filesystem walking we do and cuts down\n            # the size of the file list\n            for dname in skipped_names:\n                if dname in dirs:\n                    dirs.remove(dname)\n            for dname in dirs:\n                # dirs that start with __ are ignored\n                if dname.startswith(\"__\"):\n                    dirs.remove(dname)\n\n            for name in walkfiles:\n                pathname = os.path.join(root, name)\n                files.append(pathname)\n\n    files = normalize_files(files)\n    outfiles = []\n    for pathname in files:\n        basename = os.path.basename(pathname)\n        extension = file_extension(pathname)\n        if extension in extensions or basename in extensions:\n            outfiles.append(pathname)\n    return outfiles",
    "start_line": 158,
    "end_line": 187,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extensions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_files",
    "component_id": "hack.boilerplate.boilerplate.get_files"
  },
  "hack.boilerplate.boilerplate.get_dates": {
    "id": "hack.boilerplate.boilerplate.get_dates",
    "name": "get_dates",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [],
    "source_code": "def get_dates():\n    # After 2025, we no longer allow new files to include the year in the copyright header.\n    final_year = 2025\n    return \" (%s) \" % \"|\".join(str(year) for year in range(2014, final_year + 1))",
    "start_line": 190,
    "end_line": 193,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_dates",
    "component_id": "hack.boilerplate.boilerplate.get_dates"
  },
  "hack.boilerplate.boilerplate.get_regexs": {
    "id": "hack.boilerplate.boilerplate.get_regexs",
    "name": "get_regexs",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [
      "hack.boilerplate.boilerplate.get_dates"
    ],
    "source_code": "def get_regexs():\n    regexs = {}\n    # Search for \"YEAR\" which exists in the boilerplate, but shouldn't in the real thing\n    regexs[\"year\"] = re.compile(\"YEAR\")\n    # get_dates return 2014, 2015, 2016, 2017, ..., 2025\n    # as a regex like: \"(2014|2015|2016|2017|2018|...|2025)\";\n    regexs[\"date\"] = re.compile(\"Copyright\" + get_dates())\n    # strip the following build constraints/tags:\n    # //go:build\n    # // +build \\n\\n\n    regexs[\"go_build_constraints\"] = re.compile(\n        r\"^(//(go:build| \\+build).*\\n)+\\n\", re.MULTILINE\n    )\n    # strip #!.* from scripts\n    regexs[\"shebang\"] = re.compile(r\"^(#!.*\\n)\\n*\", re.MULTILINE)\n    # Search for generated files\n    regexs[\"generated\"] = re.compile(r\"^[/*#]+ +.* DO NOT EDIT\\.$\", re.MULTILINE)\n    return regexs",
    "start_line": 196,
    "end_line": 213,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_regexs",
    "component_id": "hack.boilerplate.boilerplate.get_regexs"
  },
  "hack.boilerplate.boilerplate.main": {
    "id": "hack.boilerplate.boilerplate.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate.py",
    "relative_path": "hack/boilerplate/boilerplate.py",
    "depends_on": [
      "hack.boilerplate.boilerplate.get_regexs",
      "hack.boilerplate.boilerplate.file_passes",
      "hack.boilerplate.boilerplate.get_files",
      "hack.boilerplate.boilerplate.get_refs"
    ],
    "source_code": "def main():\n    regexs = get_regexs()\n    refs = get_refs()\n    filenames = get_files(refs)\n\n    for filename in filenames:\n        if not file_passes(filename, refs, regexs):\n            print(filename)\n\n    return 0",
    "start_line": 216,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "hack.boilerplate.boilerplate.main"
  },
  "hack.boilerplate.boilerplate_test.TestBoilerplate": {
    "id": "hack.boilerplate.boilerplate_test.TestBoilerplate",
    "name": "TestBoilerplate",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate_test.py",
    "relative_path": "hack/boilerplate/boilerplate_test.py",
    "depends_on": [],
    "source_code": "class TestBoilerplate(unittest.TestCase):\n    \"\"\"\n    Note: run this test from the hack/boilerplate directory.\n\n    $ python -m unittest boilerplate_test\n    \"\"\"\n\n    def test_boilerplate(self):\n        os.chdir(\"test/\")\n\n        class Args:\n            filenames = []\n            rootdir = \".\"\n            boilerplate_dir = \"../\"\n            verbose = True\n\n        # capture stdout\n        old_stdout = sys.stdout\n        sys.stdout = StringIO()\n\n        boilerplate.args = Args\n        ret = boilerplate.main()\n        self.assertEqual(ret, 0)\n\n        output = sorted(sys.stdout.getvalue().split())\n\n        sys.stdout = old_stdout\n\n        self.assertEqual(output, [\"././fail.go\", \"././fail.py\", \"././fail_2026.go\"])",
    "start_line": 25,
    "end_line": 53,
    "has_docstring": true,
    "docstring": "Note: run this test from the hack/boilerplate directory.\n\n$ python -m unittest boilerplate_test",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "unittest.TestCase"
    ],
    "class_name": null,
    "display_name": "class TestBoilerplate",
    "component_id": "hack.boilerplate.boilerplate_test.TestBoilerplate"
  },
  "hack.boilerplate.boilerplate_test.Args": {
    "id": "hack.boilerplate.boilerplate_test.Args",
    "name": "Args",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/boilerplate/boilerplate_test.py",
    "relative_path": "hack/boilerplate/boilerplate_test.py",
    "depends_on": [],
    "source_code": "        class Args:\n            filenames = []\n            rootdir = \".\"\n            boilerplate_dir = \"../\"\n            verbose = True",
    "start_line": 35,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class Args",
    "component_id": "hack.boilerplate.boilerplate_test.Args"
  },
  "hack.verify-flags-underscore.is_binary": {
    "id": "hack.verify-flags-underscore.is_binary",
    "name": "is_binary",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/verify-flags-underscore.py",
    "relative_path": "hack/verify-flags-underscore.py",
    "depends_on": [],
    "source_code": "def is_binary(pathname):\n    \"\"\"Return true if the given filename is binary.\n    @raise EnvironmentError: if the file does not exist or cannot be accessed.\n    @attention: found @ http://bytes.com/topic/python/answers/21222-determine-file-type-binary-text on 6/08/2010\n    @author: Trent Mick <TrentM@ActiveState.com>\n    @author: Jorge Orpinel <jorge@orpinel.com>\"\"\"\n    try:\n        with open(pathname, 'r') as f:\n            CHUNKSIZE = 1024\n            while True:\n                chunk = f.read(CHUNKSIZE)\n                if '\\0' in chunk: # found null byte\n                    return True\n                if len(chunk) < CHUNKSIZE:\n                    break # done\n    except:\n        return True\n\n    return False",
    "start_line": 27,
    "end_line": 45,
    "has_docstring": true,
    "docstring": "Return true if the given filename is binary.\n@raise EnvironmentError: if the file does not exist or cannot be accessed.\n@attention: found @ http://bytes.com/topic/python/answers/21222-determine-file-type-binary-text on 6/08/2010\n@author: Trent Mick <TrentM@ActiveState.com>\n@author: Jorge Orpinel <jorge@orpinel.com>",
    "parameters": [
      "pathname"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_binary",
    "component_id": "hack.verify-flags-underscore.is_binary"
  },
  "hack.verify-flags-underscore.get_all_files": {
    "id": "hack.verify-flags-underscore.get_all_files",
    "name": "get_all_files",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/verify-flags-underscore.py",
    "relative_path": "hack/verify-flags-underscore.py",
    "depends_on": [
      "hack.verify-flags-underscore.is_binary"
    ],
    "source_code": "def get_all_files(rootdir):\n    all_files = []\n    for root, dirs, files in os.walk(rootdir):\n        # don't visit certain dirs\n        if 'vendor' in dirs:\n            dirs.remove('vendor')\n        if 'staging' in dirs:\n            dirs.remove('staging')\n        if '_output' in dirs:\n            dirs.remove('_output')\n        if 'third_party' in dirs:\n            dirs.remove('third_party')\n        if '.git' in dirs:\n            dirs.remove('.git')\n\n        for name in files:\n            pathname = os.path.join(root, name)\n            if not is_binary(pathname):\n                all_files.append(pathname)\n    return all_files",
    "start_line": 47,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rootdir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_all_files",
    "component_id": "hack.verify-flags-underscore.get_all_files"
  },
  "hack.verify-flags-underscore.check_underscore_in_flags": {
    "id": "hack.verify-flags-underscore.check_underscore_in_flags",
    "name": "check_underscore_in_flags",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/verify-flags-underscore.py",
    "relative_path": "hack/verify-flags-underscore.py",
    "depends_on": [],
    "source_code": "def check_underscore_in_flags(rootdir, files):\n    # preload the 'known' flags which don't follow the - standard\n    pathname = os.path.join(rootdir, \"hack/verify-flags/excluded-flags.txt\")\n    f = open(pathname, 'r')\n    excluded_flags = set(f.read().splitlines())\n    f.close()\n\n    regexs = [ re.compile('Var[P]?\\([^,]*, \"([^\"]*)\"'),\n               re.compile('.String[P]?\\(\"([^\"]*)\",[^,]+,[^)]+\\)'),\n               re.compile('.Int[P]?\\(\"([^\"]*)\",[^,]+,[^)]+\\)'),\n               re.compile('.Bool[P]?\\(\"([^\"]*)\",[^,]+,[^)]+\\)'),\n               re.compile('.Duration[P]?\\(\"([^\"]*)\",[^,]+,[^)]+\\)'),\n               re.compile('.StringSlice[P]?\\(\"([^\"]*)\",[^,]+,[^)]+\\)') ]\n\n    new_excluded_flags = set()\n    # walk all the files looking for any flags being declared\n    for pathname in files:\n        if not pathname.endswith(\".go\"):\n            continue\n        f = open(pathname, 'r')\n        data = f.read()\n        f.close()\n        matches = []\n        for regex in regexs:\n            matches = matches + regex.findall(data)\n        for flag in matches:\n            if any(x in flag for x in excluded_flags):\n                continue\n            if \"_\" in flag:\n                new_excluded_flags.add(flag)\n    if len(new_excluded_flags) != 0:\n        print(\"Found a flag declared with an _ but which is not explicitly listed as a valid flag name in hack/verify-flags/excluded-flags.txt\")\n        print(\"Are you certain this flag should not have been declared with an - instead?\")\n        l = list(new_excluded_flags)\n        l.sort()\n        print((\"%s\" % \"\\n\".join(l)))\n        sys.exit(1)",
    "start_line": 71,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rootdir",
      "files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function check_underscore_in_flags",
    "component_id": "hack.verify-flags-underscore.check_underscore_in_flags"
  },
  "hack.verify-flags-underscore.main": {
    "id": "hack.verify-flags-underscore.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/hack/verify-flags-underscore.py",
    "relative_path": "hack/verify-flags-underscore.py",
    "depends_on": [
      "hack.verify-flags-underscore.get_all_files",
      "hack.verify-flags-underscore.check_underscore_in_flags"
    ],
    "source_code": "def main():\n    rootdir = os.path.dirname(__file__) + \"/../\"\n    rootdir = os.path.abspath(rootdir)\n\n    if len(args.filenames) > 0:\n        files = args.filenames\n    else:\n        files = get_all_files(rootdir)\n\n    check_underscore_in_flags(rootdir, files)",
    "start_line": 109,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "hack.verify-flags-underscore.main"
  },
  "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.MatchHandler": {
    "id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.MatchHandler",
    "name": "MatchHandler",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "relative_path": "staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "depends_on": [],
    "source_code": "class MatchHandler(object):\n    \"\"\" Simple holder for a regular expression and a function\n    to run if that regular expression matches a line.\n    The function should expect (re.match, file, linenumber) as parameters\n    \"\"\"\n    def __init__(self, regex, replace_fn):\n        self.regex = re.compile(regex)\n        self.replace_fn = replace_fn",
    "start_line": 28,
    "end_line": 35,
    "has_docstring": true,
    "docstring": "Simple holder for a regular expression and a function\nto run if that regular expression matches a line.\nThe function should expect (re.match, file, linenumber) as parameters",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "object"
    ],
    "class_name": null,
    "display_name": "class MatchHandler",
    "component_id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.MatchHandler"
  },
  "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.short_replace": {
    "id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.short_replace",
    "name": "short_replace",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "relative_path": "staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "depends_on": [],
    "source_code": "def short_replace(match, file, line_number):\n    \"\"\"Replace a Short: ... cobra command description with an internationalization\n    \"\"\"\n    sys.stdout.write('{}i18n.T({}),\\n'.format(match.group(1), match.group(2)))",
    "start_line": 37,
    "end_line": 40,
    "has_docstring": true,
    "docstring": "Replace a Short: ... cobra command description with an internationalization\n    ",
    "parameters": [
      "match",
      "file",
      "line_number"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function short_replace",
    "component_id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.short_replace"
  },
  "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.import_replace": {
    "id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.import_replace",
    "name": "import_replace",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "relative_path": "staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "depends_on": [],
    "source_code": "def import_replace(match, file, line_number):\n    \"\"\"Add an extra import for the i18n library.\n    Doesn't try to be smart and detect if it's already present, assumes a\n    gofmt round wil fix things.\n    \"\"\"\n    sys.stdout.write('{}\\n\"k8s.io/kubectl/pkg/util/i18n\"\\n'.format(match.group(1)))",
    "start_line": 44,
    "end_line": 49,
    "has_docstring": true,
    "docstring": "Add an extra import for the i18n library.\nDoesn't try to be smart and detect if it's already present, assumes a\ngofmt round wil fix things.",
    "parameters": [
      "match",
      "file",
      "line_number"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function import_replace",
    "component_id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.import_replace"
  },
  "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.string_flag_replace": {
    "id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.string_flag_replace",
    "name": "string_flag_replace",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "relative_path": "staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "depends_on": [],
    "source_code": "def string_flag_replace(match, file, line_number):\n    \"\"\"Replace a cmd.Flags().String(\"...\", \"\", \"...\") with an internationalization\n    \"\"\"\n    sys.stdout.write('{}i18n.T(\"{})\"))\\n'.format(match.group(1), match.group(2)))",
    "start_line": 54,
    "end_line": 57,
    "has_docstring": true,
    "docstring": "Replace a cmd.Flags().String(\"...\", \"\", \"...\") with an internationalization\n    ",
    "parameters": [
      "match",
      "file",
      "line_number"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function string_flag_replace",
    "component_id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.string_flag_replace"
  },
  "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.long_string_replace": {
    "id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.long_string_replace",
    "name": "long_string_replace",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "relative_path": "staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "depends_on": [],
    "source_code": "def long_string_replace(match, file, line_number):\n    return '{}i18n.T({}){}'.format(match.group(1), match.group(2), match.group(3))",
    "start_line": 62,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "match",
      "file",
      "line_number"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function long_string_replace",
    "component_id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.long_string_replace"
  },
  "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.replace": {
    "id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.replace",
    "name": "replace",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/kubernetes/staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "relative_path": "staging/src/k8s.io/kubectl/pkg/util/i18n/translations/extract.py",
    "depends_on": [],
    "source_code": "def replace(filename, matchers, multiline_matchers):\n    \"\"\"Given a file and a set of matchers, run those matchers\n    across the file and replace it with the results.\n    \"\"\"\n    # Run all the matchers\n    line_number = 0\n    for line in fileinput.input(filename, inplace=True):\n        line_number += 1\n        matched = False\n        for matcher in matchers:\n            match = matcher.regex.match(line)\n            if match:\n                matcher.replace_fn(match, filename, line_number)\n                matched = True\n                break\n        if not matched:\n            sys.stdout.write(line)\n    sys.stdout.flush()\n    with open(filename, 'r') as datafile:\n        content = datafile.read()\n        for matcher in multiline_matchers:\n            match = matcher.regex.search(content)\n            while match:\n                rep = matcher.replace_fn(match, filename, 0)\n                # Escape back references in the replacement string\n                # (And escape for Python)\n                # (And escape for regex)\n                rep = re.sub('\\\\\\\\(\\\\d)', '\\\\\\\\\\\\\\\\\\\\1', rep)\n                content = matcher.regex.sub(rep, content, 1)\n                match = matcher.regex.search(content)\n        sys.stdout.write(content)\n\n    # gofmt the file again\n    from subprocess import call\n    call([\"goimports\", \"-w\", filename])",
    "start_line": 69,
    "end_line": 103,
    "has_docstring": true,
    "docstring": "Given a file and a set of matchers, run those matchers\nacross the file and replace it with the results.",
    "parameters": [
      "filename",
      "matchers",
      "multiline_matchers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function replace",
    "component_id": "staging.src.k8s.io.kubectl.pkg.util.i18n.translations.extract.replace"
  }
}