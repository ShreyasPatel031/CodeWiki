<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flask</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.0.0/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 15px 20px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .back-button {
            padding: 8px 16px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: inline-block;
        }

        .back-button:hover {
            background: #1d4ed8;
        }

        .back-button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        .title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
            flex: 1;
        }
        
        .repo-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: white;
            color: #2563eb;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            border: 1px solid #e2e8f0;
        }
        
        .repo-link:hover {
            background: #f8fafc;
            border-color: #2563eb;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .diagram-pane {
            width: 50%;
            border-right: 1px solid #e2e8f0;
            overflow: auto;
            padding: 20px;
            background: #ffffff;
        }

        .doc-pane {
            width: 50%;
            overflow: auto;
            padding: 20px 30px;
            background: #ffffff;
        }

        #mermaid-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .doc-content {
            line-height: 1.6;
            color: #334155;
        }

        .doc-content h1 {
            font-size: 28px;
            margin-bottom: 16px;
            color: #1e293b;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }

        .doc-content h2 {
            font-size: 22px;
            margin-top: 32px;
            margin-bottom: 12px;
            color: #1e293b;
        }

        .doc-content h3 {
            font-size: 18px;
            margin-top: 24px;
            margin-bottom: 8px;
            color: #1e293b;
        }

        .doc-content h4 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 6px;
            color: #475569;
        }

        .doc-content p {
            margin-bottom: 1rem;
            color: #475569;
        }
        
        .doc-content ul, .doc-content ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        .doc-content li {
            margin: 8px 0;
        }

        .doc-content a {
            color: #2563eb;
            text-decoration: none;
        }

        .doc-content a:hover {
            text-decoration: underline;
        }

        .doc-content code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            color: #e11d48;
        }
        
        .doc-content pre {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 16px 0;
        }
        
        .doc-content pre code {
            background: transparent;
            padding: 0;
            color: #334155;
        }

        .doc-content blockquote {
            border-left: 4px solid #2563eb;
            padding-left: 16px;
            margin: 16px 0;
            color: #64748b;
            background: #f8fafc;
            padding: 16px 16px 16px 24px;
            border-radius: 0 8px 8px 0;
        }

        .doc-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
        }

        .doc-content th, .doc-content td {
            border: 1px solid #e2e8f0;
            padding: 12px;
            text-align: left;
        }
        
        .doc-content th {
            background: #f1f5f9;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        /* Make clickable nodes have blue border only - don't change fill or edges */
        /* High specificity selectors to override Mermaid's inline styles */
        svg g.node.clickable-node rect,
        svg g.node.clickable-node circle,
        svg g.node.clickable-node polygon,
        svg g.node.clickable-node ellipse,
        .mermaid g.node.clickable-node rect,
        .mermaid g.node.clickable-node circle,
        .mermaid g.node.clickable-node polygon,
        .mermaid g.node.clickable-node ellipse,
        #mermaid-diagram g.node.clickable-node rect,
        #mermaid-diagram g.node.clickable-node circle,
        #mermaid-diagram g.node.clickable-node polygon,
        #mermaid-diagram g.node.clickable-node ellipse,
        g.clickable-node rect,
        g.clickable-node circle,
        g.clickable-node polygon,
        g.clickable-node ellipse,
        .clickable-node rect,
        .clickable-node circle,
        .clickable-node polygon,
        .clickable-node path:not(.edgePath *),
        .clickable-node ellipse {
            stroke: #2563eb !important;
            stroke-width: 3px !important;
        }

        .clickable-node text,
        .clickable-node tspan {
            font-weight: 600 !important;
        }

        .clickable-node,
        g.node.clickable-node {
            cursor: pointer !important;
        }
        
        /* Ensure pointer events work */
        .clickable-node *,
        g.node.clickable-node * {
            pointer-events: auto !important;
            cursor: pointer !important;
        }
        
        /* Don't change edge colors */
        .mermaid .edgePath path,
        .mermaid .edgePath .path {
            stroke: inherit !important;
        }
        
        /* Selected node/subgraph styling - green border for selected */
        .selected-node rect,
        .selected-node circle,
        .selected-node polygon,
        .selected-node path,
        .selected-node ellipse {
            stroke: #10b981 !important;
            stroke-width: 4px !important;
        }
        
        .selected-subgraph {
            stroke: #10b981 !important;
            stroke-width: 3px !important;
        }
        
        .selected-subgraph .flowchart-labelBox {
            stroke: #10b981 !important;
            stroke-width: 3px !important;
        }

        /* Collapse button styling */
        .collapse-button rect,
        .collapse-button circle,
        .collapse-button polygon {
            stroke: #dc2626 !important;
            stroke-width: 2px !important;
        }

        .collapse-button {
            cursor: pointer !important;
        }
        
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            .diagram-pane, .doc-pane {
                width: 100%;
                height: 50%;
            }
            .diagram-pane {
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="back-button" id="backButton" onclick="goBack()" style="display: none;">‚Üê Back</button>
        <div class="title" id="moduleTitle">üìö flask</div>
            <a href="https://github.com/pallets/flask" class="repo-link" target="_blank">üîó View Repository</a>
            </div>
            
    <div class="container">
        <div class="diagram-pane">
            <div id="mermaid-diagram" class="loading">Loading diagram...</div>
                </div>
        <div class="doc-pane">
            <div class="doc-content" id="docContent">Loading documentation...</div>
            </div>
    </div>
    
    <script>
        // Embedded configuration
        const CONFIG = {};
        const MODULE_TREE = {
  "flask_app": {
    "path": "src/flask/app.py",
    "components": [
      "Flask"
    ],
    "children": {}
  },
  "flask_blueprints": {
    "path": "src/flask/blueprints.py",
    "components": [
      "Blueprint"
    ],
    "children": {}
  },
  "flask_cli": {
    "path": "src/flask/cli.py",
    "components": [
      "ScriptInfo",
      "AppGroup",
      "SeparatedPathType",
      "FlaskGroup",
      "CertParamType"
    ],
    "children": {}
  },
  "flask_config": {
    "path": "src/flask/config.py",
    "components": [
      "ConfigAttribute",
      "Config"
    ],
    "children": {}
  },
  "flask_context": {
    "path": "src/flask/ctx.py",
    "components": [
      "_AppCtxGlobals",
      "AppContext"
    ],
    "children": {}
  },
  "flask_debug_helpers": {
    "path": "src/flask/debughelpers.py",
    "components": [
      "newcls",
      "FormDataRoutingRedirect"
    ],
    "children": {}
  },
  "flask_globals": {
    "path": "src/flask/globals.py",
    "components": [
      "_AppCtxGlobalsProxy",
      "FlaskProxy",
      "SessionMixinProxy",
      "ProxyMixin",
      "RequestProxy",
      "AppContextProxy"
    ],
    "children": {}
  },
  "flask_json": {
    "path": "src/flask/json",
    "components": [
      "JSONProvider",
      "DefaultJSONProvider",
      "PassList",
      "TagMarkup",
      "TagTuple",
      "TaggedJSONSerializer",
      "TagDict",
      "TagUUID",
      "JSONTag",
      "TagDateTime",
      "TagBytes",
      "PassDict"
    ],
    "children": {}
  },
  "flask_sansio": {
    "path": "src/flask/sansio",
    "components": [
      "App",
      "BlueprintSetupState",
      "Blueprint",
      "Scaffold"
    ],
    "children": {}
  },
  "flask_sessions": {
    "path": "src/flask/sessions.py",
    "components": [
      "SessionMixin",
      "SecureCookieSessionInterface",
      "SecureCookieSession",
      "NullSession",
      "SessionInterface"
    ],
    "children": {}
  },
  "flask_templating": {
    "path": "src/flask/templating.py",
    "components": [
      "DispatchingJinjaLoader",
      "Environment"
    ],
    "children": {}
  },
  "flask_testing": {
    "path": "src/flask/testing.py",
    "components": [
      "FlaskClient",
      "FlaskCliRunner",
      "EnvironBuilder"
    ],
    "children": {}
  },
  "flask_views": {
    "path": "src/flask/views.py",
    "components": [
      "View",
      "MethodView"
    ],
    "children": {}
  },
  "flask_wrappers": {
    "path": "src/flask/wrappers.py",
    "components": [
      "Response",
      "Request"
    ],
    "children": {}
  }
};
        const METADATA = {
  "generation_info": {
    "timestamp": "2026-01-13T17:25:12.181093",
    "main_model": "gemini-2.5-flash",
    "generator_version": "1.0.0",
    "repo_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask",
    "commit_id": null
  },
  "statistics": {
    "total_components": 128,
    "leaf_nodes": 49,
    "max_depth": 10
  },
  "files_generated": [
    "overview.md",
    "module_tree.json",
    "first_module_tree.json",
    "flask_testing.md",
    "flask_app.md",
    "flask_context.md",
    "flask_debug_helpers.md",
    "flask_cli.md",
    "flask_sessions.md",
    "flask_views.md",
    "flask_globals.md",
    "flask_config.md",
    "flask_blueprints.md",
    "flask_wrappers.md",
    "flask_sansio.md",
    "flask_templating.md",
    "flask_json.md"
  ]
};
        const DOCS_BASE_PATH = '';
        const DOCS_CONTENT = {
  "flask_testing.md": "# flask_testing\n\nThe `flask_testing` module provides essential utilities for testing Flask applications efficiently. It offers tools to simulate client interactions, execute command-line interface (CLI) commands, and construct various testing environments, making it easier to ensure the reliability and correctness of Flask-based projects.\n\n## Core Components\n\n### `FlaskClient`\nThe `FlaskClient` component extends Flask's standard testing client, providing a high-level interface for simulating HTTP requests against a Flask application. It simplifies the process of sending requests and examining responses within a test suite, offering methods for common HTTP verbs (GET, POST, PUT, DELETE, etc.).\n\n### `FlaskCliRunner`\n`FlaskCliRunner` is designed to facilitate the testing of Flask command-line interface (CLI) commands. It allows developers to programmatically invoke `flask` commands and capture their output, enabling comprehensive testing of CLI functionalities. For more details on Flask CLI, refer to the [flask_cli.md](flask_cli.md) documentation.\n\n### `EnvironBuilder`\nThe `EnvironBuilder` component assists in constructing a WSGI environment for testing. It provides a flexible way to define and customize request parameters, headers, and other environmental variables that are crucial for simulating specific testing scenarios. This component is often used internally by `FlaskClient` but can also be utilized directly for more granular control over the test environment.\n\n## Architecture and Component Relationships\n\nThe `flask_testing` module integrates closely with other core Flask modules to provide a robust testing framework.\n\n```mermaid\ngraph TD\n    subgraph \"flask_testing Module\"\n        FlaskClient[FlaskClient]\n        FlaskCliRunner[FlaskCliRunner]\n        EnvironBuilder[EnvironBuilder]\n    end\n\n    App[Flask Application]:::external\n    Request[Request Object]:::external\n    Response[Response Object]:::external\n    CLI[Flask CLI Components]:::external\n\n    FlaskClient -- Simulates Requests --> App\n    FlaskClient -- Creates --> Request\n    App -- Returns --> Response\n    FlaskClient -- Utilizes --> EnvironBuilder\n    FlaskCliRunner -- Invokes --> CLI\n\n    click App \"flask_app.md\" \"View Flask Application Module\"\n    click Request \"flask_wrappers.md\" \"View Flask Wrappers Module\"\n    click Response \"flask_wrappers.md\" \"View Flask Wrappers Module\"\n    click CLI \"flask_cli.md\" \"View Flask CLI Module\"\n\n    classDef external fill:#f9f,stroke:#333,stroke-width:2px;\n```\n\n## How the Module Fits into the Overall System\n\nThe `flask_testing` module is an indispensable part of the development lifecycle for Flask applications, providing the necessary infrastructure to implement unit and integration tests. It allows developers to:\n\n*   **Validate HTTP Endpoints**: By simulating client requests, `FlaskClient` helps verify that web endpoints behave as expected, handle different inputs correctly, and return appropriate responses.\n*   **Test CLI Commands**: `FlaskCliRunner` ensures that custom `flask` commands, often used for database migrations, data seeding, or administrative tasks, function correctly.\n*   **Isolate Test Environments**: `EnvironBuilder` contributes to creating controlled and isolated test environments, preventing side effects between tests and ensuring reproducible results.\n\nBy leveraging `flask_testing`, developers can build more robust and maintainable Flask applications through comprehensive automated testing. It acts as a bridge between the application code and the testing framework, facilitating the creation of reliable test suites.",
  "overview.md": "## Flask Repository Overview\n\nThe Flask repository contains the source code for the Flask web framework, a lightweight and extensible WSGI web application framework for Python. Its primary purpose is to provide a solid foundation for building web applications and APIs, emphasizing simplicity, flexibility, and modularity. Flask offers core functionalities such as URL routing, request and response handling, templating with Jinja2, session management, and a robust context system, while allowing developers to choose their preferred tools and extensions for other aspects like database integration or authentication.\n\n### Architecture Diagram\n\nThe following diagram illustrates the main modules within the Flask repository and their key relationships:\n\n```mermaid\ngraph TD\n    subgraph Core Application\n        A[Flask Application Core]:::main_app\n        B[Sans-I/O Base]:::core_base\n    end\n\n    subgraph Request/Response Flow\n        C[Request & Response Wrappers]:::req_res\n        D[Application & Request Context]:::context\n        E[Context Proxies]:::globals\n    end\n\n    subgraph Application Structure\n        F[Modular Blueprints]:::structure\n        G[Class-Based Views]:::structure\n    end\n\n    subgraph Data & Configuration\n        H[Configuration Management]:::config\n        I[JSON Serialization]:::data_feature\n        J[Session Management]:::data_feature\n    end\n\n    subgraph Developer Tools\n        K[Jinja2 Templating]:::dev_tool\n        L[Command Line Interface]:::dev_tool\n        M[Testing Utilities]:::dev_tool\n        N[Debug Helpers]:::dev_tool\n    end\n\n    %%Core Application Relationships\n    A -- \"Extends\" --> B\n    A -- \"Handles via\" --> C\n    A -- \"Manages\" --> D\n    A -- \"Registers\" --> F\n    A -- \"Uses\" --> H\n    A -- \"Integrates\" --> I\n    A -- \"Manages\" --> J\n    A -- \"Integrates\" --> K\n\n    %%Request/Response Flow Relationships\n    D -- \"Provides objects for\" --> E\n    E -- \"Proxies\" --> A\n    E -- \"Proxies\" --> C\n    E -- \"Proxies\" --> D\n    E -- \"Proxies\" --> J\n\n    %%Application Structure Relationships\n    F -- \"Defines\" --> G\n    G -- \"Interacts with\" --> C\n    G -- \"Uses\" --> K\n\n    %%Data & Configuration Relationships\n    H -- \"Configures\" --> A\n    I -- \"Used by\" --> C\n    J -- \"Used by\" --> C\n\n    %%Developer Tools Relationships\n    L -- \"Interacts with\" --> A\n    L -- \"Uses\" --> D\n    L -- \"Uses\" --> H\n    M -- \"Tests\" --> A\n    M -- \"Simulates\" --> C\n    M -- \"Invokes\" --> L\n    N -- \"Aids in debugging\" --> A\n    N -- \"Interacts with\" --> C\n\n    %%Clickable nodes\n    click A \"flask_app.md\" \"View Flask Application Core Documentation\"\n    click B \"flask_sansio.md\" \"View Sans-I/O Base Documentation\"\n    click C \"flask_wrappers.md\" \"View Request & Response Wrappers Documentation\"\n    click D \"flask_context.md\" \"View Application & Request Context Documentation\"\n    click E \"flask_globals.md\" \"View Context Proxies Documentation\"\n    click F \"flask_blueprints.md\" \"View Modular Blueprints Documentation\"\n    click G \"flask_views.md\" \"View Class-Based Views Documentation\"\n    click H \"flask_config.md\" \"View Configuration Management Documentation\"\n    click I \"flask_json.md\" \"View JSON Serialization Documentation\"\n    click J \"flask_sessions.md\" \"View Session Management Documentation\"\n    click K \"flask_templating.md\" \"View Jinja2 Templating Documentation\"\n    click L \"flask_cli.md\" \"View Command Line Interface Documentation\"\n    click M \"flask_testing.md\" \"View Testing Utilities Documentation\"\n    click N \"flask_debug_helpers.md\" \"View Debug Helpers Documentation\"\n\n    classDef main_app fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef core_base fill:#ccf,stroke:#333,stroke-width:2px;\n    classDef req_res fill:#bbf,stroke:#333,stroke-width:2px;\n    classDef context fill:#ddf,stroke:#333,stroke-width:2px;\n    classDef globals fill:#eef,stroke:#333,stroke-width:2px;\n    classDef structure fill:#cfc,stroke:#333,stroke-width:2px;\n    classDef config fill:#ffc,stroke:#333,stroke-width:2px;\n    classDef data_feature fill:#fcc,stroke:#333,stroke-width:2px;\n    classDef dev_tool fill:#cff,stroke:#333,stroke-width:2px;\n```",
  "flask_app.md": "# flask_app Module Documentation\n\n## Introduction\n\nThe `flask_app` module, primarily embodied by the `Flask` class, serves as the core of any Flask web application. It provides the central application object that registers routes, handles requests, and manages the application's lifecycle. This module is the entry point for defining the structure and behavior of your web application.\n\n## Core Functionality\n\nThe `Flask` application object is responsible for:\n\n*   **Request Handling**: Processing incoming HTTP requests and routing them to the appropriate view functions.\n*   **URL Routing**: Mapping URLs to Python functions using decorators.\n*   **Configuration Management**: Loading and managing application configuration settings.\n*   **Templating**: Integrating with Jinja2 for rendering dynamic HTML content.\n*   **Session Management**: Providing mechanisms for managing user sessions.\n*   **Blueprints**: Supporting modular application design through Blueprints.\n*   **Context Management**: Managing application and request contexts to make certain objects globally accessible during a request.\n\n## Architecture and Component Relationships\n\nAt its heart, the `Flask` application orchestrates interactions between various components to deliver a web service. Below is a simplified architecture diagram illustrating its key relationships:\n\n```mermaid\ngraph TD\n    A[Flask Application] --> B[Request Handling]\n    A --> C[URL Routing]\n    A --> D[Configuration Management]\n    A --> E[Templating]\n    A --> F[Session Management]\n    A --> G[Blueprints]\n    A --> H[Context Management]\n\n    A -- depends on --> FlaskBlueprints[flask_blueprints.Blueprint]\n    A -- uses --> FlaskConfig[flask_config.Config]\n    A -- manages --> FlaskContext[flask_context.AppContext]\n    A -- provides --> FlaskGlobals[flask_globals.g, request, session, current_app]\n    A -- built on --> FlaskSansio[flask_sansio.App]\n    A -- manages --> FlaskSessions[flask_sessions.SessionInterface]\n    A -- integrates with --> FlaskTemplating[flask_templating.Environment]\n    A -- wraps --> FlaskWrappers[flask_wrappers.Request & Response]\n\n    click FlaskBlueprints \"flask_blueprints.md\" \"View Flask Blueprints Module\"\n    click FlaskConfig \"flask_config.md\" \"View Flask Config Module\"\n    click FlaskContext \"flask_context.md\" \"View Flask Context Module\"\n    click FlaskGlobals \"flask_globals.md\" \"View Flask Globals Module\"\n    click FlaskSansio \"flask_sansio.md\" \"View Flask Sansio Module\"\n    click FlaskSessions \"flask_sessions.md\" \"View Flask Sessions Module\"\n    click FlaskTemplating \"flask_templating.md\" \"View Flask Templating Module\"\n    click FlaskWrappers \"flask_wrappers.md\" \"View Flask Wrappers Module\"\n```\n\n*   **`Flask` (A)**: The central application object.\n*   **`flask_blueprints`**: Enables modularity by organizing related views and other code. The `Flask` application registers and manages these blueprints.\n*   **`flask_config`**: Handles application-wide configuration settings. The `Flask` instance loads and provides access to these settings.\n*   **`flask_context`**: Manages the application and request contexts, which are crucial for making certain objects globally available during a request.\n*   **`flask_globals`**: Provides proxies (`current_app`, `request`, `session`, `g`) that give access to context-local objects. These proxies abstract away the underlying context management.\n*   **`flask_sansio`**: Provides the sans-I/O base application and blueprint classes that `Flask` builds upon for core request dispatching logic without I/O concerns.\n*   **`flask_sessions`**: Defines the interface and implementations for managing user sessions, allowing Flask to store session-specific data.\n*   **`flask_templating`**: Integrates the Jinja2 templating engine, allowing Flask applications to render dynamic HTML templates.\n*   **`flask_wrappers`**: Provides enhanced `Request` and `Response` objects that wrap the underlying Werkzeug request and response objects, adding Flask-specific functionality.\n\n## Integration with Overall System\n\nThe `Flask` application is typically the central hub of a Flask-based web service. It integrates with WSGI servers (e.g., Gunicorn, uWSGI) to receive requests and send responses. Developers define application logic by registering routes, error handlers, and other hooks with the `Flask` instance. It can also integrate with various extensions (e.g., Flask-SQLAlchemy for databases, Flask-Login for user management) to extend its capabilities, making it a flexible framework for building a wide range of web applications and APIs.",
  "flask_context.md": "# Flask Context Module\n\n## Introduction\n\nThe `flask_context` module in Flask is fundamental for managing the application context. It provides the core components for handling application-wide data and resources that are accessible throughout a request or CLI command. This module ensures that certain objects, like the current application (`current_app`) and application-specific global variables (`g`), are available without explicit passing, simplifying development and maintaining a clean API.\n\n## Core Functionality and Architecture\n\nThe `flask_context` module primarily exposes two key components: `AppContext` and `_AppCtxGlobals`.\n\n### AppContext\n\nThe `AppContext` class is responsible for managing the lifecycle of an application context. When a Flask application starts processing a request or a CLI command, an `AppContext` is pushed onto a stack. This makes the application instance available globally as `current_app` (via a proxy in [flask_globals.md](flask_globals.md)). When the request or command finishes, the `AppContext` is popped, and any associated cleanup tasks are performed.\n\nKey responsibilities of `AppContext` include:\n-   Registering and unregistering the application with the context locals.\n-   Managing the `_AppCtxGlobals` instance for the current context.\n-   Providing a mechanism for teardown functions to be executed when the context is popped.\n\n### _AppCtxGlobals\n\n`_AppCtxGlobals` is a simple object that provides a namespace for storing application-specific data. It is typically accessed through the `g` proxy (also defined in [flask_globals.md](flask_globals.md)). This object allows developers to store and retrieve data that is local to a specific application context, ensuring that different requests or CLI commands do not interfere with each other's data.\n\nCommon uses for `g` include:\n-   Storing database connections.\n-   Caching per-request data.\n-   Making external resources available throughout a request.\n\n## Module Relationships and System Fit\n\nThe `flask_context` module is a cornerstone of the Flask framework, providing the mechanism for context management that many other Flask components rely on. It works in close conjunction with:\n\n*   **[flask_globals.md](flask_globals.md)**: This module provides the proxy objects (`current_app`, `g`, `request`, `session`) that make the context-bound variables easily accessible throughout your application code. `flask_globals` directly uses the context management provided by `flask_context`.\n*   **[flask_app.md](flask_app.md)**: The `Flask` application class itself is responsible for creating and pushing `AppContext` instances during request processing and CLI command execution.\n*   **[flask_blueprints.md](flask_blueprints.md)**: Blueprints operate within the application context, and their functions and decorators rely on the availability of `current_app` and `g`.\n\nThis contextual approach ensures that Flask applications remain thread-safe and that resources are properly managed for each individual request or task.\n\n## Architecture Diagram\n\n```mermaid\nflowchart TD\n    FlaskApp[Flask Application] --> AppContext[AppContext]\n    AppContext --> AppCtxGlobals[g: _AppCtxGlobals]\n\n    FlaskApp --> RequestProcessing[Request Processing / CLI Command]\n    RequestProcessing --> AppContext\n\n    AppContext -- provides --> current_app_proxy[current_app proxy]\n    AppCtxGlobals -- provides --> g_proxy[g proxy]\n\n    subgraph flask_globals\n        current_app_proxy\n        g_proxy\n    end\n\n    click AppContext \"flask_context.md\" \"View AppContext details\"\n    click AppCtxGlobals \"flask_context.md\" \"View _AppCtxGlobals details\"\n    click current_app_proxy \"flask_globals.md\" \"View current_app proxy in flask_globals\"\n    click g_proxy \"flask_globals.md\" \"View g proxy in flask_globals\"\n    click FlaskApp \"flask_app.md\" \"View Flask Application module\"\n```\n",
  "flask_debug_helpers.md": "# Flask Debug Helpers Module Documentation\n\n## Introduction\n\nThe `flask_debug_helpers` module provides utilities to assist in debugging Flask applications, primarily focusing on request handling and routing. It offers tools that can help diagnose issues related to form data, redirects, and potentially dynamic introspection of application components.\n\n## Core Components\n\n### `newcls`\n\nThe `newcls` component is a helper utility often used for dynamic class creation or modification within a debugging context. While its specific implementation details can vary, it typically facilitates: \n\n*   **Runtime Class Generation:** Creating new classes on the fly for testing or mocking purposes.\n*   **Method Patching:** Temporarily overriding methods of existing classes to inject debugging logic or alter behavior without modifying the original source code.\n*   **Introspection:** Gaining deeper insights into the structure and behavior of objects during runtime.\n\nThis utility is particularly useful in scenarios where you need to inspect or alter the behavior of Flask internals or third-party libraries without permanently changing their code.\n\n### `FormDataRoutingRedirect`\n\nThe `FormDataRoutingRedirect` component is designed to assist in debugging issues related to form data submission and subsequent redirects within a Flask application. Its primary purpose is to help identify and resolve problems that might occur when a user submits a form, and the application attempts to redirect them to another URL.\n\nKey aspects include:\n\n*   **Form Data Preservation:** In certain debugging scenarios, it might help in understanding how form data is handled across redirects, especially when unexpected data loss or processing issues occur.\n*   **Routing Diagnostics:** It can be instrumental in tracing the flow of control after a form submission, ensuring that the correct route is being invoked and that redirects are happening as expected.\n*   **Debugging Redirect Loops:** This component could be part of a larger mechanism to detect or prevent infinite redirect loops caused by faulty routing logic or improper handling of form submissions.\n\n## Architecture and Component Relationships\n\nThe `flask_debug_helpers` module integrates with the core Flask application, providing tools that can intercept or modify aspects of the request-response cycle for debugging purposes. It works in conjunction with the main [Flask application](flask_app.md) and potentially interacts with [request and response wrappers](flask_wrappers.md) to inspect or alter their behavior.\n\n```mermaid\ngraph TD\n    A[Flask Application] --> B{Request Handling}\n    B --> C[Routing]\n    C -- FormDataRoutingRedirect --> D[Redirect Logic]\n    A -- newcls --> E[Dynamic Class/Method Modification]\n    D -- Interacts With --> A\n\n    click A \"flask_app.md\" \"View Flask App Module\"\n    click D \"flask_wrappers.md\" \"View Flask Wrappers Module\"\n```\n\n## How the Module Fits into the Overall System\n\nThe `flask_debug_helpers` module serves as a crucial toolkit for developers and maintainers to troubleshoot and understand the behavior of Flask applications. It provides low-level debugging capabilities that complement higher-level logging and error reporting. By offering fine-grained control over runtime introspection and request flow analysis, it significantly aids in identifying and resolving complex issues, especially those related to routing, form submissions, and dynamic component interactions. This module is typically used during development and testing phases to ensure the robustness and correctness of the application.",
  "flask_cli.md": "# Flask CLI Module Documentation\n\n## 1. Introduction\nThe `flask_cli` module provides the command-line interface (CLI) for Flask applications, built on top of the [Click](https://click.palletsprojects.com/) library. It enables developers to interact with their Flask applications directly from the terminal, offering tools for running development servers, managing databases, and performing other application-specific tasks.\n\n## 2. Core Functionality and Components\n\nThe `flask_cli` module defines several key components that facilitate the creation and execution of CLI commands for Flask applications:\n\n*   **`ScriptInfo`**: This class is responsible for holding application-specific information when a script is executed. It typically stores the Flask application instance, allowing commands to access the application context.\n*   **`AppGroup`**: Extends Click's `Group` class, providing a foundation for command groups that operate within a Flask application context. It ensures that commands are executed with the correct application loaded.\n*   **`SeparatedPathType`**: A custom Click parameter type designed to handle paths that might be separated by a specific delimiter. This is useful for commands that require lists of file paths.\n*   **`FlaskGroup`**: The primary command group for Flask applications. It integrates `ScriptInfo` and `AppGroup` to create a robust CLI entry point that automatically loads the Flask application. It's the main interface for `flask run`, `flask shell`, and custom commands.\n*   **`CertParamType`**: A custom Click parameter type for validating and handling certificate file paths, often used in commands that involve secure connections (e.g., development servers with HTTPS).\n\n## 3. Architecture and Component Relationships\n\nThe `flask_cli` module is designed around the Click framework, with `FlaskGroup` acting as the central orchestrator for CLI commands. It ensures that the Flask application context is correctly managed for all executed commands.\n\n```mermaid\ngraph TD\n    A[CLI Entry Point] --> B(FlaskGroup)\n    B --> C(AppGroup)\n    B --> D(ScriptInfo)\n    C --> E[Click Commands]\n    E --> F{Parameter Types}\n    F --> G(SeparatedPathType)\n    F --> H(CertParamType)\n\n    click B \"flask_cli.md\" \"View Flask CLI Documentation\"\n    click C \"flask_cli.md\" \"View Flask CLI Documentation\"\n    click D \"flask_cli.md\" \"View Flask CLI Documentation\"\n    click G \"flask_cli.md\" \"View Flask CLI Documentation\"\n    click H \"flask_cli.md\" \"View Flask CLI Documentation\"\n```\n\n*   **CLI Entry Point**: This represents the `flask` command executed in the terminal.\n*   **`FlaskGroup`**: This is the main command group that the CLI entry point invokes. It's responsible for setting up the application context.\n*   **`AppGroup`**: `FlaskGroup` utilizes `AppGroup` to manage the collection of commands available for the Flask application.\n*   **`ScriptInfo`**: `FlaskGroup` uses `ScriptInfo` to load and store information about the Flask application instance, making it accessible to commands.\n*   **Click Commands**: These are the actual commands (e.g., `run`, `shell`, or custom commands) defined within the Flask application using Click decorators.\n*   **Parameter Types**: Commands often utilize specific parameter types for input validation. `SeparatedPathType` and `CertParamType` are examples of custom types provided by `flask_cli` for specialized input handling.\n\n## 4. How `flask_cli` Fits into the Overall System\n\nThe `flask_cli` module serves as the primary interface for developers and maintainers to interact with Flask applications from the command line. It seamlessly integrates with other core Flask modules to provide a comprehensive development and deployment experience:\n\n*   **Application Loading**: It relies on the core Flask application factory (potentially defined in `flask_app` or `flask_sansio`) to load the application instance, ensuring that all configurations and blueprints are correctly initialized.\n*   **Configuration Management**: Commands can access application configurations (managed by `flask_config`) through the application context provided by `ScriptInfo`.\n*   **Context Handling**: `flask_cli` ensures that CLI commands execute within a proper Flask application context and request context (handled by `flask_context` and `flask_globals`), allowing access to `current_app`, `g`, and other context-local proxies.\n*   **Development Server**: The `flask run` command, powered by `flask_cli`, starts a development server, which internally uses Flask's request and response handling (`flask_wrappers`) and potentially templating (`flask_templating`) and session management (`flask_sessions`).\n\nBy providing a robust and extensible CLI, `flask_cli` significantly enhances the developer experience, making it easier to build, test, and deploy Flask applications.",
  "flask_sessions.md": "# Flask Sessions Module\n\n## Introduction\n\nThe `flask_sessions` module in Flask is responsible for managing user sessions, providing a mechanism to store data associated with a specific user across multiple requests. It offers different implementations for session handling, with a focus on secure, signed cookie-based sessions by default.\n\nThis module defines the interfaces and concrete implementations for session management, allowing developers to choose or implement their own session storage mechanisms.\n\n## Architecture and Component Relationships\n\nThe `flask_sessions` module revolves around the `SessionInterface` and `SessionMixin` components, which define the contract and common functionalities for session management. `SecureCookieSessionInterface` provides the default, secure cookie-based session handling.\n\n```mermaid\ngraph TD\n    A[Session Management] --> B[SessionInterface]\n    B --> C[SecureCookieSessionInterface]\n    B --> D[NullSession]\n    C --> E[SecureCookieSession]\n    A --> F[SessionMixin]\n    \n    click B \"flask_sessions.md\" \"View SessionInterface details\"\n    click C \"flask_sessions.md\" \"View SecureCookieSessionInterface details\"\n    click D \"flask_sessions.md\" \"View NullSession details\"\n    click E \"flask_sessions.md\" \"View SecureCookieSession details\"\n    click F \"flask_sessions.md\" \"View SessionMixin details\"\n```\n\n### Component Details\n\n#### `SessionInterface`\n\n`SessionInterface` is an abstract base class that defines the API for session management. Any custom session implementation in Flask must inherit from this class and implement its methods for loading and saving session data. It acts as the bridge between the Flask application and the underlying session storage mechanism.\n\n#### `SecureCookieSessionInterface`\n\nThis is the default session interface provided by Flask. It stores session data in a cryptographically signed cookie on the client-side. The session data is serialized, signed with a secret key to prevent tampering, and then stored in the user's browser cookie. This approach avoids server-side storage, making it suitable for stateless applications.\n\n#### `SecureCookieSession`\n\nRepresents a session object managed by the `SecureCookieSessionInterface`. It is a dictionary-like object that holds the actual session data. When changes are made to this object, `SecureCookieSessionInterface` is responsible for serializing and storing these changes back into the secure cookie.\n\n#### `NullSession`\n\n`NullSession` is an implementation of `SessionInterface` that effectively disables sessions. When this interface is used, no session data is stored or retrieved, and any attempts to access or modify session variables will have no effect. It can be useful in scenarios where session management is explicitly not required.\n\n#### `SessionMixin`\n\n`SessionMixin` provides helper methods and properties related to session handling. It is typically mixed into the `Request` object (see [flask_wrappers.md](flask_wrappers.md)) to provide easy access to the current session object via `request.session` or similar attributes.\n\n## Integration with Flask System\n\nThe `flask_sessions` module is a fundamental part of the Flask ecosystem, enabling stateful interactions over the stateless HTTP protocol. It integrates closely with the `Flask` application object (see [flask_app.md](flask_app.md)) which is configured with a `SECRET_KEY` necessary for signing the secure cookies.\n\nWhen a request comes in, the `SessionInterface` implementation (by default `SecureCookieSessionInterface`) is responsible for loading the session data from the incoming request (e.g., from a cookie). This session object is then made available through the request context, often via a `SessionMixin` on the request object.\n\nAfter the request is processed and before the response is sent, the `SessionInterface` saves any modified session data back to the appropriate storage (e.g., setting a new secure cookie in the response).",
  "flask_views.md": "# Flask Views Module Documentation\n\n## Introduction\n\nThe `flask_views` module provides class-based views for Flask applications, offering an alternative to traditional function-based views. It helps organize request handling logic into classes, promoting reusability and better structure, especially for RESTful APIs or complex applications.\n\n## Core Functionality\n\nThe module introduces two primary class-based view components: `View` and `MethodView`.\n\n### View\n\nThe `View` class is a base class for generic class-based views. It allows developers to define a `dispatch_request` method which will be called when a request matches the view's registered URL rule. This provides a structured way to handle requests, especially when different HTTP methods (GET, POST, etc.) for the same endpoint share common setup or teardown logic.\n\n#### Key Features:\n*   **Centralized Request Handling:** All HTTP methods for a given endpoint are handled within a single `dispatch_request` method.\n*   **Flexibility:** Can be used for simple pages or more complex request processing.\n*   **Inheritance:** Encourages creating reusable base view classes.\n\n### MethodView\n\nThe `MethodView` class extends the `View` concept by automatically dispatching requests to methods named after the HTTP method (e.g., `get()` for GET requests, `post()` for POST requests, `put()` for PUT requests, etc.). This simplifies the implementation of RESTful APIs where different HTTP methods perform distinct operations on a resource.\n\n#### Key Features:\n*   **RESTful API Design:** Directly supports HTTP verb-based routing.\n*   **Code Organization:** Each HTTP method gets its own dedicated method within the view class, improving readability and maintainability.\n*   **Automatic Dispatching:** Flask handles the mapping of HTTP methods to class methods automatically.\n\n## Architecture and Component Relationships\n\nThe `flask_views` module integrates seamlessly with the core Flask application and blueprints. Views are typically registered with a Flask application instance or a Blueprint to define how specific URLs are handled.\n\n```mermaid\ngraph TD\n    A[Flask Application] --> B(Register View)\n    B --> C{URL Routing}\n    C --> D[View Instance]\n    D --> E(dispatch_request or HTTP Method Method)\n\n    subgraph flask_views\n        F[View]\n        G[MethodView]\n    end\n\n    F -- inherets --> G\n\n    click A \"flask_app.md\" \"View Flask Application Module\"\n    click B \"flask_blueprints.md\" \"View Flask Blueprints Module\"\n\n    style F fill:#f9f,stroke:#333,stroke-width:2px\n    style G fill:#f9f,stroke:#333,stroke-width:2px\n```\n\n### How it Fits into the Overall System\n\nClass-based views, especially `MethodView`, are a cornerstone for building maintainable and scalable web applications and APIs with Flask. They abstract away repetitive routing logic and promote a clean separation of concerns, making it easier to manage complex application logic. They work in conjunction with:\n\n*   **[Flask Application](flask_app.md):** The main application instance where views are registered.\n*   **[Flask Blueprints](flask_blueprints.md):** For organizing views into modular components, especially in larger applications.\n*   **[Flask Wrappers](flask_wrappers.md):** Views often interact with `Request` and `Response` objects to process incoming data and generate outgoing responses.\n*   **[Flask Templating](flask_templating.md):** Views can render templates to generate HTML responses.\n\nBy providing a structured way to define request handlers, `flask_views` significantly contributes to the overall organization and modularity of Flask applications.",
  "flask_globals.md": "# flask_globals Module Documentation\n\n## Introduction\n\nThe `flask_globals` module provides essential proxy objects that allow for easy, thread-local access to various core Flask components within an application context. These proxies abstract away the underlying context management, enabling developers to interact with the current application, request, session, and application context globals as if they were directly accessible.\n\n## Architecture and Component Relationships\n\nThe `flask_globals` module acts as an intermediary, providing proxy access to objects managed by other core Flask modules. The following diagram illustrates its relationship with the modules it proxies:\n\n```mermaid\ngraph TD\n    subgraph flask_globals\n        FG_AppContextProxy[\"AppContextProxy\"]\n        FG_AppCtxGlobalsProxy[\"_AppCtxGlobalsProxy\"]\n        FG_FlaskProxy[\"FlaskProxy\"]\n        FG_RequestProxy[\"RequestProxy\"]\n        FG_SessionMixinProxy[\"SessionMixinProxy\"]\n    end\n\n    flask_context[flask_context]\n    flask_app[flask_app]\n    flask_wrappers[flask_wrappers]\n    flask_sessions[flask_sessions]\n\n    FG_AppContextProxy --> flask_context\n    FG_AppCtxGlobalsProxy --> flask_context\n    FG_FlaskProxy --> flask_app\n    FG_RequestProxy --> flask_wrappers\n    FG_SessionMixinProxy --> flask_sessions\n\n    click flask_context \"flask_context.md\" \"View flask_context Module\"\n    click flask_app \"flask_app.md\" \"View flask_app Module\"\n    click flask_wrappers \"flask_wrappers.md\" \"View flask_wrappers Module\"\n    click flask_sessions \"flask_sessions.md\" \"View flask_sessions Module\"\n```\n\n## Core Functionality and Components\n\nThe `flask_globals` module exposes several proxy objects, all inheriting from `ProxyMixin`, to provide convenient access to context-local objects.\n\n### `ProxyMixin`\n\nThe base mixin for all proxy objects in this module. It provides the core functionality for delegating attribute access to the wrapped object within the current context.\n\n### `_AppCtxGlobalsProxy`\n\nThis proxy provides access to the application context globals object, typically an instance of [`_AppCtxGlobals`](flask_context.md) from the `flask_context` module. It allows storing and retrieving application-specific data that is local to the current application context.\n\n### `FlaskProxy`\n\nA proxy for the current Flask application instance, which is typically an instance of [`Flask`](flask_app.md) from the `flask_app` module. Through this proxy, developers can access application-wide configuration, extensions, and other properties of the active Flask application.\n\n### `SessionMixinProxy`\n\nThis proxy provides access to the current session object, which implements the `SessionMixin` interface (defined in [`flask_sessions`](flask_sessions.md)). It allows developers to interact with session-specific data, such as storing and retrieving user-specific information across requests.\n\n### `RequestProxy`\n\nA proxy for the current request object, typically an instance of [`Request`](flask_wrappers.md) from the `flask_wrappers` module. It allows access to all properties and methods of the incoming HTTP request, such as form data, headers, URL parameters, and more.\n\n### `AppContextProxy`\n\nThis proxy provides access to the current application context object, typically an instance of [`AppContext`](flask_context.md) from the `flask_context` module. It allows direct interaction with the application context itself, which manages the lifespan of various application-level objects.\n\n## Integration with the Overall System\n\nThe `flask_globals` module is a fundamental part of Flask's context management system. It relies heavily on the thread-local storage provided by Flask's context locals (`_app_ctx_stack`, `_request_ctx_stack`) to ensure that the correct application, request, and session objects are accessible at any given time, regardless of the thread handling the request.\n\nBy providing these global proxies, Flask simplifies application development by allowing direct access to `current_app`, `request`, `session`, and `g` (application context globals) without explicit passing of these objects through function calls. This design choice makes Flask applications feel more \"global\" within a request-response cycle, while still maintaining thread isolation.",
  "flask_config.md": "# Flask Config Module Documentation\n\n## Introduction\nThe `flask_config` module is a crucial component in Flask applications, providing a robust and flexible system for managing application-wide configuration settings. It allows developers to define, load, and access various parameters that dictate the behavior and environment of a Flask application.\n\n## Core Functionality\nThe `flask_config` module provides the following core components:\n\n### `Config`\nThe `Config` class is the cornerstone of Flask's configuration system. It behaves like a dictionary but offers enhanced capabilities for loading configuration from multiple sources, including:\n*   **Python Files:** Loading configurations from `.py` files, which allows for dynamic configuration based on Python expressions.\n*   **Objects:** Loading from any object that has attributes representing configuration keys.\n*   **Environment Variables:** Integrating with environment variables, which is essential for deploying applications in different environments (e.g., development, staging, production) without changing the codebase.\n\nThe `Config` object stores application settings such as `SECRET_KEY`, database URIs, debug flags, and other custom parameters. It provides a convenient and centralized way to manage these settings throughout the application lifecycle.\n\n### `ConfigAttribute`\n`ConfigAttribute` is a descriptor that facilitates access to configuration values as attributes of the `Flask` application object, even though they are stored in the underlying `Config` object. This provides a more intuitive and Pythonic way to retrieve configuration settings, for example, `app.debug` instead of `app.config['DEBUG']`. This abstraction simplifies development by making configuration values feel like native attributes of the application.\n\n## Architecture and Component Relationships\nThe `flask_config` module primarily interacts with the main `Flask` application instance. The `Config` object is an integral part of the `Flask` application, instantiated and managed by it to hold all relevant configuration data.\n\n```mermaid\ngraph TD\n    Flask_App[Flask Application]\n    Config_Module[flask_config.md Config Module]\n\n    Flask_App --> Config_Module\n    \n    click Flask_App \"flask_app.md\" \"View Flask Application Module\"\n```\n\nThe `Flask` application object (from the [flask_app.md](flask_app.md) module) directly utilizes the `Config` class to manage its settings. `ConfigAttribute` instances are typically set on the `Flask` application class to proxy access to the underlying `Config` object's values.\n\n## Integration with the Overall System\nThe `flask_config` module is fundamental to the entire Flask ecosystem. It serves as the central repository for all application settings, influencing almost every aspect of a Flask application's behavior. From database connections and secret key management to debug mode activation and custom extension configurations, the `Config` object is consulted.\n\nIt enables developers to create flexible and environment-aware applications by allowing configurations to be easily swapped based on the deployment environment. This modular approach to configuration management ensures that applications can be easily adapted and maintained across various development and production stages.\n",
  "flask_blueprints.md": "# Flask Blueprints Documentation\n\n## 1. Introduction\n\nThe `flask_blueprints` module provides the `Blueprint` object, a fundamental feature in Flask for structuring applications. Blueprints allow you to organize your application into smaller, reusable components, each defining its own set of views, static files, and templates. This modular approach significantly improves maintainability and scalability, especially for larger applications or when developing reusable components that can be registered with multiple Flask applications.\n\n## 2. Core Functionality\n\nA `Blueprint` object works similarly to a Flask application object, but it is not a standalone application. Instead, it is a blueprint for building parts of an application. Key functionalities include:\n\n*   **Modular Organization**: Grouping related views, templates, static files, and other resources into a single, self-contained unit.\n*   **URL Prefixing**: Blueprints can be registered with a URL prefix, allowing all routes defined within the blueprint to automatically start with that prefix.\n*   **Template Folder Specification**: Each blueprint can specify its own template folder, separate from the main application's templates.\n*   **Static File Handling**: Blueprints can manage their own static files, accessible via a blueprint-specific URL.\n*   **Subdomain Support**: Blueprints can be configured to handle requests for specific subdomains.\n*   **Registration with Applications**: A blueprint must be registered with a Flask application instance using `app.register_blueprint()`. This integrates the blueprint's routes, error handlers, and other components into the application.\n\n### Key Benefits:\n*   **Code Organization**: Keeps related code together, making it easier to navigate and understand.\n*   **Reusability**: Blueprints can be easily reused across different Flask projects.\n*   **Scalability**: Facilitates the growth of an application by allowing features to be developed and managed in isolation.\n*   **Team Collaboration**: Multiple teams can work on different parts of an application (different blueprints) without significant conflicts.\n\n## 3. Architecture and Component Relationships\n\nThe `flask_blueprints` module, through its `Blueprint` component, acts as a bridge between modular application components and the main Flask application.\n\n```mermaid\ngraph TD\n    A[Flask Application] --> B[Registers]\n    B --> C{Blueprint}\n    C --> D[Defines Routes, Views, Templates]\n    C --> E[Manages Static Files]\n\n    click A \"flask_app.md\" \"View Flask Application Module\"\n    click C \"flask_blueprints.md\" \"View Flask Blueprints Module\"\n```\n\nIn this architecture:\n*   The `Flask Application` (from the [flask_app.md](flask_app.md) module) is the central instance that orchestrates the entire web application.\n*   A `Blueprint` (from `flask_blueprints`) encapsulates a segment of the application's functionality.\n*   The Flask application `registers` one or more Blueprints. Upon registration, the blueprint's definitions (routes, error handlers, template folders, static files) are integrated into the main application.\n*   Each Blueprint `Defines Routes, Views, Templates` and `Manages Static Files` specific to its domain.\n\nThis relationship allows for a clear separation of concerns, where the main application handles global configurations and shared resources, while blueprints manage specific features or sections of the application.\n\n## 4. How the Module Fits into the Overall System\n\nThe `flask_blueprints` module is crucial for developing scalable and well-organized Flask applications. It enables developers to break down a monolithic application into smaller, manageable, and self-contained units. This is particularly beneficial for:\n\n*   **Large Applications**: Organizing features like user management, product catalogs, or API endpoints into distinct blueprints.\n*   **RESTful APIs**: Structuring different API versions or resource groups using separate blueprints.\n*   **Reusable Components**: Creating generic components (e.g., an authentication system) that can be easily plugged into various Flask projects.\n\nBy providing a structured way to extend and organize Flask applications, `flask_blueprints` ensures that applications remain maintainable and comprehensible as they grow in complexity. It works hand-in-hand with other Flask components, allowing views defined in blueprints to interact with the [Request and Response objects](flask_wrappers.md) objects, utilize [Flask Templating](flask_templating.md), and access application context provided by [Flask Context](flask_context.md) and [Flask Globals](flask_globals.md).",
  "flask_wrappers.md": "# Flask Wrappers Module\n\n## Introduction\n\nThe `flask_wrappers` module in Flask provides the fundamental `Request` and `Response` objects, which are essential for handling HTTP communication within a Flask application. These objects abstract away the complexities of the underlying WSGI environment, offering a convenient and Pythonic interface for interacting with incoming client requests and constructing outgoing server responses.\n\n## Purpose and Core Functionality\n\n### Request Object\n\nThe `Request` object encapsulates all information about an incoming HTTP request from a client. It provides properties and methods to access various parts of the request, including:\n\n*   **Headers**: Access to HTTP headers (e.g., `request.headers`).\n*   **Method**: The HTTP method used (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n*   **URL Data**: The URL, path, query parameters (e.g., `request.path`, `request.args`).\n*   **Form Data**: Data submitted via HTML forms (e.g., `request.form`).\n*   **JSON Data**: JSON payload in the request body (e.g., `request.json`).\n*   **Files**: Uploaded files (e.g., `request.files`).\n*   **Cookies**: Client-sent cookies (e.g., `request.cookies`).\n*   **Body Data**: Raw request body content.\n\nThis object makes it straightforward for developers to process client input and make decisions based on the request's characteristics.\n\n### Response Object\n\nThe `Response` object is used to construct the HTTP response that will be sent back to the client. It allows developers to control:\n\n*   **Content**: The body of the response (e.g., HTML, JSON, plain text).\n*   **Status Code**: The HTTP status code (e.g., `200 OK`, `404 Not Found`, `500 Internal Server Error`).\n*   **Headers**: HTTP headers to include in the response (e.g., `Content-Type`, `Set-Cookie`).\n*   **Cookies**: Cookies to be set in the client's browser.\n\nFlask automatically wraps return values from view functions into `Response` objects, but developers can also create and return `Response` objects directly for more fine-grained control.\n\n## Architecture and Component Relationships\n\nThe `Request` and `Response` objects are central to the request-response cycle in Flask. They interact directly with the main Flask application instance and the WSGI server. The Flask application dispatches an incoming WSGI request into a `Request` object, processes it through view functions, and then converts the view function's return value into a `Response` object before sending it back via the WSGI server.\n\n```mermaid\ngraph TD\n    A[Client] -- HTTP Request --> B{WSGI Server}\n    B --> C[Flask Application]\n    C -- Creates Request Object --> D[Request Object]\n    D -- Processed by View Function --> C\n    C -- Returns Data/Response --> E[Response Object]\n    E -- Converted to WSGI Response --> B\n    B -- HTTP Response --> A\n\n    click C \"flask_app.md\" \"View Flask Application Module\"\n    click D \"flask_wrappers.md\" \"View Request Object Details\"\n    click E \"flask_wrappers.md\" \"View Response Object Details\"\n```\n\n## How the Module Fits into the Overall System\n\n`flask_wrappers` is a foundational module within the Flask ecosystem. Almost every interaction in a Flask application involves these two objects:\n\n*   **Routing and Views**: View functions receive data via the `request` global proxy and construct responses, often implicitly, which are then converted into `Response` objects.\n*   **Context Management**: The `Request` object is tied to the request context (see [flask_context.md](flask_context.md)), making it accessible via the `flask.request` proxy.\n*   **Error Handling**: Custom error handlers often construct `Response` objects for error pages.\n*   **Testing**: The `FlaskClient` (from [flask_testing.md](flask_testing.md)) internally uses these wrappers to simulate requests and inspect responses during testing.\n*   **Extensions**: Many Flask extensions build upon or interact with the `Request` and `Response` objects to add functionality (e.g., authentication, logging, internationalization).\n\nEssentially, `flask_wrappers` provides the core objects that enable Flask to function as a web framework, bridging the gap between raw HTTP and Python application logic.",
  "flask_sansio.md": "# flask_sansio Module Documentation\n\n## Introduction\nThe `flask_sansio` module provides the core sans-I/O components for Flask, enabling a flexible and testable application architecture by decoupling the application logic from the underlying I/O mechanisms. This module introduces fundamental building blocks such as `App`, `Blueprint`, and `Scaffold`, which are essential for constructing Flask applications without direct reliance on specific web server interfaces.\n\n## Architecture and Core Components\n\nThe `flask_sansio` module is built around several key components that facilitate the sans-I/O design. These components work together to provide a robust and extensible foundation for Flask applications.\n\n### Core Components\n*   **App**: Represents the sans-I/O application object. It manages the application's configuration, teardown functions, and provides the central point for dispatching requests without directly handling the HTTP protocol. The `App` component in `flask_sansio` serves as the base for the main `Flask` application object found in [flask_app.md](flask_app.md).\n*   **Blueprint**: A sans-I/O blueprint provides a mechanism to organize a group of related views, static files, and templates. It defers registration with the application until later, allowing for modularity and reusability. The `Blueprint` component here is a sans-I/O version of the more comprehensive `Blueprint` in [flask_blueprints.md](flask_blueprints.md).\n*   **Scaffold**: This component serves as a base class for both `App` and `Blueprint`, providing common functionalities and attributes like name and static file handling. It ensures consistency across these core structures.\n*   **BlueprintSetupState**: An internal helper class that holds the state during the setup process of a Blueprint, managing configurations and deferred functions.\n\n### Architecture Diagram\n\n```mermaid\ngraph TD\n    A[App]\n    B[Blueprint]\n    C[Scaffold]\n    D[BlueprintSetupState]\n\n    C --> A\n    C --> B\n    B --> D\n\n    click A \"flask_app.md\" \"View Flask App Module\"\n    click B \"flask_blueprints.md\" \"View Flask Blueprints Module\"\n```\n\n## How it Fits into the Overall System\n\nThe `flask_sansio` module forms the foundational layer of a Flask application's core logic. By separating the application's request processing and response generation from the actual network I/O, it allows Flask to be highly adaptable to various deployment environments, including WSGI, ASGI, and testing frameworks.\n\nThe `App` component in `flask_sansio` is extended by the `Flask` class in the [flask_app.md](flask_app.md) module, which adds the WSGI application interface and other I/O specific functionalities. Similarly, the `Blueprint` component provides the sans-I/O capabilities that are further built upon by the `Blueprint` class in [flask_blueprints.md](flask_blueprints.md), enabling modular application development.\n\nThis sans-I/O design promotes:\n*   **Testability**: Application logic can be tested in isolation without needing to mock HTTP requests or responses.\n*   **Flexibility**: The same application logic can be deployed with different I/O layers (e.g., synchronous WSGI servers or asynchronous ASGI servers).\n*   **Maintainability**: Clear separation of concerns makes the codebase easier to understand and manage.\n\nThe components within `flask_sansio` work closely with other modules like [flask_config.md](flask_config.md) for application configuration, [flask_context.md](flask_context.md) for managing application and request contexts, and [flask_globals.md](flask_globals.md) for providing proxy access to context-local objects.",
  "flask_templating.md": "# Flask Templating Module (`flask_templating`)\n\n## Introduction\n\nThe `flask_templating` module is responsible for integrating the Jinja2 templating engine into Flask applications. It provides the necessary components to load, manage, and render templates, allowing developers to create dynamic HTML content.\n\n## Core Functionality and Components\n\nThis module primarily revolves around two core components: `DispatchingJinjaLoader` and `Environment`.\n\n### `DispatchingJinjaLoader`\n\nThe `DispatchingJinjaLoader` is a custom Jinja2 loader designed for Flask. Its primary function is to intelligently locate templates within a Flask application. It understands Flask's application and blueprint structure, allowing templates to be organized and discovered from various locations, such as the application's `templates` folder or within blueprint-specific `templates` folders. This loader is crucial for enabling modular template organization in larger Flask applications.\n\n### `Environment`\n\nThe `Environment` component in `flask_templating` represents the Jinja2 templating environment. It's an instance of `jinja2.Environment` configured specifically for Flask. This environment holds the configuration for template loading, global variables, filters, tests, and other Jinja2 extensions. It's responsible for parsing template files, compiling them, and rendering them with context data. Flask configures this environment to provide access to common Flask-specific globals (like `request`, `session`, `g`, `url_for`, etc.) within templates.\n\n## Architecture and Component Relationships\n\nThe `flask_templating` module sits between the Flask application core and the Jinja2 templating engine. It relies on the main `flask_app` for configuration and context and provides the templating capabilities used by views to render responses.\n\n```mermaid\ngraph TD\n    A[Flask Application Core] --> B{flask_templating Module}\n    B --> C[DispatchingJinjaLoader]\n    B --> D[Jinja2 Environment]\n    C --> E[Template Files]\n    D --> E\n    A -- Configures --> D\n    A -- Uses to Render --> B\n\n    click A \"flask_app.md\" \"View Flask App Module\"\n    click B \"#\" \"Current Module: Flask Templating\"\n```\n\n## How the Module Fits into the Overall System\n\nThe `flask_templating` module is a fundamental part of Flask's request-response cycle for web applications. When a client makes a request, Flask routes it to a view function. If that view function needs to generate an HTML response, it typically calls `render_template()`.\n\nThe `render_template()` function, provided by Flask, uses the `Environment` configured by `flask_templating` to load and render the specified template. The `DispatchingJinjaLoader` helps the `Environment` find the correct template file, taking into account the current application or blueprint context. The rendered HTML is then returned as part of the `Response` object (handled by `flask_wrappers`).\n\nThis module ensures a clean separation of concerns, allowing developers to define application logic in Python and presentation logic in Jinja2 templates.\n",
  "flask_json.md": "# Flask JSON Module\n\n## Introduction\n\nThe `flask_json` module is a crucial component of Flask, providing robust and flexible JSON serialization and deserialization capabilities. It enables Flask applications to seamlessly handle JSON data, which is fundamental for building web APIs and communicating with modern web clients. This module focuses on extensibility, allowing developers to define custom serialization rules for complex Python objects.\n\n## Core Functionality and Components\n\nThe `flask_json` module offers a sophisticated mechanism for converting Python objects to JSON and back, with a particular emphasis on tagging objects to preserve their type information during serialization. This ensures that complex data structures can be faithfully reconstructed after deserialization.\n\n### `JSONProvider`\n\nThe `JSONProvider` is an abstract base class that defines the interface for JSON serialization and deserialization in Flask. It specifies the methods that any JSON provider must implement, such as `dumps` for serializing Python objects to JSON strings and `loads` for deserializing JSON strings back into Python objects.\n\n### `DefaultJSONProvider`\n\nThe `DefaultJSONProvider` is the default implementation of the `JSONProvider`. It provides standard JSON serialization and deserialization, often utilizing Python's built-in `json` module. It also incorporates the tagging system to handle Flask-specific object types and custom objects configured by the application.\n\n### Tagging System (`JSONTag`, `TaggedJSONSerializer`, `Tag*` classes)\n\nThe tagging system is at the heart of `flask_json`'s advanced serialization capabilities. It allows for the serialization of complex or non-standard Python types by attaching a \"tag\" that identifies their original type. When deserializing, `TaggedJSONSerializer` uses these tags to reconstruct the original Python objects.\n\n*   **`JSONTag`**: A base class for defining custom JSON tags. Each specific tag type (e.g., `TagUUID`, `TagDateTime`) inherits from this.\n*   **`TaggedJSONSerializer`**: The serializer that orchestrates the tagging and untagging process. It manages a registry of tag handlers and is responsible for converting tagged objects to a JSON-compatible format and vice-versa.\n*   **`TagMarkup`**: Handles the serialization and deserialization of Jinja2 `Markup` objects.\n*   **`TagTuple`**: Manages the serialization and deserialization of tuples, ensuring they are correctly reconstructed as tuples rather than lists (which is the default JSON array mapping).\n*   **`TagDict`**: Handles dictionary serialization, potentially with custom logic for specific dictionary types or keys.\n*   **`TagUUID`**: Provides serialization for `uuid.UUID` objects, converting them to string representations and back.\n*   **`TagDateTime`**: Serializes `datetime` objects into a standardized string format (e.g., ISO 8601) and deserializes them back to `datetime` objects.\n*   **`TagBytes`**: Converts `bytes` objects to a JSON-compatible format (e.g., base64 encoded strings) and reconstructs them.\n\n### Pass-Through Types (`PassList`, `PassDict`)\n\nThese components are likely used to explicitly mark certain lists or dictionaries that should be serialized directly without any special tagging or processing, acting as simple pass-through mechanisms within the tagging system.\n\n*   **`PassList`**: Indicates a list that should be serialized as a standard JSON array.\n*   **`PassDict`**: Indicates a dictionary that should be serialized as a standard JSON object.\n\n## Architecture and Component Relationships\n\nThe `flask_json` module's architecture revolves around the `JSONProvider` interface, with `DefaultJSONProvider` serving as the primary implementation. The core of its advanced features is the `TaggedJSONSerializer` and its associated `JSONTag` subclasses, which enable intelligent serialization of various Python types.\n\n```mermaid\ngraph TD\n    A[Flask Application] --> B(JSONProvider Interface)\n    B --> C{DefaultJSONProvider}\n    C --> D[TaggedJSONSerializer]\n    D --> E(JSONTag Registry)\n\n    E --> F[TagMarkup]\n    E --> G[TagTuple]\n    E --> H[TagDict]\n    E --> I[TagUUID]\n    E --> J[TagDateTime]\n    E --> K[TagBytes]\n\n    D -- \"Utilizes for direct serialization\" --> L[PassList]\n    D -- \"Utilizes for direct serialization\" --> M[PassDict]\n\n    click A \"flask_app.md\" \"View Flask Application Module\"\n    click B \"flask_json.md\" \"JSONProvider Documentation\"\n    click C \"flask_json.md\" \"DefaultJSONProvider Documentation\"\n    click D \"flask_json.md\" \"TaggedJSONSerializer Documentation\"\n    click E \"flask_json.md\" \"JSONTag Documentation\"\n    click F \"flask_json.md\" \"TagMarkup Documentation\"\n    click G \"flask_json.md\" \"TagTuple Documentation\"\n    click H \"flask_json.md\" \"TagDict Documentation\"\n    click I \"flask_json.md\" \"TagUUID Documentation\"\n    click J \"flask_json.md\" \"TagDateTime Documentation\"\n    click K \"flask_json.md\" \"TagBytes Documentation\"\n    click L \"flask_json.md\" \"PassList Documentation\"\n    click M \"flask_json.md\" \"PassDict Documentation\"\n```\n\n## Integration with the Overall System\n\nThe `flask_json` module is tightly integrated with the core Flask application (`flask_app`). When a Flask application needs to send or receive JSON data, it consults the configured `JSONProvider` (typically `DefaultJSONProvider`).\n\nFor instance:\n*   When a view function returns a dictionary or a list, Flask's `Response` object (`flask_wrappers.md`) uses the `JSONProvider` to serialize this Python object into a JSON string, which is then sent as the HTTP response body with the appropriate `Content-Type: application/json` header.\n*   Conversely, when an incoming HTTP request has a `Content-Type: application/json` header, Flask's `Request` object (`flask_wrappers.md`) uses the `JSONProvider` to deserialize the request body JSON string into a Python object, making it accessible through `request.json` or `request.get_json()`.\n\nThis module ensures that developers can work with Python objects directly, abstracting away the complexities of JSON serialization and deserialization, while also providing hooks for extending this behavior for custom types.\n\nRefer to [flask_app.md](flask_app.md) for how the overall Flask application utilizes this module, and [flask_wrappers.md](flask_wrappers.md) for details on `Request` and `Response` objects that interact with JSON data.\n"
};
        const REPO_TITLE = 'flask';

        // State management
        let currentModule = 'overview';
        let navigationHistory = [];
        let expandedNodes = new Map(); // Track expanded nodes: nodeId -> {originalLabel, targetModuleId, subgraphId}
        let currentDiagramCode = '';
        let baseDiagramCode = '';
        let selectedNodeId = null;
        let selectedModuleId = null;
        
        // Module data structure (built from MODULE_TREE)
        let moduleData = {};
        let nodeIdToModule = {}; // Maps node IDs to module keys
        let moduleLinkMap = {}; // Maps module names to their links

        // Initialize marked
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });
        
        // Initialize mermaid
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Build module data from MODULE_TREE
        function buildModuleData() {
            // Create overview module - prefer extracted diagram from overview.md
            const fallbackDiagram = generateOverviewDiagram();
            const overviewMd = DOCS_CONTENT['overview.md'] || '';
            const extractedDiagram = extractMermaidFromMarkdown(overviewMd);
            const overviewDiagram = extractedDiagram || fallbackDiagram;
            
            const overviewLinks = {};
            
            // Build links for overview - each top-level module is a link
            for (const [key, data] of Object.entries(MODULE_TREE)) {
                const formattedName = formatModuleName(key);
                overviewLinks[formattedName] = key;
            }
            
            // If using extracted diagram, build links from click statements AND node labels
            if (extractedDiagram) {
                // First, parse click statements: click A "flask_app.md" "tooltip"
                // This provides the authoritative mapping from node ID to module
                const nodeIdToModule = {};
                const clickPattern = /click\s+([A-Za-z_][A-Za-z0-9_]*)\s+["']([^"']+\.md)["']/g;
                let clickMatch;
                while ((clickMatch = clickPattern.exec(extractedDiagram)) !== null) {
                    const nodeId = clickMatch[1];
                    const mdFile = clickMatch[2];
                    const moduleId = mdFile.replace('.md', '');
                    nodeIdToModule[nodeId] = moduleId;
                    console.log('[CLICK] Mapped node ID "' + nodeId + '" to module "' + moduleId + '"');
                }
                
                // Now parse node definitions to map labels to node IDs: A[text], A(text), etc.
                const nodePattern = /([A-Za-z_][A-Za-z0-9_]*)\s*(?:\["?([^"\]]+)"?\]|\("?([^"\)]+)"?\)|\{"?([^"\}]+)"?\}|\(\("?([^"\)]+)"?\)\))/g;
                let match;
                while ((match = nodePattern.exec(extractedDiagram)) !== null) {
                    const nodeId = match[1];
                    const label = (match[2] || match[3] || match[4] || match[5] || '').trim();
                    if (!label) continue;
                    
                    // If we have a click mapping for this node ID, use it
                    if (nodeIdToModule[nodeId]) {
                        overviewLinks[label] = nodeIdToModule[nodeId];
                        console.log('[LINK] Mapped label "' + label + '" to module "' + nodeIdToModule[nodeId] + '" via click');
                        continue;
                    }
                    
                    // Fallback: Try to match label to a module in MODULE_TREE
                    const labelLower = label.toLowerCase();
                    const labelNormalized = labelLower.replace(/[^a-z0-9]/g, '_');
                    
                    function findModuleRecursive(tree) {
                        for (const [modKey, modData] of Object.entries(tree)) {
                            const modKeyLower = modKey.toLowerCase();
                            if (modKeyLower === labelNormalized || 
                                modKeyLower === labelLower ||
                                formatModuleName(modKey).toLowerCase() === labelLower) {
                                return modKey;
                            }
                            const dottedLabel = labelLower.replace(/\./g, '_');
                            if (modKeyLower === dottedLabel) {
                                return modKey;
                            }
                            if (modData.children) {
                                const found = findModuleRecursive(modData.children);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    
                    const foundModule = findModuleRecursive(MODULE_TREE);
                    if (foundModule) {
                        overviewLinks[label] = foundModule;
                        console.log('[LINK] Mapped diagram label "' + label + '" to module "' + foundModule + '"');
                    }
                }
            }
            
            moduleData['overview'] = {
                name: REPO_TITLE + ' Overview',
                diagram: stripClickStatements(overviewDiagram),
                documentation: DOCS_CONTENT['overview.md'] || '# Overview\n\nNo overview available.',
                links: overviewLinks
            };
            
            // Build modules from tree
            buildModulesFromTree(MODULE_TREE, '');
        }

        function buildModulesFromTree(tree, parentPath) {
            for (const [key, data] of Object.entries(tree)) {
                const moduleId = parentPath ? `${parentPath}/${key}` : key;
                const formattedName = formatModuleName(key);
                
                // Try to find documentation file
                const docFilename = `${key}.md`;
                const documentation = DOCS_CONTENT[docFilename] || `# ${formattedName}\n\nNo documentation available.`;
                
                // FIX: Extract diagram from markdown FIRST, then fallback to generated
                const extractedDiagram = extractMermaidFromMarkdown(documentation);
                const diagram = extractedDiagram || generateModuleDiagram(key, data);
                
                // Strip click statements to allow custom click handling
                const cleanDiagram = diagram ? stripClickStatements(diagram) : diagram;
                
                // Build links for children
                const links = {};
                if (data.children) {
                    for (const [childKey, childData] of Object.entries(data.children)) {
                        const childFormattedName = formatModuleName(childKey);
                        links[childFormattedName] = childKey;
                    }
                }
                
                moduleData[key] = {
                    name: formattedName,
                    diagram: cleanDiagram,
                    documentation: documentation,
                    links: links,
                    children: data.children || {}
                };
                
                // Recursively build child modules
                if (data.children) {
                    buildModulesFromTree(data.children, moduleId);
                }
            }
        }

        function generateOverviewDiagram() {
            let diagram = 'graph TD\n';
            const repoNodeId = 'REPO';
            const repoLabel = escapeLabel(REPO_TITLE);
            diagram += `    ${repoNodeId}["${repoLabel}"]\n`;
            
            let nodeIndex = 0;
            for (const [key, data] of Object.entries(MODULE_TREE)) {
                const nodeId = `M${nodeIndex}`;
                const label = escapeLabel(formatModuleName(key));
                diagram += `    ${nodeId}["${label}"]\n`;
                diagram += `    ${repoNodeId} --> ${nodeId}\n`;
                nodeIdToModule[nodeId] = key;
                nodeIndex++;
            }
            
            return diagram;
        }

        function generateModuleDiagram(moduleKey, moduleData) {
            if (!moduleData.children || Object.keys(moduleData.children).length === 0) {
                // Leaf module - no sub-diagram
                return '';
            }
            
            let diagram = 'graph TD\n';
            const parentNodeId = 'PARENT';
            const parentLabel = escapeLabel(formatModuleName(moduleKey));
            diagram += `    ${parentNodeId}["${parentLabel}"]\n`;
            
            let nodeIndex = 0;
            for (const [childKey, childData] of Object.entries(moduleData.children)) {
                const nodeId = `C${nodeIndex}`;
                const label = escapeLabel(formatModuleName(childKey));
                diagram += `    ${nodeId}["${label}"]\n`;
                diagram += `    ${parentNodeId} --> ${nodeId}\n`;
                nodeIdToModule[nodeId] = childKey;
                nodeIndex++;
            }
            
            return diagram;
        }
        
        function escapeLabel(label) {
            // Escape special characters that cause mermaid syntax errors
            return label
                .replace(/"/g, "'")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/&(?!lt;|gt;|amp;)/g, "&amp;");
        }

        function formatModuleName(key) {
            return key
                .replace(/_/g, ' ')
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function escapeLabel(label) {
            // Escape special characters that cause mermaid syntax errors
            return label
                .replace(/"/g, "'")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/&(?!lt;|gt;|amp;)/g, "&amp;");
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            buildModuleData();
            loadModule('overview');
        });

        function loadModule(moduleId, skipHistoryUpdate = false) {
            if (!moduleData || !moduleData[moduleId]) {
                console.error('Module not found:', moduleId);
                return;
            }

            const module = moduleData[moduleId];
            currentModule = moduleId;
            
            // Reset expansion state when loading new module
            expandedNodes.clear();
            selectedNodeId = null;
            selectedModuleId = null;
            baseDiagramCode = module.diagram || '';
            currentDiagramCode = module.diagram || '';

            // Update title
            document.getElementById('moduleTitle').textContent = module.name;

            // Update back button
            const backButton = document.getElementById('backButton');
            if (navigationHistory.length > 0) {
                backButton.style.display = 'inline-block';
                backButton.disabled = false;
            } else if (moduleId === 'overview') {
                backButton.style.display = 'none';
            } else {
                backButton.style.display = 'inline-block';
                backButton.disabled = true;
            }

            // Render documentation
            renderDocumentation(module.documentation);

            // Render diagram
            if (module.diagram && module.diagram.trim()) {
                renderDiagram(module.diagram, module.links || {}, moduleId);
            } else {
                // No diagram - try to extract from markdown
                const extracted = extractMermaidFromMarkdown(module.documentation);
                if (extracted) {
                    renderDiagram(extracted, module.links || {}, moduleId);
                } else {
                    document.getElementById('mermaid-diagram').innerHTML = '<p style="color: #64748b;">No diagram available for this module.</p>';
                }
            }
        }

        function extractMermaidFromMarkdown(markdown) {
            const mermaidRegex = /```mermaid\n([\s\S]*?)```/g;
            const match = mermaidRegex.exec(markdown);
            return match ? match[1].trim() : null;
        }
        
        function stripClickStatements(diagram) {
            // Strip out click statements to allow custom click handling
            // Also strip :::className styling from node definitions (causes issues with subgraph insertion)
            let cleaned = diagram.replace(/^\s*click\s+.+$/gm, '');
            cleaned = cleaned.replace(/:::[a-zA-Z_][a-zA-Z0-9_]*/g, '');
            return cleaned;
        }

        // Combine links from current module + all expanded modules
        // This ensures that expanded subgraph children are clickable
        function getCombinedLinks() {
            const combined = {};
            
            // Add current module's links
            const current = moduleData[currentModule];
            if (current && current.links) {
                Object.assign(combined, current.links);
            }
            
            // Add links from all expanded modules
            for (const [nodeId, expansion] of expandedNodes.entries()) {
                const expandedMod = moduleData[expansion.targetModuleId];
                if (expandedMod && expandedMod.links) {
                    // Prefix the links to match the prefixed node IDs in the subgraph
                    const prefix = `${nodeId}_`;
                    for (const [label, targetId] of Object.entries(expandedMod.links)) {
                        combined[label] = targetId;
                    }
                }
            }
            
            return combined;
        }

        function selectNode(nodeId, moduleId) {
            
            selectedNodeId = nodeId;
            selectedModuleId = moduleId;
            
            // Load selected module's documentation
            if (moduleData && moduleData[moduleId]) {
                const module = moduleData[moduleId];
                renderDocumentation(module.documentation || 'No documentation available.');
                document.getElementById('moduleTitle').textContent = module.name || moduleId;
            }
            
            // Re-render diagram to apply selected styling - use combined links for expanded nodes
            renderDiagram(currentDiagramCode || baseDiagramCode, getCombinedLinks(), currentModule);
        }

        function renderDocumentation(markdown) {
            // Remove mermaid blocks from display
            const cleanMarkdown = markdown.replace(/```mermaid\n[\s\S]*?```/g, '');
            const html = marked.parse(cleanMarkdown);
            document.getElementById('docContent').innerHTML = html;

            // Make .md links clickable
            document.querySelectorAll('#docContent a[href$=".md"]').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                const href = link.getAttribute('href');
                    const moduleId = href.replace('.md', '');
                    navigateToModule(moduleId);
                });
            });
            
            // Also handle anchor links that reference module documentation
            // LLM-generated docs often use anchors like #file-management-tools-module-documentation
            document.querySelectorAll('#docContent a[href^="#"]').forEach(link => {
                link.addEventListener('click', (e) => {
                    const href = link.getAttribute('href');
                    // Convert anchor to potential module ID
                    // E.g., #file-management-tools-module-documentation -> file_management_tools
                    const anchor = href.substring(1); // Remove #
                    const potentialModuleId = anchor
                        .replace(/-module-documentation$/, '')
                        .replace(/-module$/, '')
                        .replace(/-/g, '_');
                    
                    // Check if this maps to an existing module
                    if (moduleData[potentialModuleId]) {
                    e.preventDefault();
                        navigateToModule(potentialModuleId);
                    }
                    // Otherwise let the normal anchor behavior proceed
                });
            });
        }

        function expandNodeInline(nodeId, targetModuleId) {
            if (!nodeId || !targetModuleId || !moduleData[targetModuleId]) {
                console.error(`Cannot expand: nodeId=${nodeId}, module=${targetModuleId}`);
                return;
            }
            
            if (expandedNodes.has(nodeId)) {
                console.log(`Node ${nodeId} is already expanded`);
                return;
            }
            
            const targetModule = moduleData[targetModuleId];
            if (!targetModule.diagram) {
                console.log(`Module ${targetModuleId} has no diagram - just selecting`);
                selectNode(nodeId, targetModuleId);
                return;
            }
            
            
            // Find node's original label in base diagram
            let workingDiagram = baseDiagramCode;
            const nodeDefPattern = new RegExp(`\\b${nodeId}\\s*\\["?([^"\\]]+)"?\\]`);
            const baseNodeMatch = workingDiagram.match(nodeDefPattern);
            
            if (!baseNodeMatch) {
                // Try current diagram
                const currentNodeMatch = currentDiagramCode.match(nodeDefPattern);
                if (!currentNodeMatch) {
                    console.error(`Could not find node ${nodeId}`);
                    return;
                }
            }
            
            const originalLabel = baseNodeMatch ? baseNodeMatch[1].trim() : formatModuleName(targetModuleId);
            const subgraphId = `${nodeId}_sub`;
            const prefix = `${nodeId}_`;
            const collapseNodeId = `${prefix}collapse`;
            
            expandedNodes.set(nodeId, {
                originalLabel: originalLabel,
                targetModuleId: targetModuleId,
                subgraphId: subgraphId,
                collapseNodeId: collapseNodeId
            });
            
            // Rebuild diagram with all expansions
            const sortedExpansions = Array.from(expandedNodes.entries()).sort((a, b) => {
                const depthA = (a[0].match(/_/g) || []).length;
                const depthB = (b[0].match(/_/g) || []).length;
                return depthA - depthB;
            });
            
            for (const [expNodeId, expState] of sortedExpansions) {
                workingDiagram = applyExpansionToDiagram(workingDiagram, expNodeId, expState.targetModuleId, expState.originalLabel);
            }
            
            currentDiagramCode = workingDiagram;
            selectNode(subgraphId, targetModuleId);
        }

        function collapseNode(nodeId) {
            if (!expandedNodes.has(nodeId)) {
                console.log(`Node ${nodeId} is not expanded`);
                return;
            }
            
            console.log(`[COLLAPSE] Collapsing node ${nodeId}`);
            
            // Also collapse child expansions
            const nodesToCollapse = [nodeId];
            for (const [expNodeId] of expandedNodes.entries()) {
                if (expNodeId.startsWith(nodeId + '_') && !expNodeId.endsWith('_collapse')) {
                    nodesToCollapse.push(expNodeId);
                }
            }
            
            for (const nodeToRemove of nodesToCollapse) {
                expandedNodes.delete(nodeToRemove);
            }
            
            // Rebuild from base
            let rebuiltDiagram = baseDiagramCode;
            const sortedExpansions = Array.from(expandedNodes.entries()).sort((a, b) => {
                const depthA = (a[0].match(/_/g) || []).length;
                const depthB = (b[0].match(/_/g) || []).length;
                return depthA - depthB;
            });
            
            for (const [expNodeId, expState] of sortedExpansions) {
                rebuiltDiagram = applyExpansionToDiagram(rebuiltDiagram, expNodeId, expState.targetModuleId, expState.originalLabel);
            }
            
            currentDiagramCode = rebuiltDiagram;
            selectedNodeId = null;
            selectedModuleId = null;
            
            // Use combined links for remaining expanded nodes
            renderDiagram(rebuiltDiagram, getCombinedLinks(), currentModule);
        }

        function applyExpansionToDiagram(diagram, nodeId, targetModuleId, originalLabel) {
            const targetModule = moduleData[targetModuleId];
            if (!targetModule || !targetModule.diagram) {
                return diagram;
            }
            
            const subgraphName = `${nodeId}_sub`;
            const prefix = `${nodeId}_`;
            const collapseNodeId = `${prefix}collapse`;
            
            // Get target module's diagram content
            let subgraphContent = targetModule.diagram.trim().replace(/^(graph|flowchart)\s+\w+\s*\n?/, '');
            
            // Strip out styling statements that are incompatible with subgraphs
            subgraphContent = subgraphContent.replace(/^\s*classDef\s+.+$/gm, '');
            subgraphContent = subgraphContent.replace(/^\s*class\s+.+$/gm, '');
            subgraphContent = subgraphContent.replace(/:::[a-zA-Z_][a-zA-Z0-9_]*/g, '');
            
            // Prefix all node IDs to avoid conflicts - match uppercase letter sequences possibly followed by numbers
            const nodeIdMatches = [...subgraphContent.matchAll(/\b([A-Z][A-Za-z0-9_]*)\b(?=\s*\[|\s*--)/g)];
            const uniqueIds = [...new Set(nodeIdMatches.map(m => m[1]))];
            for (const oldId of uniqueIds) {
                const newId = prefix + oldId;
                subgraphContent = subgraphContent.replace(new RegExp(`\\b${oldId}\\b`, 'g'), newId);
            }
            
            // Build subgraph block
            const subgraphLines = subgraphContent.split('\n').filter(l => l.trim());
            const indentedContent = subgraphLines.map(l => '        ' + l.trim()).join('\n');
            const subgraphDef = `    subgraph ${subgraphName} ["${originalLabel}"]\n${indentedContent}\n        ${collapseNodeId}["[-] Collapse"]\n    end`;
            
            // STEP 1: Remove the node DEFINITION (the [label] part) but keep the node ID for edges
            // This handles both standalone definitions and inline definitions in edges
            // Pattern: nodeId[anything] or nodeId["anything"] optionally with :::class
            let newDiagram = diagram.replace(
                new RegExp(`${nodeId}\\[[^\\]]+\\](?:::[a-zA-Z_][a-zA-Z0-9_]*)?`, 'g'),
                nodeId
            );
            
            // STEP 2: Update all edge references from nodeId to subgraphName
            // Match nodeId only when not followed by underscore (to avoid matching prefixed nodes)
            newDiagram = newDiagram.replace(
                new RegExp(`\\b${nodeId}\\b(?!_)`, 'g'),
                subgraphName
            );
            
            // STEP 3: Add subgraph definition at the end
            // Insert before any trailing whitespace
            newDiagram = newDiagram.trimEnd() + '\n\n' + subgraphDef + '\n';
            
            // Ensure graph declaration
            if (!newDiagram.trim().startsWith('graph') && !newDiagram.trim().startsWith('flowchart')) {
                newDiagram = 'graph TD\n' + newDiagram;
            }
            
            return newDiagram;
        }

        function renderDiagram(diagramCode, links, currentModuleId) {
            if (!diagramCode) {
                document.getElementById('mermaid-diagram').innerHTML = '<p style="color: #64748b;">No diagram available.</p>';
                return;
            }
            
            currentDiagramCode = diagramCode;
            
            // Build node mappings
            const localNodeIdToModule = {};
            const labelToNodeId = {};
            
            const nodePattern = /(\w+)\["?([^"\]]+)"?\]/g;
            let match;
            while ((match = nodePattern.exec(diagramCode)) !== null) {
                const nodeId = match[1];
                const label = match[2].trim();
                labelToNodeId[label] = nodeId;
                
                // Match label to links
                for (const [linkText, moduleId] of Object.entries(links)) {
                    if (label.toLowerCase() === linkText.toLowerCase() ||
                        label.toLowerCase().includes(linkText.toLowerCase()) ||
                        linkText.toLowerCase().includes(label.toLowerCase())) {
                        localNodeIdToModule[nodeId] = moduleId;
                        break;
                    }
                }
            }
            
            // Ensure graph declaration
            let finalDiagramCode = diagramCode.trim();
            if (!finalDiagramCode.startsWith('graph ')) {
                finalDiagramCode = 'graph TD\n' + finalDiagramCode;
            }
            
            const diagramDiv = document.getElementById('mermaid-diagram');
            diagramDiv.innerHTML = '<div class="loading">Rendering diagram...</div>';
            const diagramId = 'diagram-' + Date.now();

            (async () => {
                try {
                    const { svg } = await mermaid.render(diagramId, finalDiagramCode);
                    diagramDiv.innerHTML = svg;
                    
                    const processedNodes = new WeakSet();
                    
                    const processNodes = () => {
                        const svgEl = diagramDiv.querySelector('svg');
                        if (!svgEl) return;
                        
                        const nodeGroups = svgEl.querySelectorAll('g.node');
                        
                        nodeGroups.forEach((nodeGroup, idx) => {
                            if (processedNodes.has(nodeGroup)) return;
                            
                            // Extract node ID from SVG element
                            let svgNodeId = null;
                            const groupId = nodeGroup.id || '';
                            const idMatch = groupId.match(/flowchart-([A-Za-z0-9_]+)-\d+/);
                            if (idMatch) {
                                svgNodeId = idMatch[1];
                            }
                            
                            // Get text content - Mermaid 11.x may use different structures
                            let fullText = '';
                            
                            // Method 1: Direct text/tspan elements
                            const textElements = nodeGroup.querySelectorAll('text, tspan');
                            textElements.forEach(el => {
                                const text = el.textContent.trim();
                                if (text && !fullText.includes(text)) {
                                    fullText += (fullText ? ' ' : '') + text;
                                }
                            });
                            
                            // Method 2: foreignObject elements (Mermaid 11.x uses these)
                            if (!fullText) {
                                const foreignObjects = nodeGroup.querySelectorAll('foreignObject');
                                foreignObjects.forEach(fo => {
                                    const text = fo.textContent.trim();
                                    if (text && !fullText.includes(text)) {
                                        fullText += (fullText ? ' ' : '') + text;
                                    }
                                });
                            }
                            
                            // Method 3: span/div inside foreignObject
                            if (!fullText) {
                                const spans = nodeGroup.querySelectorAll('foreignObject span, foreignObject div, foreignObject p');
                                spans.forEach(el => {
                                    const text = el.textContent.trim();
                                    if (text && !fullText.includes(text)) {
                                        fullText += (fullText ? ' ' : '') + text;
                                    }
                                });
                            }
                            
                            // Method 4: Any text content in the node
                            if (!fullText) {
                                fullText = nodeGroup.textContent.trim();
                            }
                            
                            fullText = fullText.trim();
                            
                            if (!fullText) return;
                            
                            // Check for collapse button
                            if (fullText.includes('Collapse') || fullText === '[-] Collapse') {
                                processedNodes.add(nodeGroup);
                                
                                let collapseNodeId = null;
                                if (svgNodeId && svgNodeId.endsWith('_collapse')) {
                                    collapseNodeId = svgNodeId.replace(/_collapse$/, '');
                                }
                                
                                if (collapseNodeId && expandedNodes.has(collapseNodeId)) {
                                    const capturedNodeId = collapseNodeId;
                                    
                                    nodeGroup.style.cursor = 'pointer';
                                    nodeGroup.classList.add('collapse-button');
                                    
                                    const shapes = nodeGroup.querySelectorAll('rect, circle, polygon, path, ellipse');
                                    shapes.forEach(shape => {
                                        shape.setAttribute('stroke', '#dc2626');
                                        shape.setAttribute('stroke-width', '2');
                                    });
                                    
                                    const collapseHandler = (e) => {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        collapseNode(capturedNodeId);
                                    };
                                    
                                    nodeGroup.addEventListener('click', collapseHandler, true);
                                    nodeGroup.querySelectorAll('*').forEach(child => {
                                        child.style.cursor = 'pointer';
                                        child.addEventListener('click', collapseHandler, true);
                                    });
                                }
                                return;
                            }
                            
                            // Find target module
                            let targetModule = null;
                            let nodeId = svgNodeId;
                            
                            console.log('[PROCESS] Node:', svgNodeId, 'Text:', fullText, 'Links keys:', Object.keys(links).slice(0,5));
                            
                            // Try to match by node ID
                            if (svgNodeId && localNodeIdToModule[svgNodeId]) {
                                targetModule = localNodeIdToModule[svgNodeId];
                                console.log('[PROCESS] Matched by ID:', svgNodeId, '->', targetModule);
                            }
                            
                            // Try to match by text
                            if (!targetModule) {
                                for (const [linkText, moduleId] of Object.entries(links)) {
                                    if (fullText.toLowerCase() === linkText.toLowerCase() ||
                                        fullText.toLowerCase().includes(linkText.toLowerCase())) {
                                        targetModule = moduleId;
                                        console.log('[PROCESS] Matched by text:', fullText, '->', moduleId);
                                        if (!nodeId) {
                                            nodeId = labelToNodeId[fullText] || linkText.replace(/\s+/g, '_');
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            if (targetModule && moduleData[targetModule]) {
                                console.log('[PROCESS] Making clickable:', fullText, '->', targetModule);
                                processedNodes.add(nodeGroup);
                                makeNodeBlueAndClickable(nodeGroup, targetModule, fullText, nodeId);
                            } else {
                                console.log('[PROCESS] No match for:', fullText, 'targetModule:', targetModule, 'inModuleData:', !!moduleData[targetModule]);
                            }
                        });
                        
                        // Apply selected styling to subgraphs
                        if (selectedNodeId && selectedNodeId.endsWith('_sub')) {
                            const subgraphs = svgEl.querySelectorAll('g.cluster');
                            subgraphs.forEach(sg => {
                                const sgId = sg.id || '';
                                if (sgId.includes(selectedNodeId) || sgId.includes(selectedNodeId.replace('_sub', ''))) {
                                    sg.classList.add('selected-subgraph');
                                    const rects = sg.querySelectorAll('rect');
                                    rects.forEach(rect => {
                                        rect.setAttribute('stroke', '#10b981');
                                        rect.setAttribute('stroke-width', '3');
                                    });
                                }
                            });
                        }
                    };
                    
                    processNodes();
                    setTimeout(processNodes, 100);
                    setTimeout(processNodes, 500);
                    
                } catch (error) {
                    console.error('Error rendering diagram:', error);
                    diagramDiv.innerHTML = '<p style="color: #dc2626;">Error rendering diagram.</p>';
                }
            })();
        }

        function makeNodeBlueAndClickable(nodeGroup, targetModule, displayText, nodeId) {
            // Make shapes blue
            const shapes = nodeGroup.querySelectorAll('rect, circle, polygon, path, ellipse');
            shapes.forEach(shape => {
                shape.setAttribute('stroke', '#2563eb');
                shape.setAttribute('stroke-width', '3');
                shape.style.setProperty('stroke', '#2563eb', 'important');
                shape.style.setProperty('stroke-width', '3px', 'important');
            });
            
            // Bold text
            const texts = nodeGroup.querySelectorAll('text, tspan');
            texts.forEach(txt => {
                txt.style.fontWeight = '600';
            });
            
            // Make clickable
            nodeGroup.style.cursor = 'pointer';
            nodeGroup.classList.add('clickable-node');
            nodeGroup.setAttribute('title', `Click to expand: ${displayText}`);
            nodeGroup.setAttribute('data-node-id', nodeId);
            
            const capturedTargetModule = targetModule;
            const capturedNodeId = nodeId;
            
            const clickHandler = (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                if (capturedNodeId && capturedTargetModule && moduleData[capturedTargetModule]) {
                    const targetModuleData = moduleData[capturedTargetModule];
                    if (targetModuleData.diagram && targetModuleData.diagram.trim()) {
                        if (!expandedNodes.has(capturedNodeId)) {
                            expandNodeInline(capturedNodeId, capturedTargetModule);
                        } else {
                            selectNode(`${capturedNodeId}_sub`, capturedTargetModule);
                        }
                    } else {
                        selectNode(capturedNodeId, capturedTargetModule);
                    }
                }
            };
            
            nodeGroup.addEventListener('click', clickHandler, true);
            nodeGroup.querySelectorAll('*').forEach(child => {
                child.style.cursor = 'pointer';
                child.addEventListener('click', clickHandler, true);
            });
            
            // Hover effects
            nodeGroup.addEventListener('mouseenter', () => {
                shapes.forEach(shape => {
                    if (shape.parentNode) {
                        shape.style.strokeWidth = '4px';
                    }
                });
            });
            nodeGroup.addEventListener('mouseleave', () => {
                shapes.forEach(shape => {
                    if (shape.parentNode) {
                        shape.style.strokeWidth = '3px';
                    }
                });
            });
            
            // Apply selected styling if this node is selected
            if (selectedNodeId === nodeId && selectedModuleId === targetModule) {
                nodeGroup.classList.add('selected-node');
                shapes.forEach(shape => {
                    shape.setAttribute('stroke', '#10b981');
                    shape.setAttribute('stroke-width', '4');
                    shape.style.setProperty('stroke', '#10b981', 'important');
                    shape.style.setProperty('stroke-width', '4px', 'important');
                });
            }
        }

        function navigateToModule(moduleId) {
            if (!moduleData[moduleId]) {
                console.error(`Module not found: ${moduleId}`);
                return;
            }
            
            if (currentModule !== moduleId) {
                navigationHistory.push(currentModule);
                loadModule(moduleId);
            }
        }

        function goBack() {
            if (navigationHistory.length > 0) {
                const previousModule = navigationHistory.pop();
                if (previousModule && moduleData[previousModule]) {
                    loadModule(previousModule, true);
                } else {
                    navigationHistory = [];
                    loadModule('overview', true);
                }
            } else if (currentModule !== 'overview') {
                loadModule('overview', true);
            }
        }

        window.addEventListener('popstate', () => {
            goBack();
        });

        // Helper - click node by label (for testing)
        window.clickNode = function(label) {
            const nodes = document.querySelectorAll('.clickable-node');
            for (const node of nodes) {
                const title = node.getAttribute('title') || '';
                if (title.toLowerCase().includes(label.toLowerCase())) {
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    node.dispatchEvent(clickEvent);
                    return true;
                }
            }
            return false;
        };

        // Keyboard shortcuts - press 1-9 to click on Nth clickable node in diagram
        // Prioritizes child nodes in expanded subgraphs over their expanded parents
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const keyNum = parseInt(e.key);
            if (keyNum >= 1 && keyNum <= 9) {
                // Find all clickable nodes in the current diagram
                const svg = document.querySelector('#mermaid-diagram svg');
                if (!svg) return;
                
                const allClickableNodes = Array.from(svg.querySelectorAll('.clickable-node'));
                
                // Separate nodes: those inside subgraphs (children) vs those outside (parents)
                const childNodes = [];
                const parentNodes = [];
                
                allClickableNodes.forEach(node => {
                    // Check if this node is inside a subgraph (cluster)
                    const isInSubgraph = node.closest('g.cluster') !== null;
                    if (isInSubgraph) {
                        childNodes.push(node);
                    } else {
                        parentNodes.push(node);
                    }
                });
                
                // Prioritize child nodes first, then parent nodes
                const prioritizedNodes = [...childNodes, ...parentNodes];
                const index = keyNum - 1;
                
                if (index < prioritizedNodes.length) {
                    const node = prioritizedNodes[index];
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    node.dispatchEvent(clickEvent);
                }
            }
        });
    </script>
</body>
</html>
