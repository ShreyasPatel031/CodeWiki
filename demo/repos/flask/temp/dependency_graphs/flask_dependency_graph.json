{
  "src.flask.app._make_timedelta": {
    "id": "src.flask.app._make_timedelta",
    "name": "_make_timedelta",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/app.py",
    "relative_path": "src/flask/app.py",
    "depends_on": [],
    "source_code": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
    "start_line": 72,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _make_timedelta",
    "component_id": "src.flask.app._make_timedelta"
  },
  "src.flask.app.remove_ctx": {
    "id": "src.flask.app.remove_ctx",
    "name": "remove_ctx",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/app.py",
    "relative_path": "src/flask/app.py",
    "depends_on": [],
    "source_code": "def remove_ctx(f: F) -> F:\n    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if args and isinstance(args[0], AppContext):\n            args = args[1:]\n\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]",
    "start_line": 84,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function remove_ctx",
    "component_id": "src.flask.app.remove_ctx"
  },
  "src.flask.app.wrapper": {
    "id": "src.flask.app.wrapper",
    "name": "wrapper",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/app.py",
    "relative_path": "src/flask/app.py",
    "depends_on": [],
    "source_code": "    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not args:\n            args = (app_ctx._get_current_object(),)\n        elif not isinstance(args[0], AppContext):\n            args = (app_ctx._get_current_object(), *args)\n\n        return f(self, *args, **kwargs)",
    "start_line": 97,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function wrapper",
    "component_id": "src.flask.app.wrapper"
  },
  "src.flask.app.add_ctx": {
    "id": "src.flask.app.add_ctx",
    "name": "add_ctx",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/app.py",
    "relative_path": "src/flask/app.py",
    "depends_on": [],
    "source_code": "def add_ctx(f: F) -> F:\n    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not args:\n            args = (app_ctx._get_current_object(),)\n        elif not isinstance(args[0], AppContext):\n            args = (app_ctx._get_current_object(), *args)\n\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]",
    "start_line": 96,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_ctx",
    "component_id": "src.flask.app.add_ctx"
  },
  "src.flask.app.Flask": {
    "id": "src.flask.app.Flask",
    "name": "Flask",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/app.py",
    "relative_path": "src/flask/app.py",
    "depends_on": [
      "src.flask.helpers.send_from_directory",
      "src.flask.cli.load_dotenv",
      "src.flask.cli.AppGroup",
      "src.flask.app.remove_ctx",
      "src.flask.app.add_ctx",
      "src.flask.testing.EnvironBuilder",
      "src.flask.helpers.get_load_dotenv",
      "src.flask.debughelpers.FormDataRoutingRedirect",
      "src.flask.cli.show_server_banner",
      "src.flask.helpers.make_response",
      "src.flask.sessions.SecureCookieSessionInterface",
      "src.flask.ctx.AppContext",
      "src.flask.helpers.get_debug_flag"
    ],
    "source_code": "class Flask(App):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        ``static_url_path``. Relative to the application ``root_path``\n        or an absolute path. Defaults to ``'static'``.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: The path to the root of the application files.\n        This should only be set manually when it can't be detected\n        automatically, such as for namespace packages.\n    \"\"\"\n\n    default_config = ImmutableDict(\n        {\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"SECRET_KEY\": None,\n            \"SECRET_KEY_FALLBACKS\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"TRUSTED_HOSTS\": None,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_PARTITIONED\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"MAX_FORM_MEMORY_SIZE\": 500_000,\n            \"MAX_FORM_PARTS\": 1_000,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n            \"PROVIDE_AUTOMATIC_OPTIONS\": True,\n        }\n    )\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class: type[Request] = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class: type[Response] = Response\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface: SessionInterface = SecureCookieSessionInterface()\n\n    def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        import warnings\n\n        # These method signatures were updated to take a ctx param. Detect\n        # overridden methods in subclasses that still have the old signature.\n        # Show a deprecation warning and wrap to call with correct args.\n        for method in (\n            cls.handle_http_exception,\n            cls.handle_user_exception,\n            cls.handle_exception,\n            cls.log_exception,\n            cls.dispatch_request,\n            cls.full_dispatch_request,\n            cls.finalize_request,\n            cls.make_default_options_response,\n            cls.preprocess_request,\n            cls.process_response,\n            cls.do_teardown_request,\n            cls.do_teardown_appcontext,\n        ):\n            base_method = getattr(Flask, method.__name__)\n\n            if method is base_method:\n                # not overridden\n                continue\n\n            # get the second parameter (first is self)\n            iter_params = iter(inspect.signature(method).parameters.values())\n            next(iter_params)\n            param = next(iter_params, None)\n\n            # must have second parameter named ctx or annotated AppContext\n            if param is None or not (\n                # no annotation, match name\n                (param.annotation is inspect.Parameter.empty and param.name == \"ctx\")\n                or (\n                    # string annotation, access path ends with AppContext\n                    isinstance(param.annotation, str)\n                    and param.annotation.rpartition(\".\")[2] == \"AppContext\"\n                )\n                or (\n                    # class annotation\n                    inspect.isclass(param.annotation)\n                    and issubclass(param.annotation, AppContext)\n                )\n            ):\n                warnings.warn(\n                    f\"The '{method.__name__}' method now takes 'ctx: AppContext'\"\n                    \" as the first parameter. The old signature is deprecated\"\n                    \" and will not be supported in Flask 4.0.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n                setattr(cls, method.__name__, remove_ctx(method))\n                setattr(Flask, method.__name__, add_ctx(base_method))\n\n    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_folder=static_folder,\n            static_host=static_host,\n            host_matching=host_matching,\n            subdomain_matching=subdomain_matching,\n            template_folder=template_folder,\n            instance_path=instance_path,\n            instance_relative_config=instance_relative_config,\n            root_path=root_path,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = cli.AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, (\n                \"Invalid static_host/host_matching combination\"\n            )\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )\n\n    def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = self.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value  # type: ignore[no-any-return]\n\n    def send_static_file(self, filename: str) -> Response:\n        \"\"\"The view function used to serve files from\n        :attr:`static_folder`. A route is automatically registered for\n        this view at :attr:`static_url_path` if :attr:`static_folder` is\n        set.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionadded:: 0.5\n\n        \"\"\"\n        if not self.has_static_folder:\n            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n\n        # send_file only knows to call get_send_file_max_age on the app,\n        # call it here so it works for blueprints too.\n        max_age = self.get_send_file_max_age(filename)\n        return send_from_directory(\n            t.cast(str, self.static_folder), filename, max_age=max_age\n        )\n\n    def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = None\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading.\n\n        For example, if the file ``schema.sql`` is next to the file\n        ``app.py`` where the ``Flask`` app is defined, it can be opened\n        with:\n\n        .. code-block:: python\n\n            with app.open_resource(\"schema.sql\") as f:\n                conn.executescript(f.read())\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)\n\n    def open_instance_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to the application's instance folder\n        :attr:`instance_path`. Unlike :meth:`open_resource`, files in the\n        instance folder can be opened for writing.\n\n        :param resource: Path to the resource relative to :attr:`instance_path`.\n        :param mode: Open the file in this mode.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        path = os.path.join(self.instance_path, resource)\n\n        if \"b\" in mode:\n            return open(path, mode)\n\n        return open(path, mode, encoding=encoding)\n\n    def create_jinja_environment(self) -> Environment:\n        \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n        and the various Jinja-related methods of the app. Changing\n        :attr:`jinja_options` after this will have no effect. Also adds\n        Flask-related globals and filters to the environment.\n\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            auto_reload = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n\n            if auto_reload is None:\n                auto_reload = self.debug\n\n            options[\"auto_reload\"] = auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=self.url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.policies[\"json.dumps_function\"] = self.json.dumps\n        return rv\n\n    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionchanged:: 3.1\n            If :data:`SERVER_NAME` is set, it does not restrict requests to\n            only that domain, for both ``subdomain_matching`` and\n            ``host_matching``.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n\n        .. versionchanged:: 0.9\n           This can be called outside a request when the URL adapter is created\n           for an application context.\n\n        .. versionadded:: 0.6\n        \"\"\"\n        if request is not None:\n            if (trusted_hosts := self.config[\"TRUSTED_HOSTS\"]) is not None:\n                request.trusted_hosts = trusted_hosts\n\n            # Check trusted_hosts here until bind_to_environ does.\n            request.host = get_host(request.environ, request.trusted_hosts)  # pyright: ignore\n            subdomain = None\n            server_name = self.config[\"SERVER_NAME\"]\n\n            if self.url_map.host_matching:\n                # Don't pass SERVER_NAME, otherwise it's used and the actual\n                # host is ignored, which breaks host matching.\n                server_name = None\n            elif not self.subdomain_matching:\n                # Werkzeug doesn't implement subdomain matching yet. Until then,\n                # disable it by forcing the current subdomain to the default, or\n                # the empty string.\n                subdomain = self.url_map.default_subdomain or \"\"\n\n            return self.url_map.bind_to_environ(\n                request.environ, server_name=server_name, subdomain=subdomain\n            )\n\n        # Need at least SERVER_NAME to match/build outside a request.\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n\n        return None\n\n    def raise_routing_exception(self, request: Request) -> t.NoReturn:\n        \"\"\"Intercept routing exceptions and possibly do something else.\n\n        In debug mode, intercept a routing redirect and replace it with\n        an error if the body will be discarded.\n\n        With modern Werkzeug this shouldn't occur, since it now uses a\n        308 status which tells the browser to resend the method and\n        body.\n\n        .. versionchanged:: 2.1\n            Don't intercept 307 and 308 redirects.\n\n        :meta private:\n        :internal:\n        \"\"\"\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.routing_exception.code in {307, 308}\n            or request.method in {\"GET\", \"HEAD\", \"OPTIONS\"}\n        ):\n            raise request.routing_exception  # type: ignore[misc]\n\n        from .debughelpers import FormDataRoutingRedirect\n\n        raise FormDataRoutingRedirect(request)\n\n    def update_template_context(\n        self, ctx: AppContext, context: dict[str, t.Any]\n    ) -> None:\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        names: t.Iterable[str | None] = (None,)\n\n        # A template may be rendered outside a request context.\n        if ctx.has_request:\n            names = chain(names, reversed(ctx.request.blueprints))\n\n        # The values passed to render_template take precedence. Keep a\n        # copy to re-apply after all context functions.\n        orig_ctx = context.copy()\n\n        for name in names:\n            if name in self.template_context_processors:\n                for func in self.template_context_processors[name]:\n                    context.update(self.ensure_sync(func)())\n\n        context.update(orig_ctx)\n\n    def make_shell_context(self) -> dict[str, t.Any]:\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    def run(\n        self,\n        host: str | None = None,\n        port: int | None = None,\n        debug: bool | None = None,\n        load_dotenv: bool = True,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Ignore this call so that it doesn't start another server if\n        # the 'flask run' command is used.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            if not is_running_from_reloader():\n                click.secho(\n                    \" * Ignoring a call to 'app.run()' that would block\"\n                    \" the current 'flask' CLI command.\\n\"\n                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n                    ' \"__main__\"\\' guard.',\n                    fg=\"red\",\n                )\n\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, env var overrides existing value\n            if \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(t.cast(str, host), port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :doc:`/testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(  # type: ignore\n            self, self.response_class, use_cookies=use_cookies, **kwargs\n        )\n\n    def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)  # type: ignore\n\n    def handle_http_exception(\n        self, ctx: AppContext, e: HTTPException\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, ctx.request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_user_exception(\n        self, ctx: AppContext, e: Exception\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        if isinstance(e, BadRequestKeyError) and (\n            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        ):\n            e.show_exception = True\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(ctx, e)\n\n        handler = self._find_error_handler(e, ctx.request.blueprints)\n\n        if handler is None:\n            raise\n\n        return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]\n\n    def handle_exception(self, ctx: AppContext, e: Exception) -> Response:\n        \"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\n        mode, the error will be re-raised so that the debugger can\n        display it. Otherwise, the original exception is logged, and\n        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n\n        If an error handler is registered for ``InternalServerError`` or\n        ``500``, it will be used. For consistency, the handler will\n        always receive the ``InternalServerError``. The original\n        unhandled exception is available as ``e.original_exception``.\n\n        .. versionchanged:: 1.1.0\n            Always passes the ``InternalServerError`` instance to the\n            handler, setting ``original_exception`` to the unhandled\n            error.\n\n        .. versionchanged:: 1.1.0\n            ``after_request`` functions and other finalization is done\n            even for the default 500 response when there is no handler.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_info = sys.exc_info()\n        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)\n        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]\n\n        if propagate is None:\n            propagate = self.testing or self.debug\n\n        if propagate:\n            # Re-raise if called with an active exception, otherwise\n            # raise the passed in exception.\n            if exc_info[1] is e:\n                raise\n\n            raise e\n\n        self.log_exception(ctx, exc_info)\n        server_error: InternalServerError | ft.ResponseReturnValue\n        server_error = InternalServerError(original_exception=e)\n        handler = self._find_error_handler(server_error, ctx.request.blueprints)\n\n        if handler is not None:\n            server_error = self.ensure_sync(handler)(server_error)\n\n        return self.finalize_request(ctx, server_error, from_error_handler=True)\n\n    def log_exception(\n        self,\n        ctx: AppContext,\n        exc_info: tuple[type, BaseException, TracebackType] | tuple[None, None, None],\n    ) -> None:\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            f\"Exception on {ctx.request.path} [{ctx.request.method}]\", exc_info=exc_info\n        )\n\n    def dispatch_request(self, ctx: AppContext) -> ft.ResponseReturnValue:\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = ctx.request\n\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule: Rule = req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response(ctx)\n        # otherwise dispatch to the handler for that endpoint\n        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n\n    def full_dispatch_request(self, ctx: AppContext) -> Response:\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._got_first_request = True\n\n        try:\n            request_started.send(self, _async_wrapper=self.ensure_sync)\n            rv = self.preprocess_request(ctx)\n            if rv is None:\n                rv = self.dispatch_request(ctx)\n        except Exception as e:\n            rv = self.handle_user_exception(ctx, e)\n        return self.finalize_request(ctx, rv)\n\n    def finalize_request(\n        self,\n        ctx: AppContext,\n        rv: ft.ResponseReturnValue | HTTPException,\n        from_error_handler: bool = False,\n    ) -> Response:\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(ctx, response)\n            request_finished.send(\n                self, _async_wrapper=self.ensure_sync, response=response\n            )\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n\n    def make_default_options_response(self, ctx: AppContext) -> Response:\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        methods = ctx.url_adapter.allowed_methods()  # type: ignore[union-attr]\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def ensure_sync(self, func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:\n        \"\"\"Ensure that the function is synchronous for WSGI workers.\n        Plain ``def`` functions are returned as-is. ``async def``\n        functions are wrapped to run and wait for the response.\n\n        Override this method to change how the app runs async views.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if iscoroutinefunction(func):\n            return self.async_to_sync(func)\n\n        return func\n\n    def async_to_sync(\n        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]\n    ) -> t.Callable[..., t.Any]:\n        \"\"\"Return a sync function that will run the coroutine function.\n\n        .. code-block:: python\n\n            result = app.async_to_sync(func)(*args, **kwargs)\n\n        Override this method to change how the app converts async code\n        to be synchronously callable.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        try:\n            from asgiref.sync import async_to_sync as asgiref_async_to_sync\n        except ImportError:\n            raise RuntimeError(\n                \"Install Flask with the 'async' extra in order to use async views.\"\n            ) from None\n\n        return asgiref_async_to_sync(func)\n\n    def url_for(\n        self,\n        /,\n        endpoint: str,\n        *,\n        _anchor: str | None = None,\n        _method: str | None = None,\n        _scheme: str | None = None,\n        _external: bool | None = None,\n        **values: t.Any,\n    ) -> str:\n        \"\"\"Generate a URL to the given endpoint with the given values.\n\n        This is called by :func:`flask.url_for`, and can be called\n        directly as well.\n\n        An *endpoint* is the name of a URL rule, usually added with\n        :meth:`@app.route() <route>`, and usually the same name as the\n        view function. A route defined in a :class:`~flask.Blueprint`\n        will prepend the blueprint's name separated by a ``.`` to the\n        endpoint.\n\n        In some cases, such as email messages, you want URLs to include\n        the scheme and domain, like ``https://example.com/hello``. When\n        not in an active request, URLs will be external by default, but\n        this requires setting :data:`SERVER_NAME` so Flask knows what\n        domain to use. :data:`APPLICATION_ROOT` and\n        :data:`PREFERRED_URL_SCHEME` should also be configured as\n        needed. This config is only used when not in an active request.\n\n        Functions can be decorated with :meth:`url_defaults` to modify\n        keyword arguments before the URL is built.\n\n        If building fails for some reason, such as an unknown endpoint\n        or incorrect values, the app's :meth:`handle_url_build_error`\n        method is called. If that returns a string, that is returned,\n        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n\n        :param endpoint: The endpoint name associated with the URL to\n            generate. If this starts with a ``.``, the current blueprint\n            name (if any) will be used.\n        :param _anchor: If given, append this as ``#anchor`` to the URL.\n        :param _method: If given, generate the URL associated with this\n            method for the endpoint.\n        :param _scheme: If given, the URL will have this scheme if it\n            is external.\n        :param _external: If given, prefer the URL to be internal\n            (False) or require it to be external (True). External URLs\n            include the scheme and domain. When not in an active\n            request, URLs are external by default.\n        :param values: Values to use for the variable parts of the URL\n            rule. Unknown keys are appended as query string arguments,\n            like ``?a=b&c=d``.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.url_for``, which calls this method.\n        \"\"\"\n        if (ctx := _cv_app.get(None)) is not None and ctx.has_request:\n            url_adapter = ctx.url_adapter\n            blueprint_name = ctx.request.blueprint\n\n            # If the endpoint starts with \".\" and the request matches a\n            # blueprint, the endpoint is relative to the blueprint.\n            if endpoint[:1] == \".\":\n                if blueprint_name is not None:\n                    endpoint = f\"{blueprint_name}{endpoint}\"\n                else:\n                    endpoint = endpoint[1:]\n\n            # When in a request, generate a URL without scheme and\n            # domain by default, unless a scheme is given.\n            if _external is None:\n                _external = _scheme is not None\n        else:\n            # If called by helpers.url_for, an app context is active,\n            # use its url_adapter. Otherwise, app.url_for was called\n            # directly, build an adapter.\n            if ctx is not None:\n                url_adapter = ctx.url_adapter\n            else:\n                url_adapter = self.create_url_adapter(None)\n\n            if url_adapter is None:\n                raise RuntimeError(\n                    \"Unable to build URLs outside an active request\"\n                    \" without 'SERVER_NAME' configured. Also configure\"\n                    \" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as\"\n                    \" needed.\"\n                )\n\n            # When outside a request, generate a URL with scheme and\n            # domain by default.\n            if _external is None:\n                _external = True\n\n        # It is an error to set _scheme when _external=False, in order\n        # to avoid accidental insecure URLs.\n        if _scheme is not None and not _external:\n            raise ValueError(\"When specifying '_scheme', '_external' must be True.\")\n\n        self.inject_url_defaults(endpoint, values)\n\n        try:\n            rv = url_adapter.build(  # type: ignore[union-attr]\n                endpoint,\n                values,\n                method=_method,\n                url_scheme=_scheme,\n                force_external=_external,\n            )\n        except BuildError as error:\n            values.update(\n                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n            )\n            return self.handle_url_build_error(error, endpoint, values)\n\n        if _anchor is not None:\n            _anchor = _url_quote(_anchor, safe=\"%!#$&'()*+,/:;=?@\")\n            rv = f\"{rv}#{_anchor}\"\n\n        return rv\n\n    def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str``\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes``\n                A response object is created with the bytes as the body.\n\n            ``dict``\n                A dictionary that will be jsonify'd before being returned.\n\n            ``list``\n                A list that will be jsonify'd before being returned.\n\n            ``generator`` or ``iterator``\n                A generator that returns ``str`` or ``bytes`` to be\n                streamed as the response.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 2.2\n            A generator will be converted to a streaming response.\n            A list will be converted to a JSON response.\n\n        .. versionchanged:: 1.1\n            A dict will be converted to a JSON response.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status: int | None = None\n        headers: HeadersValue | None = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv  # type: ignore[misc]\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv  # pyright: ignore\n                else:\n                    rv, status = rv  # type: ignore[assignment,misc]\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(\n                    rv,  # pyright: ignore\n                    status=status,\n                    headers=headers,  # type: ignore[arg-type]\n                )\n                status = headers = None\n            elif isinstance(rv, (dict, list)):\n                rv = self.json.response(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(\n                        rv,  # type: ignore[arg-type]\n                        request.environ,\n                    )\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, list, tuple with headers or status,\"\n                        \" Response instance, or WSGI callable, but it\"\n                        f\" was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2]) from None\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, list, tuple with headers or status,\"\n                    \" Response instance, or WSGI callable, but it was a\"\n                    f\" {type(rv).__name__}.\"\n                )\n\n        rv = t.cast(Response, rv)\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.update(headers)\n\n        return rv\n\n    def preprocess_request(self, ctx: AppContext) -> ft.ResponseReturnValue | None:\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n        req = ctx.request\n        names = (None, *reversed(req.blueprints))\n\n        for name in names:\n            if name in self.url_value_preprocessors:\n                for url_func in self.url_value_preprocessors[name]:\n                    url_func(req.endpoint, req.view_args)\n\n        for name in names:\n            if name in self.before_request_funcs:\n                for before_func in self.before_request_funcs[name]:\n                    rv = self.ensure_sync(before_func)()\n\n                    if rv is not None:\n                        return rv  # type: ignore[no-any-return]\n\n        return None\n\n    def process_response(self, ctx: AppContext, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(ctx.request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response\n\n    def do_teardown_request(\n        self, ctx: AppContext, exc: BaseException | None = None\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is finalized,\n        right before the request context is popped. Called by\n        :meth:`.AppContext.pop`.\n\n        This calls all functions decorated with :meth:`teardown_request`, and\n        :meth:`Blueprint.teardown_request` if a blueprint handled the request.\n        Finally, the :data:`request_tearing_down` signal is sent.\n\n        :param exc: An unhandled exception raised while dispatching the request.\n            Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        for name in chain(ctx.request.blueprints, (None,)):\n            if name in self.teardown_request_funcs:\n                for func in reversed(self.teardown_request_funcs[name]):\n                    self.ensure_sync(func)(exc)\n\n        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def do_teardown_appcontext(\n        self, ctx: AppContext, exc: BaseException | None = None\n    ) -> None:\n        \"\"\"Called right before the application context is popped. Called by\n        :meth:`.AppContext.pop`.\n\n        This calls all functions decorated with :meth:`teardown_appcontext`.\n        Then the :data:`appcontext_tearing_down` signal is sent.\n\n        :param exc: An unhandled exception raised while the context was active.\n            Passed to each teardown function.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        for func in reversed(self.teardown_appcontext_funcs):\n            self.ensure_sync(func)(exc)\n\n        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n\n    def app_context(self) -> AppContext:\n        \"\"\"Create an :class:`.AppContext`. When the context is pushed,\n        :data:`.current_app` and :data:`.g` become available.\n\n        A context is automatically pushed when handling each request, and when\n        running any ``flask`` CLI command. Use this as a ``with`` block to\n        manually push a context outside of those situations, such as during\n        setup or testing.\n\n        .. code-block:: python\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ: WSGIEnvironment) -> AppContext:\n        \"\"\"Create an :class:`.AppContext` with request information representing\n        the given WSGI environment. A context is automatically pushed when\n        handling each request. When the context is pushed, :data:`.request`,\n        :data:`.session`, :data:`g:, and :data:`.current_app` become available.\n\n        This method should not be used in your own code. Creating a valid WSGI\n        environ is not trivial. Use :meth:`test_request_context` to correctly\n        create a WSGI environ and request context instead.\n\n        See :doc:`/appcontext`.\n\n        :param environ: A WSGI environment.\n        \"\"\"\n        return AppContext.from_environ(self, environ)\n\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> AppContext:\n        \"\"\"Create an :class:`.AppContext` with request information created from\n        the given arguments. When the context is pushed, :data:`.request`,\n        :data:`.session`, :data:`g:, and :data:`.current_app` become available.\n\n        This is useful during testing to run a function that uses request data\n        without dispatching a full request. Use this as a ``with`` block to push\n        a context.\n\n        .. code-block:: python\n\n            with app.test_request_context(...):\n                generate_report()\n\n        See :doc:`/appcontext`.\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``, :data:`SERVER_NAME`,\n            and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to prepend to :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body text or bytes,or a dict of form data.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application/json``.\n        :param args: Other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: Other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            environ = builder.get_environ()\n        finally:\n            builder.close()\n\n        return self.request_context(environ)\n\n    def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request(ctx)\n            except Exception as e:\n                error = e\n                response = self.handle_exception(ctx, e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](ctx)\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n\n    def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)",
    "start_line": 108,
    "end_line": 1591,
    "has_docstring": true,
    "docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the\npackage or the folder the module is contained in depending on if the\npackage parameter resolves to an actual python package (a folder with\nan :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\nFor more information about resource loading, see :func:`open_resource`.\n\nUsually you create a :class:`Flask` instance in your main module or\nin the :file:`__init__.py` file of your package like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n.. admonition:: About the First Parameter\n\n    The idea of the first parameter is to give Flask an idea of what\n    belongs to your application.  This name is used to find resources\n    on the filesystem, can be used by extensions to improve debugging\n    information and a lot more.\n\n    So it's important what you provide there.  If you are using a single\n    module, `__name__` is always the correct value.  If you however are\n    using a package, it's usually recommended to hardcode the name of\n    your package there.\n\n    For example if your application is defined in :file:`yourapplication/app.py`\n    you should create it with one of the two versions below::\n\n        app = Flask('yourapplication')\n        app = Flask(__name__.split('.')[0])\n\n    Why is that?  The application will work even with `__name__`, thanks\n    to how resources are looked up.  However it will make debugging more\n    painful.  Certain extensions can make assumptions based on the\n    import name of your application.  For example the Flask-SQLAlchemy\n    extension will look for the code in your application that triggered\n    an SQL query in debug mode.  If the import name is not properly set\n    up, that debugging information is lost.  (For example it would only\n    pick up SQL queries in `yourapplication.app` and not\n    `yourapplication.views.frontend`)\n\n.. versionadded:: 0.7\n   The `static_url_path`, `static_folder`, and `template_folder`\n   parameters were added.\n\n.. versionadded:: 0.8\n   The `instance_path` and `instance_relative_config` parameters were\n   added.\n\n.. versionadded:: 0.11\n   The `root_path` parameter was added.\n\n.. versionadded:: 1.0\n   The ``host_matching`` and ``static_host`` parameters were added.\n\n.. versionadded:: 1.0\n   The ``subdomain_matching`` parameter was added. Subdomain\n   matching needs to be enabled manually now. Setting\n   :data:`SERVER_NAME` does not implicitly enable it.\n\n:param import_name: the name of the application package\n:param static_url_path: can be used to specify a different path for the\n                        static files on the web.  Defaults to the name\n                        of the `static_folder` folder.\n:param static_folder: The folder with static files that is served at\n    ``static_url_path``. Relative to the application ``root_path``\n    or an absolute path. Defaults to ``'static'``.\n:param static_host: the host to use when adding the static route.\n    Defaults to None. Required when using ``host_matching=True``\n    with a ``static_folder`` configured.\n:param host_matching: set ``url_map.host_matching`` attribute.\n    Defaults to False.\n:param subdomain_matching: consider the subdomain relative to\n    :data:`SERVER_NAME` when matching routes. Defaults to False.\n:param template_folder: the folder that contains the templates that should\n                        be used by the application.  Defaults to\n                        ``'templates'`` folder in the root path of the\n                        application.\n:param instance_path: An alternative instance path for the application.\n                      By default the folder ``'instance'`` next to the\n                      package or module is assumed to be the instance\n                      path.\n:param instance_relative_config: if set to ``True`` relative filenames\n                                 for loading the config are assumed to\n                                 be relative to the instance path instead\n                                 of the application root.\n:param root_path: The path to the root of the application files.\n    This should only be set manually when it can't be detected\n    automatically, such as for namespace packages.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "App"
    ],
    "class_name": null,
    "display_name": "class Flask",
    "component_id": "src.flask.app.Flask"
  },
  "src.flask.blueprints.Blueprint": {
    "id": "src.flask.blueprints.Blueprint",
    "name": "Blueprint",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/blueprints.py",
    "relative_path": "src/flask/blueprints.py",
    "depends_on": [
      "src.flask.cli.AppGroup",
      "src.flask.helpers.send_from_directory"
    ],
    "source_code": "class Blueprint(SansioBlueprint):\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore\n    ) -> None:\n        super().__init__(\n            name,\n            import_name,\n            static_folder,\n            static_url_path,\n            template_folder,\n            url_prefix,\n            subdomain,\n            url_defaults,\n            root_path,\n            cli_group,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n    def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value  # type: ignore[no-any-return]\n\n    def send_static_file(self, filename: str) -> Response:\n        \"\"\"The view function used to serve files from\n        :attr:`static_folder`. A route is automatically registered for\n        this view at :attr:`static_url_path` if :attr:`static_folder` is\n        set.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionadded:: 0.5\n\n        \"\"\"\n        if not self.has_static_folder:\n            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n\n        # send_file only knows to call get_send_file_max_age on the app,\n        # call it here so it works for blueprints too.\n        max_age = self.get_send_file_max_age(filename)\n        return send_from_directory(\n            t.cast(str, self.static_folder), filename, max_age=max_age\n        )\n\n    def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading. The\n        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`\n        method.\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)",
    "start_line": 18,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SansioBlueprint"
    ],
    "class_name": null,
    "display_name": "class Blueprint",
    "component_id": "src.flask.blueprints.Blueprint"
  },
  "src.flask.cli.NoAppException": {
    "id": "src.flask.cli.NoAppException",
    "name": "NoAppException",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "class NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"",
    "start_line": 37,
    "end_line": 38,
    "has_docstring": true,
    "docstring": "Raised if an application cannot be found or loaded.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "click.UsageError"
    ],
    "class_name": null,
    "display_name": "class NoAppException",
    "component_id": "src.flask.cli.NoAppException"
  },
  "src.flask.cli.find_best_app": {
    "id": "src.flask.cli.find_best_app",
    "name": "find_best_app",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.NoAppException",
      "src.flask.cli._called_with_wrong_args"
    ],
    "source_code": "def find_best_app(module: ModuleType) -> Flask:\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n            \" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in (\"create_app\", \"make_app\"):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = app_factory()\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError as e:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n\n                raise NoAppException(\n                    f\"Detected factory '{attr_name}' in module '{module.__name__}',\"\n                    \" but could not call it without arguments. Use\"\n                    f\" '{module.__name__}:{attr_name}(args)'\"\n                    \" to specify arguments.\"\n                ) from e\n\n    raise NoAppException(\n        \"Failed to find Flask application or factory in module\"\n        f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n        \" to specify one.\"\n    )",
    "start_line": 41,
    "end_line": 91,
    "has_docstring": true,
    "docstring": "Given a module instance this tries to find the best possible\napplication in the module or raises an exception.",
    "parameters": [
      "module"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function find_best_app",
    "component_id": "src.flask.cli.find_best_app"
  },
  "src.flask.cli._called_with_wrong_args": {
    "id": "src.flask.cli._called_with_wrong_args",
    "name": "_called_with_wrong_args",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def _called_with_wrong_args(f: t.Callable[..., Flask]) -> bool:\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb",
    "start_line": 94,
    "end_line": 117,
    "has_docstring": true,
    "docstring": "Check whether calling a function raised a ``TypeError`` because\nthe call failed or because something in the factory raised the\nerror.\n\n:param f: The function that was called.\n:return: ``True`` if the call failed.",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _called_with_wrong_args",
    "component_id": "src.flask.cli._called_with_wrong_args"
  },
  "src.flask.cli.find_app_by_string": {
    "id": "src.flask.cli.find_app_by_string",
    "name": "find_app_by_string",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.NoAppException",
      "src.flask.cli._called_with_wrong_args"
    ],
    "source_code": "def find_app_by_string(module: ModuleType, app_name: str) -> Flask:\n    \"\"\"Check if the given string is a variable name or a function. Call\n    a function to get the app instance, or return the variable directly.\n    \"\"\"\n    from . import Flask\n\n    # Parse app_name as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expr = ast.parse(app_name.strip(), mode=\"eval\").body\n    except SyntaxError:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        ) from None\n\n    if isinstance(expr, ast.Name):\n        name = expr.id\n        args = []\n        kwargs = {}\n    elif isinstance(expr, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expr.func, ast.Name):\n            raise NoAppException(\n                f\"Function reference must be a simple name: {app_name!r}.\"\n            )\n\n        name = expr.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expr.args]\n            kwargs = {\n                kw.arg: ast.literal_eval(kw.value)\n                for kw in expr.keywords\n                if kw.arg is not None\n            }\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise NoAppException(\n                f\"Failed to parse arguments as literal values: {app_name!r}.\"\n            ) from None\n    else:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        )\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError as e:\n        raise NoAppException(\n            f\"Failed to find attribute {name!r} in {module.__name__!r}.\"\n        ) from e\n\n    # If the attribute is a function, call it with any args and kwargs\n    # to get the real application.\n    if inspect.isfunction(attr):\n        try:\n            app = attr(*args, **kwargs)\n        except TypeError as e:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                f\"The factory {app_name!r} in module\"\n                f\" {module.__name__!r} could not be called with the\"\n                \" specified arguments.\"\n            ) from e\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        \"A valid Flask application was not obtained from\"\n        f\" '{module.__name__}:{app_name}'.\"\n    )",
    "start_line": 120,
    "end_line": 197,
    "has_docstring": true,
    "docstring": "Check if the given string is a variable name or a function. Call\na function to get the app instance, or return the variable directly.",
    "parameters": [
      "module",
      "app_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function find_app_by_string",
    "component_id": "src.flask.cli.find_app_by_string"
  },
  "src.flask.cli.prepare_import": {
    "id": "src.flask.cli.prepare_import",
    "name": "prepare_import",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def prepare_import(path: str) -> str:\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    fname, ext = os.path.splitext(path)\n    if ext == \".py\":\n        path = fname\n\n    if os.path.basename(path) == \"__init__\":\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, \"__init__.py\")):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return \".\".join(module_name[::-1])",
    "start_line": 200,
    "end_line": 226,
    "has_docstring": true,
    "docstring": "Given a filename this will try to calculate the python path, add it\nto the search path and return the actual module name that is expected.",
    "parameters": [
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function prepare_import",
    "component_id": "src.flask.cli.prepare_import"
  },
  "src.flask.cli.locate_app": {
    "id": "src.flask.cli.locate_app",
    "name": "locate_app",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.NoAppException",
      "src.flask.cli.find_app_by_string",
      "src.flask.cli.find_best_app"
    ],
    "source_code": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: bool = True\n) -> Flask | None:\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return None\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)",
    "start_line": 241,
    "end_line": 264,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "module_name",
      "app_name",
      "raise_if_not_found"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function locate_app",
    "component_id": "src.flask.cli.locate_app"
  },
  "src.flask.cli.get_version": {
    "id": "src.flask.cli.get_version",
    "name": "get_version",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:\n    if not value or ctx.resilient_parsing:\n        return\n\n    flask_version = importlib.metadata.version(\"flask\")\n    werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    click.echo(\n        f\"Python {platform.python_version()}\\n\"\n        f\"Flask {flask_version}\\n\"\n        f\"Werkzeug {werkzeug_version}\",\n        color=ctx.color,\n    )\n    ctx.exit()",
    "start_line": 267,
    "end_line": 280,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ctx",
      "param",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_version",
    "component_id": "src.flask.cli.get_version"
  },
  "src.flask.cli.ScriptInfo": {
    "id": "src.flask.cli.ScriptInfo",
    "name": "ScriptInfo",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.NoAppException",
      "src.flask.cli.locate_app",
      "src.flask.helpers.get_load_dotenv",
      "src.flask.cli.prepare_import",
      "src.flask.helpers.get_debug_flag"
    ],
    "source_code": "class ScriptInfo:\n    \"\"\"Helper object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n\n    .. versionchanged:: 3.1\n        Added the ``load_dotenv_defaults`` parameter and attribute.\n    \"\"\"\n\n    def __init__(\n        self,\n        app_import_path: str | None = None,\n        create_app: t.Callable[..., Flask] | None = None,\n        set_debug_flag: bool = True,\n        load_dotenv_defaults: bool = True,\n    ) -> None:\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data: dict[t.Any, t.Any] = {}\n        self.set_debug_flag = set_debug_flag\n\n        self.load_dotenv_defaults = get_load_dotenv(load_dotenv_defaults)\n        \"\"\"Whether default ``.flaskenv`` and ``.env`` files should be loaded.\n\n        ``ScriptInfo`` doesn't load anything, this is for reference when doing\n        the load elsewhere during processing.\n\n        .. versionadded:: 3.1\n        \"\"\"\n\n        self._loaded_app: Flask | None = None\n\n    def load_app(self) -> Flask:\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        if self._loaded_app is not None:\n            return self._loaded_app\n        app: Flask | None = None\n        if self.create_app is not None:\n            app = self.create_app()\n        else:\n            if self.app_import_path:\n                path, name = (\n                    re.split(r\":(?![\\\\/])\", self.app_import_path, maxsplit=1) + [None]\n                )[:2]\n                import_name = prepare_import(path)\n                app = locate_app(import_name, name)\n            else:\n                for path in (\"wsgi.py\", \"app.py\"):\n                    import_name = prepare_import(path)\n                    app = locate_app(import_name, None, raise_if_not_found=False)\n\n                    if app is not None:\n                        break\n\n        if app is None:\n            raise NoAppException(\n                \"Could not locate a Flask application. Use the\"\n                \" 'flask --app' option, 'FLASK_APP' environment\"\n                \" variable, or a 'wsgi.py' or 'app.py' file in the\"\n                \" current directory.\"\n            )\n\n        if self.set_debug_flag:\n            # Update the app's debug flag through the descriptor so that\n            # other values repopulate as well.\n            app.debug = get_debug_flag()\n\n        self._loaded_app = app\n        return app",
    "start_line": 293,
    "end_line": 372,
    "has_docstring": true,
    "docstring": "Helper object to deal with Flask applications.  This is usually not\nnecessary to interface with as it's used internally in the dispatching\nto click.  In future versions of Flask this object will most likely play\na bigger role.  Typically it's created automatically by the\n:class:`FlaskGroup` but you can also manually create it and pass it\nonwards as click object.\n\n.. versionchanged:: 3.1\n    Added the ``load_dotenv_defaults`` parameter and attribute.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ScriptInfo",
    "component_id": "src.flask.cli.ScriptInfo"
  },
  "src.flask.cli.with_appcontext": {
    "id": "src.flask.cli.with_appcontext",
    "name": "with_appcontext",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def with_appcontext(f: F) -> F:\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.\n\n    Custom commands (and their options) registered under ``app.cli`` or\n    ``blueprint.cli`` will always have an app context available, this\n    decorator is not required in that case.\n\n    .. versionchanged:: 2.2\n        The app context is active for subcommands as well as the\n        decorated callback. The app context is always available to\n        ``app.cli`` command and parameter callbacks.\n    \"\"\"\n\n    @click.pass_context\n    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not current_app:\n            app = ctx.ensure_object(ScriptInfo).load_app()\n            ctx.with_resource(app.app_context())\n\n        return ctx.invoke(f, *args, **kwargs)\n\n    return update_wrapper(decorator, f)  # type: ignore[return-value]",
    "start_line": 380,
    "end_line": 402,
    "has_docstring": true,
    "docstring": "Wraps a callback so that it's guaranteed to be executed with the\nscript's application context.\n\nCustom commands (and their options) registered under ``app.cli`` or\n``blueprint.cli`` will always have an app context available, this\ndecorator is not required in that case.\n\n.. versionchanged:: 2.2\n    The app context is active for subcommands as well as the\n    decorated callback. The app context is always available to\n    ``app.cli`` command and parameter callbacks.",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function with_appcontext",
    "component_id": "src.flask.cli.with_appcontext"
  },
  "src.flask.cli.decorator": {
    "id": "src.flask.cli.decorator",
    "name": "decorator",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not current_app:\n            app = ctx.ensure_object(ScriptInfo).load_app()\n            ctx.with_resource(app.app_context())\n\n        return ctx.invoke(f, *args, **kwargs)",
    "start_line": 395,
    "end_line": 400,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function decorator",
    "component_id": "src.flask.cli.decorator"
  },
  "src.flask.cli.AppGroup": {
    "id": "src.flask.cli.AppGroup",
    "name": "AppGroup",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.with_appcontext"
    ],
    "source_code": "class AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(  # type: ignore[override]\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop(\"with_appcontext\", True)\n\n        def decorator(f: t.Callable[..., t.Any]) -> click.Command:\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]\n\n        return decorator\n\n    def group(  # type: ignore[override]\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault(\"cls\", AppGroup)\n        return super().group(*args, **kwargs)  # type: ignore[no-any-return]",
    "start_line": 405,
    "end_line": 437,
    "has_docstring": true,
    "docstring": "This works similar to a regular click :class:`~click.Group` but it\nchanges the behavior of the :meth:`command` decorator so that it\nautomatically wraps the functions in :func:`with_appcontext`.\n\nNot to be confused with :class:`FlaskGroup`.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "click.Group"
    ],
    "class_name": null,
    "display_name": "class AppGroup",
    "component_id": "src.flask.cli.AppGroup"
  },
  "src.flask.cli._set_app": {
    "id": "src.flask.cli._set_app",
    "name": "_set_app",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value",
    "start_line": 440,
    "end_line": 446,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ctx",
      "param",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _set_app",
    "component_id": "src.flask.cli._set_app"
  },
  "src.flask.cli._set_debug": {
    "id": "src.flask.cli._set_debug",
    "name": "_set_debug",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n    # If the flag isn't provided, it will default to False. Don't use\n    # that, let debug be set by env in that case.\n    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n\n    if source is not None and source in (\n        ParameterSource.DEFAULT,\n        ParameterSource.DEFAULT_MAP,\n    ):\n        return None\n\n    # Set with env var instead of ScriptInfo.load so that it can be\n    # accessed early during a factory function.\n    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n    return value",
    "start_line": 468,
    "end_line": 482,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ctx",
      "param",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _set_debug",
    "component_id": "src.flask.cli._set_debug"
  },
  "src.flask.cli._env_file_callback": {
    "id": "src.flask.cli._env_file_callback",
    "name": "_env_file_callback",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.load_dotenv"
    ],
    "source_code": "def _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        # Only show an error if a value was passed, otherwise we still want to\n        # call load_dotenv and show a message without exiting.\n        if value is not None:\n            raise click.BadParameter(\n                \"python-dotenv must be installed to load an env file.\",\n                ctx=ctx,\n                param=param,\n            ) from None\n\n    # Load if a value was passed, or we want to load default files, or both.\n    if value is not None or ctx.obj.load_dotenv_defaults:\n        load_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)\n\n    return value",
    "start_line": 493,
    "end_line": 512,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ctx",
      "param",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _env_file_callback",
    "component_id": "src.flask.cli._env_file_callback"
  },
  "src.flask.cli.FlaskGroup": {
    "id": "src.flask.cli.FlaskGroup",
    "name": "FlaskGroup",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.AppGroup",
      "src.flask.cli.ScriptInfo",
      "src.flask.json.__init__.load"
    ],
    "source_code": "class FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this. see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n        shell commands will be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info and\n        returns the loaded app.\n    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n        files to set environment variables. Will also change the working\n        directory to the directory containing the first file found.\n    :param set_debug_flag: Set the app's debug flag.\n\n    .. versionchanged:: 3.1\n        ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.\n\n    .. versionchanged:: 2.2\n        Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.\n\n    .. versionchanged:: 2.2\n        An app context is pushed when running ``app.cli`` commands, so\n        ``@with_appcontext`` is no longer required for those commands.\n\n    .. versionchanged:: 1.0\n        If installed, python-dotenv will be used to load environment variables\n        from :file:`.env` and :file:`.flaskenv` files.\n    \"\"\"\n\n    def __init__(\n        self,\n        add_default_commands: bool = True,\n        create_app: t.Callable[..., Flask] | None = None,\n        add_version_option: bool = True,\n        load_dotenv: bool = True,\n        set_debug_flag: bool = True,\n        **extra: t.Any,\n    ) -> None:\n        params: list[click.Parameter] = list(extra.pop(\"params\", None) or ())\n        # Processing is done with option callbacks instead of a group\n        # callback. This allows users to make a custom group callback\n        # without losing the behavior. --env-file must come first so\n        # that it is eagerly evaluated before --app.\n        params.extend((_env_file_option, _app_option, _debug_option))\n\n        if add_version_option:\n            params.append(version_option)\n\n        if \"context_settings\" not in extra:\n            extra[\"context_settings\"] = {}\n\n        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n\n        super().__init__(params=params, **extra)\n\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self) -> None:\n        if self._loaded_plugin_commands:\n            return\n\n        for ep in importlib.metadata.entry_points(group=\"flask.commands\"):\n            self.add_command(ep.load(), ep.name)\n\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx: click.Context, name: str) -> click.Command | None:\n        self._load_plugin_commands()\n        # Look up built-in and plugin commands, which should be\n        # available even if the app fails to load.\n        rv = super().get_command(ctx, name)\n\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Look up commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            app = info.load_app()\n        except NoAppException as e:\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n            return None\n\n        # Push an app context for the loaded app unless it is already\n        # active somehow. This makes the context available to parameter\n        # and command callbacks without needing @with_appcontext.\n        if not current_app or current_app._get_current_object() is not app:\n            ctx.with_resource(app.app_context())\n\n        return app.cli.get_command(ctx, name)\n\n    def list_commands(self, ctx: click.Context) -> list[str]:\n        self._load_plugin_commands()\n        # Start with the built-in and plugin commands.\n        rv = set(super().list_commands(ctx))\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Add commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except NoAppException as e:\n            # When an app couldn't be loaded, show the error message\n            # without the traceback.\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n        except Exception:\n            # When any other errors occurred during loading, show the\n            # full traceback.\n            click.secho(f\"{traceback.format_exc()}\\n\", err=True, fg=\"red\")\n\n        return sorted(rv)\n\n    def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: click.Context | None = None,\n        **extra: t.Any,\n    ) -> click.Context:\n        # Set a flag to tell app.run to become a no-op. If app.run was\n        # not in a __name__ == __main__ guard, it would start the server\n        # when importing, blocking whatever command is being called.\n        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n            extra[\"obj\"] = ScriptInfo(\n                create_app=self.create_app,\n                set_debug_flag=self.set_debug_flag,\n                load_dotenv_defaults=self.load_dotenv,\n            )\n\n        return super().make_context(info_name, args, parent=parent, **extra)\n\n    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n        if (not args and self.no_args_is_help) or (\n            len(args) == 1 and args[0] in self.get_help_option_names(ctx)\n        ):\n            # Attempt to load --env-file and --app early in case they\n            # were given as env vars. Otherwise no_args_is_help will not\n            # see commands from app.cli.\n            _env_file_option.handle_parse_result(ctx, {}, [])\n            _app_option.handle_parse_result(ctx, {}, [])\n\n        return super().parse_args(ctx, args)",
    "start_line": 531,
    "end_line": 688,
    "has_docstring": true,
    "docstring": "Special subclass of the :class:`AppGroup` group that supports\nloading more commands from the configured Flask app.  Normally a\ndeveloper does not have to interface with this class but there are\nsome very advanced use cases for which it makes sense to create an\ninstance of this. see :ref:`custom-scripts`.\n\n:param add_default_commands: if this is True then the default run and\n    shell commands will be added.\n:param add_version_option: adds the ``--version`` option.\n:param create_app: an optional callback that is passed the script info and\n    returns the loaded app.\n:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n    files to set environment variables. Will also change the working\n    directory to the directory containing the first file found.\n:param set_debug_flag: Set the app's debug flag.\n\n.. versionchanged:: 3.1\n    ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.\n\n.. versionchanged:: 2.2\n    Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.\n\n.. versionchanged:: 2.2\n    An app context is pushed when running ``app.cli`` commands, so\n    ``@with_appcontext`` is no longer required for those commands.\n\n.. versionchanged:: 1.0\n    If installed, python-dotenv will be used to load environment variables\n    from :file:`.env` and :file:`.flaskenv` files.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "AppGroup"
    ],
    "class_name": null,
    "display_name": "class FlaskGroup",
    "component_id": "src.flask.cli.FlaskGroup"
  },
  "src.flask.cli._path_is_ancestor": {
    "id": "src.flask.cli._path_is_ancestor",
    "name": "_path_is_ancestor",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def _path_is_ancestor(path: str, other: str) -> bool:\n    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"\n    return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other",
    "start_line": 691,
    "end_line": 695,
    "has_docstring": true,
    "docstring": "Take ``other`` and remove the length of ``path`` from it. Then join it\nto ``path``. If it is the original value, ``path`` is an ancestor of\n``other``.",
    "parameters": [
      "path",
      "other"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _path_is_ancestor",
    "component_id": "src.flask.cli._path_is_ancestor"
  },
  "src.flask.cli.load_dotenv": {
    "id": "src.flask.cli.load_dotenv",
    "name": "load_dotenv",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def load_dotenv(\n    path: str | os.PathLike[str] | None = None, load_defaults: bool = True\n) -> bool:\n    \"\"\"Load \"dotenv\" files to set environment variables. A given path takes\n    precedence over ``.env``, which takes precedence over ``.flaskenv``. After\n    loading and combining these files, values are only set if the key is not\n    already set in ``os.environ``.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location.\n    :param load_defaults: Search for and load the default ``.flaskenv`` and\n        ``.env`` files.\n    :return: ``True`` if at least one env var was loaded.\n\n    .. versionchanged:: 3.1\n        Added the ``load_defaults`` parameter. A given path takes precedence\n        over default files.\n\n    .. versionchanged:: 2.0\n        The current directory is not changed to the location of the\n        loaded file.\n\n    .. versionchanged:: 2.0\n        When loading the env files, set the default encoding to UTF-8.\n\n    .. versionchanged:: 1.1.0\n        Returns ``False`` when python-dotenv is not installed, or when\n        the given path isn't a file.\n\n    .. versionadded:: 1.0\n    \"\"\"\n    try:\n        import dotenv\n    except ImportError:\n        if path or os.path.isfile(\".env\") or os.path.isfile(\".flaskenv\"):\n            click.secho(\n                \" * Tip: There are .env files present. Install python-dotenv\"\n                \" to use them.\",\n                fg=\"yellow\",\n                err=True,\n            )\n\n        return False\n\n    data: dict[str, str | None] = {}\n\n    if load_defaults:\n        for default_name in (\".flaskenv\", \".env\"):\n            if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):\n                continue\n\n            data |= dotenv.dotenv_values(default_path, encoding=\"utf-8\")\n\n    if path is not None and os.path.isfile(path):\n        data |= dotenv.dotenv_values(path, encoding=\"utf-8\")\n\n    for key, value in data.items():\n        if key in os.environ or value is None:\n            continue\n\n        os.environ[key] = value\n\n    return bool(data)  # True if at least one env var was loaded.",
    "start_line": 698,
    "end_line": 763,
    "has_docstring": true,
    "docstring": "Load \"dotenv\" files to set environment variables. A given path takes\nprecedence over ``.env``, which takes precedence over ``.flaskenv``. After\nloading and combining these files, values are only set if the key is not\nalready set in ``os.environ``.\n\nThis is a no-op if `python-dotenv`_ is not installed.\n\n.. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n:param path: Load the file at this location.\n:param load_defaults: Search for and load the default ``.flaskenv`` and\n    ``.env`` files.\n:return: ``True`` if at least one env var was loaded.\n\n.. versionchanged:: 3.1\n    Added the ``load_defaults`` parameter. A given path takes precedence\n    over default files.\n\n.. versionchanged:: 2.0\n    The current directory is not changed to the location of the\n    loaded file.\n\n.. versionchanged:: 2.0\n    When loading the env files, set the default encoding to UTF-8.\n\n.. versionchanged:: 1.1.0\n    Returns ``False`` when python-dotenv is not installed, or when\n    the given path isn't a file.\n\n.. versionadded:: 1.0",
    "parameters": [
      "path",
      "load_defaults"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_dotenv",
    "component_id": "src.flask.cli.load_dotenv"
  },
  "src.flask.cli.show_server_banner": {
    "id": "src.flask.cli.show_server_banner",
    "name": "show_server_banner",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def show_server_banner(debug: bool, app_import_path: str | None) -> None:\n    \"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"\n    if is_running_from_reloader():\n        return\n\n    if app_import_path is not None:\n        click.echo(f\" * Serving Flask app '{app_import_path}'\")\n\n    if debug is not None:\n        click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")",
    "start_line": 766,
    "end_line": 777,
    "has_docstring": true,
    "docstring": "Show extra startup messages the first time the server is run,\nignoring the reloader.",
    "parameters": [
      "debug",
      "app_import_path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_server_banner",
    "component_id": "src.flask.cli.show_server_banner"
  },
  "src.flask.cli.CertParamType": {
    "id": "src.flask.cli.CertParamType",
    "name": "CertParamType",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "class CertParamType(click.ParamType):\n    \"\"\"Click option type for the ``--cert`` option. Allows either an\n    existing file, the string ``'adhoc'``, or an import for a\n    :class:`~ssl.SSLContext` object.\n    \"\"\"\n\n    name = \"path\"\n\n    def __init__(self) -> None:\n        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)\n\n    def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise",
    "start_line": 780,
    "end_line": 825,
    "has_docstring": true,
    "docstring": "Click option type for the ``--cert`` option. Allows either an\nexisting file, the string ``'adhoc'``, or an import for a\n:class:`~ssl.SSLContext` object.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "click.ParamType"
    ],
    "class_name": null,
    "display_name": "class CertParamType",
    "component_id": "src.flask.cli.CertParamType"
  },
  "src.flask.cli._validate_key": {
    "id": "src.flask.cli._validate_key",
    "name": "_validate_key",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key\" is not used.',\n                ctx,\n                param,\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value",
    "start_line": 828,
    "end_line": 864,
    "has_docstring": true,
    "docstring": "The ``--key`` option must be specified when ``--cert`` is a file.\nModifies the ``cert`` param to be a ``(cert, key)`` pair if needed.",
    "parameters": [
      "ctx",
      "param",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _validate_key",
    "component_id": "src.flask.cli._validate_key"
  },
  "src.flask.cli.SeparatedPathType": {
    "id": "src.flask.cli.SeparatedPathType",
    "name": "SeparatedPathType",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "class SeparatedPathType(click.Path):\n    \"\"\"Click option type that accepts a list of values separated by the\n    OS's path separator (``:``, ``;`` on Windows). Each value is\n    validated as a :class:`click.Path` type.\n    \"\"\"\n\n    def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        items = self.split_envvar_value(value)\n        # can't call no-arg super() inside list comprehension until Python 3.12\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]",
    "start_line": 867,
    "end_line": 879,
    "has_docstring": true,
    "docstring": "Click option type that accepts a list of values separated by the\nOS's path separator (``:``, ``;`` on Windows). Each value is\nvalidated as a :class:`click.Path` type.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "click.Path"
    ],
    "class_name": null,
    "display_name": "class SeparatedPathType",
    "component_id": "src.flask.cli.SeparatedPathType"
  },
  "src.flask.cli.run_command": {
    "id": "src.flask.cli.run_command",
    "name": "run_command",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def run_command(\n    info: ScriptInfo,\n    host: str,\n    port: int,\n    reload: bool,\n    debugger: bool,\n    with_threads: bool,\n    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal[\"adhoc\"] | None,\n    extra_files: list[str] | None,\n    exclude_patterns: list[str] | None,\n) -> None:\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default with the '--debug'\n    option.\n    \"\"\"\n    try:\n        app: WSGIApplication = info.load_app()  # pyright: ignore\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(\n                environ: WSGIEnvironment, start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )",
    "start_line": 935,
    "end_line": 993,
    "has_docstring": true,
    "docstring": "Run a local development server.\n\nThis server is for development purposes only. It does not provide\nthe stability, security, or performance of production WSGI servers.\n\nThe reloader and debugger are enabled by default with the '--debug'\noption.",
    "parameters": [
      "info",
      "host",
      "port",
      "reload",
      "debugger",
      "with_threads",
      "cert",
      "extra_files",
      "exclude_patterns"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run_command",
    "component_id": "src.flask.cli.run_command"
  },
  "src.flask.cli.app": {
    "id": "src.flask.cli.app",
    "name": "app",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "            def app(\n                environ: WSGIEnvironment, start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None",
    "start_line": 963,
    "end_line": 966,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "environ",
      "start_response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function app",
    "component_id": "src.flask.cli.app"
  },
  "src.flask.cli.shell_command": {
    "id": "src.flask.cli.shell_command",
    "name": "shell_command",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def shell_command() -> None:\n    \"\"\"Run an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to its configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"\n    import code\n\n    banner = (\n        f\"Python {sys.version} on {sys.platform}\\n\"\n        f\"App: {current_app.import_name}\\n\"\n        f\"Instance: {current_app.instance_path}\"\n    )\n    ctx: dict[str, t.Any] = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get(\"PYTHONSTARTUP\")\n    if startup and os.path.isfile(startup):\n        with open(startup) as f:\n            eval(compile(f.read(), startup, \"exec\"), ctx)\n\n    ctx.update(current_app.make_shell_context())\n\n    # Site, customize, or startup script can set a hook to call when\n    # entering interactive mode. The default one sets up readline with\n    # tab and history completion.\n    interactive_hook = getattr(sys, \"__interactivehook__\", None)\n\n    if interactive_hook is not None:\n        try:\n            import readline\n            from rlcompleter import Completer\n        except ImportError:\n            pass\n        else:\n            # rlcompleter uses __main__.__dict__ by default, which is\n            # flask.__main__. Use the shell context instead.\n            readline.set_completer(Completer(ctx).complete)\n\n        interactive_hook()\n\n    code.interact(banner=banner, local=ctx)",
    "start_line": 1001,
    "end_line": 1045,
    "has_docstring": true,
    "docstring": "Run an interactive Python shell in the context of a given\nFlask application.  The application will populate the default\nnamespace of this shell according to its configuration.\n\nThis is useful for executing small snippets of management code\nwithout having to manually configure the application.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function shell_command",
    "component_id": "src.flask.cli.shell_command"
  },
  "src.flask.cli.routes_command": {
    "id": "src.flask.cli.routes_command",
    "name": "routes_command",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [],
    "source_code": "def routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n    host_matching = current_app.url_map.host_matching\n    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\n    rows = []\n\n    for rule in rules:\n        row = [\n            rule.endpoint,\n            \", \".join(sorted((rule.methods or set()) - ignored_methods)),\n        ]\n\n        if has_domain:\n            row.append((rule.host if host_matching else rule.subdomain) or \"\")\n\n        row.append(rule.rule)\n        rows.append(row)\n\n    headers = [\"Endpoint\", \"Methods\"]\n    sorts = [\"endpoint\", \"methods\"]\n\n    if has_domain:\n        headers.append(\"Host\" if host_matching else \"Subdomain\")\n        sorts.append(\"domain\")\n\n    headers.append(\"Rule\")\n    sorts.append(\"rule\")\n\n    try:\n        rows.sort(key=itemgetter(sorts.index(sort)))\n    except ValueError:\n        pass\n\n    rows.insert(0, headers)\n    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\n    rows.insert(1, [\"-\" * w for w in widths])\n    template = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\n\n    for row in rows:\n        click.echo(template.format(*row))",
    "start_line": 1061,
    "end_line": 1107,
    "has_docstring": true,
    "docstring": "Show all registered routes with endpoints and methods.",
    "parameters": [
      "sort",
      "all_methods"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function routes_command",
    "component_id": "src.flask.cli.routes_command"
  },
  "src.flask.cli.main": {
    "id": "src.flask.cli.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/cli.py",
    "relative_path": "src/flask/cli.py",
    "depends_on": [
      "src.flask.cli.main"
    ],
    "source_code": "def main() -> None:\n    cli.main()",
    "start_line": 1122,
    "end_line": 1123,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "src.flask.cli.main"
  },
  "src.flask.config.ConfigAttribute": {
    "id": "src.flask.config.ConfigAttribute",
    "name": "ConfigAttribute",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/config.py",
    "relative_path": "src/flask/config.py",
    "depends_on": [],
    "source_code": "class ConfigAttribute(t.Generic[T]):\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(\n        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None\n    ) -> None:\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    @t.overload\n    def __get__(self, obj: None, owner: None) -> te.Self: ...\n\n    @t.overload\n    def __get__(self, obj: App, owner: type[App]) -> T: ...\n\n    def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:\n        if obj is None:\n            return self\n\n        rv = obj.config[self.__name__]\n\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n\n        return rv  # type: ignore[no-any-return]\n\n    def __set__(self, obj: App, value: t.Any) -> None:\n        obj.config[self.__name__] = value",
    "start_line": 20,
    "end_line": 47,
    "has_docstring": true,
    "docstring": "Makes an attribute forward to the config",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ConfigAttribute",
    "component_id": "src.flask.config.ConfigAttribute"
  },
  "src.flask.config.Config": {
    "id": "src.flask.config.Config",
    "name": "Config",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/config.py",
    "relative_path": "src/flask/config.py",
    "depends_on": [
      "src.flask.json.__init__.loads",
      "src.flask.json.__init__.load"
    ],
    "source_code": "class Config(dict):  # type: ignore[type-arg]\n    \"\"\"Works exactly like a dict but provides ways to fill it from files\n    or special dictionaries.  There are two common patterns to populate the\n    config.\n\n    Either you can fill the config from a config file::\n\n        app.config.from_pyfile('yourconfig.cfg')\n\n    Or alternatively you can define the configuration options in the\n    module that calls :meth:`from_object` or provide an import path to\n    a module that should be loaded.  It is also possible to tell it to\n    use the same module and with that provide the configuration values\n    just before the call::\n\n        DEBUG = True\n        SECRET_KEY = 'development key'\n        app.config.from_object(__name__)\n\n    In both cases (loading from any Python file or loading from modules),\n    only uppercase keys are added to the config.  This makes it possible to use\n    lowercase values in the config file for temporary values that are not added\n    to the config or to define the config keys in the same file that implements\n    the application.\n\n    Probably the most interesting way to load configurations is from an\n    environment variable pointing to a file::\n\n        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\n    In this case before launching the application you have to set this\n    environment variable to the file you want to use.  On Linux and OS X\n    use the export statement::\n\n        export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\n    On windows use `set` instead.\n\n    :param root_path: path to which files are read relative from.  When the\n                      config object is created by the application, this is\n                      the application's :attr:`~flask.Flask.root_path`.\n    :param defaults: an optional dictionary of default values\n    \"\"\"\n\n    def __init__(\n        self,\n        root_path: str | os.PathLike[str],\n        defaults: dict[str, t.Any] | None = None,\n    ) -> None:\n        super().__init__(defaults or {})\n        self.root_path = root_path\n\n    def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)\n\n    def from_prefixed_env(\n        self, prefix: str = \"FLASK\", *, loads: t.Callable[[str], t.Any] = json.loads\n    ) -> bool:\n        \"\"\"Load any environment variables that start with ``FLASK_``,\n        dropping the prefix from the env key for the config key. Values\n        are passed through a loading function to attempt to convert them\n        to more specific types than strings.\n\n        Keys are loaded in :func:`sorted` order.\n\n        The default loading function attempts to parse values as any\n        valid JSON type, including dicts and lists.\n\n        Specific items in nested dicts can be set by separating the\n        keys with double underscores (``__``). If an intermediate key\n        doesn't exist, it will be initialized to an empty dict.\n\n        :param prefix: Load env vars that start with this prefix,\n            separated with an underscore (``_``).\n        :param loads: Pass each string value to this function and use\n            the returned value as the config value. If any error is\n            raised it is ignored and the value remains a string. The\n            default is :func:`json.loads`.\n\n        .. versionadded:: 2.1\n        \"\"\"\n        prefix = f\"{prefix}_\"\n\n        for key in sorted(os.environ):\n            if not key.startswith(prefix):\n                continue\n\n            value = os.environ[key]\n            key = key.removeprefix(prefix)\n\n            try:\n                value = loads(value)\n            except Exception:\n                # Keep the value as a string if loading failed.\n                pass\n\n            if \"__\" not in key:\n                # A non-nested key, set directly.\n                self[key] = value\n                continue\n\n            # Traverse nested dictionaries with keys separated by \"__\".\n            current = self\n            *parts, tail = key.split(\"__\")\n\n            for part in parts:\n                # If an intermediate dict does not exist, create it.\n                if part not in current:\n                    current[part] = {}\n\n                current = current[part]\n\n            current[tail] = value\n\n        return True\n\n    def from_pyfile(\n        self, filename: str | os.PathLike[str], silent: bool = False\n    ) -> bool:\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj: object | str) -> None:\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n\n    def from_file(\n        self,\n        filename: str | os.PathLike[str],\n        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],\n        silent: bool = False,\n        text: bool = True,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import tomllib\n            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :param text: Open the file in text or binary mode.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionchanged:: 2.3\n            The ``text`` parameter was added.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename, \"r\" if text else \"rb\") as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)\n\n    def from_mapping(\n        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any\n    ) -> bool:\n        \"\"\"Updates the config like :meth:`update` ignoring items with\n        non-upper keys.\n\n        :return: Always returns ``True``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings: dict[str, t.Any] = {}\n        if mapping is not None:\n            mappings.update(mapping)\n        mappings.update(kwargs)\n        for key, value in mappings.items():\n            if key.isupper():\n                self[key] = value\n        return True\n\n    def get_namespace(\n        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True\n    ) -> dict[str, t.Any]:\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in self.items():\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {dict.__repr__(self)}>\"",
    "start_line": 50,
    "end_line": 367,
    "has_docstring": true,
    "docstring": "Works exactly like a dict but provides ways to fill it from files\nor special dictionaries.  There are two common patterns to populate the\nconfig.\n\nEither you can fill the config from a config file::\n\n    app.config.from_pyfile('yourconfig.cfg')\n\nOr alternatively you can define the configuration options in the\nmodule that calls :meth:`from_object` or provide an import path to\na module that should be loaded.  It is also possible to tell it to\nuse the same module and with that provide the configuration values\njust before the call::\n\n    DEBUG = True\n    SECRET_KEY = 'development key'\n    app.config.from_object(__name__)\n\nIn both cases (loading from any Python file or loading from modules),\nonly uppercase keys are added to the config.  This makes it possible to use\nlowercase values in the config file for temporary values that are not added\nto the config or to define the config keys in the same file that implements\nthe application.\n\nProbably the most interesting way to load configurations is from an\nenvironment variable pointing to a file::\n\n    app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\nIn this case before launching the application you have to set this\nenvironment variable to the file you want to use.  On Linux and OS X\nuse the export statement::\n\n    export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\nOn windows use `set` instead.\n\n:param root_path: path to which files are read relative from.  When the\n                  config object is created by the application, this is\n                  the application's :attr:`~flask.Flask.root_path`.\n:param defaults: an optional dictionary of default values",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "dict"
    ],
    "class_name": null,
    "display_name": "class Config",
    "component_id": "src.flask.config.Config"
  },
  "src.flask.ctx._AppCtxGlobals": {
    "id": "src.flask.ctx._AppCtxGlobals",
    "name": "_AppCtxGlobals",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "class _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`.g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__.get(name, default)\n\n    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n        \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n\n    def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n        \"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.__dict__.setdefault(name, default)\n\n    def __contains__(self, item: str) -> bool:\n        return item in self.__dict__\n\n    def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)\n\n    def __repr__(self) -> str:\n        ctx = _cv_app.get(None)\n        if ctx is not None:\n            return f\"<flask.g of '{ctx.app.name}'>\"\n        return object.__repr__(self)",
    "start_line": 29,
    "end_line": 114,
    "has_docstring": true,
    "docstring": "A plain object. Used as a namespace for storing data during an\napplication context.\n\nCreating an app context automatically creates this object, which is\nmade available as the :data:`.g` proxy.\n\n.. describe:: 'key' in g\n\n    Check whether an attribute is present.\n\n    .. versionadded:: 0.10\n\n.. describe:: iter(g)\n\n    Return an iterator over the attribute names.\n\n    .. versionadded:: 0.10",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class _AppCtxGlobals",
    "component_id": "src.flask.ctx._AppCtxGlobals"
  },
  "src.flask.ctx.after_this_request": {
    "id": "src.flask.ctx.after_this_request",
    "name": "after_this_request",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "def after_this_request(\n    f: ft.AfterRequestCallable[t.Any],\n) -> ft.AfterRequestCallable[t.Any]:\n    \"\"\"Decorate a function to run after the current request. The behavior is the\n    same as :meth:`.Flask.after_request`, except it only applies to the current\n    request, rather than every request. Therefore, it must be used within a\n    request context, rather than during setup.\n\n    .. code-block:: python\n\n        @app.route(\"/\")\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers[\"X-Foo\"] = \"Parachute\"\n                return response\n\n            return \"Hello, World!\"\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_app.get(None)\n\n    if ctx is None or not ctx.has_request:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f",
    "start_line": 117,
    "end_line": 147,
    "has_docstring": true,
    "docstring": "Decorate a function to run after the current request. The behavior is the\nsame as :meth:`.Flask.after_request`, except it only applies to the current\nrequest, rather than every request. Therefore, it must be used within a\nrequest context, rather than during setup.\n\n.. code-block:: python\n\n    @app.route(\"/\")\n    def index():\n        @after_this_request\n        def add_header(response):\n            response.headers[\"X-Foo\"] = \"Parachute\"\n            return response\n\n        return \"Hello, World!\"\n\n.. versionadded:: 0.9",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function after_this_request",
    "component_id": "src.flask.ctx.after_this_request"
  },
  "src.flask.ctx.copy_current_request_context": {
    "id": "src.flask.ctx.copy_current_request_context",
    "name": "copy_current_request_context",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "def copy_current_request_context(f: F) -> F:\n    \"\"\"Decorate a function to run inside the current request context. This can\n    be used when starting a background task, otherwise it will not see the app\n    and request objects that were active in the parent.\n\n    .. warning::\n\n        Due to the following caveats, it is often safer (and simpler) to pass\n        the data you need when starting the task, rather than using this and\n        relying on the context objects.\n\n    In order to avoid execution switching partially though reading data, either\n    read the request body (access ``form``, ``json``, ``data``, etc) before\n    starting the task, or use a lock. This can be an issue when using threading,\n    but shouldn't be an issue when using greenlet/gevent or asyncio.\n\n    If the task will access ``session``, be sure to do so in the parent as well\n    so that the ``Vary: cookie`` header will be set. Modifying ``session`` in\n    the task should be avoided, as it may execute after the response cookie has\n    already been written.\n\n    .. code-block:: python\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_app.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)  # type: ignore[return-value]",
    "start_line": 153,
    "end_line": 205,
    "has_docstring": true,
    "docstring": "Decorate a function to run inside the current request context. This can\nbe used when starting a background task, otherwise it will not see the app\nand request objects that were active in the parent.\n\n.. warning::\n\n    Due to the following caveats, it is often safer (and simpler) to pass\n    the data you need when starting the task, rather than using this and\n    relying on the context objects.\n\nIn order to avoid execution switching partially though reading data, either\nread the request body (access ``form``, ``json``, ``data``, etc) before\nstarting the task, or use a lock. This can be an issue when using threading,\nbut shouldn't be an issue when using greenlet/gevent or asyncio.\n\nIf the task will access ``session``, be sure to do so in the parent as well\nso that the ``Vary: cookie`` header will be set. Modifying ``session`` in\nthe task should be avoided, as it may execute after the response cookie has\nalready been written.\n\n.. code-block:: python\n\n    import gevent\n    from flask import copy_current_request_context\n\n    @app.route('/')\n    def index():\n        @copy_current_request_context\n        def do_some_work():\n            # do some work here, it can access flask.request or\n            # flask.session like you would otherwise in the view function.\n            ...\n        gevent.spawn(do_some_work)\n        return 'Regular response'\n\n.. versionadded:: 0.10",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function copy_current_request_context",
    "component_id": "src.flask.ctx.copy_current_request_context"
  },
  "src.flask.ctx.wrapper": {
    "id": "src.flask.ctx.wrapper",
    "name": "wrapper",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)",
    "start_line": 201,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function wrapper",
    "component_id": "src.flask.ctx.wrapper"
  },
  "src.flask.ctx.has_request_context": {
    "id": "src.flask.ctx.has_request_context",
    "name": "has_request_context",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "def has_request_context() -> bool:\n    \"\"\"Test if an app context is active and if it has request information.\n\n    .. code-block:: python\n\n        from flask import has_request_context, request\n\n        if has_request_context():\n            remote_addr = request.remote_addr\n\n    If a request context is active, the :data:`.request` and :data:`.session`\n    context proxies will available and ``True``, otherwise ``False``. You can\n    use that to test the data you use, rather than using this function.\n\n    .. code-block:: python\n\n        from flask import request\n\n        if request:\n            remote_addr = request.remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return (ctx := _cv_app.get(None)) is not None and ctx.has_request",
    "start_line": 208,
    "end_line": 231,
    "has_docstring": true,
    "docstring": "Test if an app context is active and if it has request information.\n\n.. code-block:: python\n\n    from flask import has_request_context, request\n\n    if has_request_context():\n        remote_addr = request.remote_addr\n\nIf a request context is active, the :data:`.request` and :data:`.session`\ncontext proxies will available and ``True``, otherwise ``False``. You can\nuse that to test the data you use, rather than using this function.\n\n.. code-block:: python\n\n    from flask import request\n\n    if request:\n        remote_addr = request.remote_addr\n\n.. versionadded:: 0.7",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function has_request_context",
    "component_id": "src.flask.ctx.has_request_context"
  },
  "src.flask.ctx.has_app_context": {
    "id": "src.flask.ctx.has_app_context",
    "name": "has_app_context",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "def has_app_context() -> bool:\n    \"\"\"Test if an app context is active. Unlike :func:`has_request_context`\n    this can be true outside a request, such as in a CLI command.\n\n    .. code-block:: python\n\n        from flask import has_app_context, g\n\n        if has_app_context():\n            g.cached_data = ...\n\n    If an app context is active, the :data:`.g` and :data:`.current_app` context\n    proxies will available and ``True``, otherwise ``False``. You can use that\n    to test the data you use, rather than using this function.\n\n        from flask import g\n\n        if g:\n            g.cached_data = ...\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None",
    "start_line": 234,
    "end_line": 256,
    "has_docstring": true,
    "docstring": "Test if an app context is active. Unlike :func:`has_request_context`\nthis can be true outside a request, such as in a CLI command.\n\n.. code-block:: python\n\n    from flask import has_app_context, g\n\n    if has_app_context():\n        g.cached_data = ...\n\nIf an app context is active, the :data:`.g` and :data:`.current_app` context\nproxies will available and ``True``, otherwise ``False``. You can use that\nto test the data you use, rather than using this function.\n\n    from flask import g\n\n    if g:\n        g.cached_data = ...\n\n.. versionadded:: 0.9",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function has_app_context",
    "component_id": "src.flask.ctx.has_app_context"
  },
  "src.flask.ctx.AppContext": {
    "id": "src.flask.ctx.AppContext",
    "name": "AppContext",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "class AppContext:\n    \"\"\"An app context contains information about an app, and about the request\n    when handling a request. A context is pushed at the beginning of each\n    request and CLI command, and popped at the end. The context is referred to\n    as a \"request context\" if it has request information, and an \"app context\"\n    if not.\n\n    Do not use this class directly. Use :meth:`.Flask.app_context` to create an\n    app context if needed during setup, and :meth:`.Flask.test_request_context`\n    to create a request context if needed during tests.\n\n    When the context is popped, it will evaluate all the teardown functions\n    registered with :meth:`~flask.Flask.teardown_request` (if handling a\n    request) then :meth:`.Flask.teardown_appcontext`.\n\n    When using the interactive debugger, the context will be restored so\n    ``request`` is still accessible. Similarly, the test client can preserve the\n    context after the request ends. However, teardown functions may already have\n    closed some resources such as database connections, and will run again when\n    the restored context is popped.\n\n    :param app: The application this context represents.\n    :param request: The request data this context represents.\n    :param session: The session data this context represents. If not given,\n        loaded from the request on first access.\n\n    .. versionchanged:: 3.2\n        Merged with ``RequestContext``. The ``RequestContext`` alias will be\n        removed in Flask 4.0.\n\n    .. versionchanged:: 3.2\n        A combined app and request context is pushed for every request and CLI\n        command, rather than trying to detect if an app context is already\n        pushed.\n\n    .. versionchanged:: 3.2\n        The session is loaded the first time it is accessed, rather than when\n        the context is pushed.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        *,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> None:\n        self.app = app\n        \"\"\"The application represented by this context. Accessed through\n        :data:`.current_app`.\n        \"\"\"\n\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        \"\"\"The global data for this context. Accessed through :data:`.g`.\"\"\"\n\n        self.url_adapter: MapAdapter | None = None\n        \"\"\"The URL adapter bound to the request, or the app if not in a request.\n        May be ``None`` if binding failed.\n        \"\"\"\n\n        self._request: Request | None = request\n        self._session: SessionMixin | None = session\n        self._flashes: list[tuple[str, str]] | None = None\n        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []\n\n        try:\n            self.url_adapter = app.create_url_adapter(self._request)\n        except HTTPException as e:\n            if self._request is not None:\n                self._request.routing_exception = e\n\n        self._cv_token: contextvars.Token[AppContext] | None = None\n        \"\"\"The previous state to restore when popping.\"\"\"\n\n        self._push_count: int = 0\n        \"\"\"Track nested pushes of this context. Cleanup will only run once the\n        original push has been popped.\n        \"\"\"\n\n    @classmethod\n    def from_environ(cls, app: Flask, environ: WSGIEnvironment, /) -> te.Self:\n        \"\"\"Create an app context with request data from the given WSGI environ.\n\n        :param app: The application this context represents.\n        :param environ: The request data this context represents.\n        \"\"\"\n        request = app.request_class(environ)\n        request.json_module = app.json\n        return cls(app, request=request)\n\n    @property\n    def has_request(self) -> bool:\n        \"\"\"True if this context was created with request data.\"\"\"\n        return self._request is not None\n\n    def copy(self) -> te.Self:\n        \"\"\"Create a new context with the same data objects as this context. See\n        :func:`.copy_current_request_context`.\n\n        .. versionchanged:: 1.1\n            The current session data is used instead of reloading the original data.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__class__(\n            self.app,\n            request=self._request,\n            session=self._session,\n        )\n\n    @property\n    def request(self) -> Request:\n        \"\"\"The request object associated with this context. Accessed through\n        :data:`.request`. Only available in request contexts, otherwise raises\n        :exc:`RuntimeError`.\n        \"\"\"\n        if self._request is None:\n            raise RuntimeError(\"There is no request in this context.\")\n\n        return self._request\n\n    @property\n    def session(self) -> SessionMixin:\n        \"\"\"The session object associated with this context. Accessed through\n        :data:`.session`. Only available in request contexts, otherwise raises\n        :exc:`RuntimeError`.\n        \"\"\"\n        if self._request is None:\n            raise RuntimeError(\"There is no request in this context.\")\n\n        if self._session is None:\n            si = self.app.session_interface\n            self._session = si.open_session(self.app, self.request)\n\n            if self._session is None:\n                self._session = si.make_null_session(self.app)\n\n        return self._session\n\n    def match_request(self) -> None:\n        \"\"\"Apply routing to the current request, storing either the matched\n        endpoint and args, or a routing exception.\n        \"\"\"\n        try:\n            result = self.url_adapter.match(return_rule=True)  # type: ignore[union-attr]\n        except HTTPException as e:\n            self._request.routing_exception = e  # type: ignore[union-attr]\n        else:\n            self._request.url_rule, self._request.view_args = result  # type: ignore[union-attr]\n\n    def push(self) -> None:\n        \"\"\"Push this context so that it is the active context. If this is a\n        request context, calls :meth:`match_request` to perform routing with\n        the context active.\n\n        Typically, this is not used directly. Instead, use a ``with`` block\n        to manage the context.\n\n        In some situations, such as streaming or testing, the context may be\n        pushed multiple times. It will only trigger matching and signals if it\n        is not currently pushed.\n        \"\"\"\n        self._push_count += 1\n\n        if self._cv_token is not None:\n            return\n\n        self._cv_token = _cv_app.set(self)\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n        if self._request is not None and self.url_adapter is not None:\n            self.match_request()\n\n    def pop(self, exc: BaseException | None = None) -> None:\n        \"\"\"Pop this context so that it is no longer the active context. Then\n        call teardown functions and signals.\n\n        Typically, this is not used directly. Instead, use a ``with`` block\n        to manage the context.\n\n        This context must currently be the active context, otherwise a\n        :exc:`RuntimeError` is raised. In some situations, such as streaming or\n        testing, the context may have been pushed multiple times. It will only\n        trigger cleanup once it has been popped as many times as it was pushed.\n        Until then, it will remain the active context.\n\n        :param exc: An unhandled exception that was raised while the context was\n            active. Passed to teardown functions.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if self._cv_token is None:\n            raise RuntimeError(f\"Cannot pop this context ({self!r}), it is not pushed.\")\n\n        ctx = _cv_app.get(None)\n\n        if ctx is None or self._cv_token is None:\n            raise RuntimeError(\n                f\"Cannot pop this context ({self!r}), there is no active context.\"\n            )\n\n        if ctx is not self:\n            raise RuntimeError(\n                f\"Cannot pop this context ({self!r}), it is not the active\"\n                f\" context ({ctx!r}).\"\n            )\n\n        self._push_count -= 1\n\n        if self._push_count > 0:\n            return\n\n        try:\n            if self._request is not None:\n                self.app.do_teardown_request(self, exc)\n                self._request.close()\n        finally:\n            self.app.do_teardown_appcontext(self, exc)\n            _cv_app.reset(self._cv_token)\n            self._cv_token = None\n            appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n    def __enter__(self) -> te.Self:\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)\n\n    def __repr__(self) -> str:\n        if self._request is not None:\n            return (\n                f\"<{type(self).__name__} {id(self)} of {self.app.name},\"\n                f\" {self.request.method} {self.request.url!r}>\"\n            )\n\n        return f\"<{type(self).__name__} {id(self)} of {self.app.name}>\"",
    "start_line": 259,
    "end_line": 501,
    "has_docstring": true,
    "docstring": "An app context contains information about an app, and about the request\nwhen handling a request. A context is pushed at the beginning of each\nrequest and CLI command, and popped at the end. The context is referred to\nas a \"request context\" if it has request information, and an \"app context\"\nif not.\n\nDo not use this class directly. Use :meth:`.Flask.app_context` to create an\napp context if needed during setup, and :meth:`.Flask.test_request_context`\nto create a request context if needed during tests.\n\nWhen the context is popped, it will evaluate all the teardown functions\nregistered with :meth:`~flask.Flask.teardown_request` (if handling a\nrequest) then :meth:`.Flask.teardown_appcontext`.\n\nWhen using the interactive debugger, the context will be restored so\n``request`` is still accessible. Similarly, the test client can preserve the\ncontext after the request ends. However, teardown functions may already have\nclosed some resources such as database connections, and will run again when\nthe restored context is popped.\n\n:param app: The application this context represents.\n:param request: The request data this context represents.\n:param session: The session data this context represents. If not given,\n    loaded from the request on first access.\n\n.. versionchanged:: 3.2\n    Merged with ``RequestContext``. The ``RequestContext`` alias will be\n    removed in Flask 4.0.\n\n.. versionchanged:: 3.2\n    A combined app and request context is pushed for every request and CLI\n    command, rather than trying to detect if an app context is already\n    pushed.\n\n.. versionchanged:: 3.2\n    The session is loaded the first time it is accessed, rather than when\n    the context is pushed.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class AppContext",
    "component_id": "src.flask.ctx.AppContext"
  },
  "src.flask.ctx.__getattr__": {
    "id": "src.flask.ctx.__getattr__",
    "name": "__getattr__",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/ctx.py",
    "relative_path": "src/flask/ctx.py",
    "depends_on": [],
    "source_code": "def __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"RequestContext\":\n        warnings.warn(\n            \"'RequestContext' has merged with 'AppContext', and will be removed\"\n            \" in Flask 4.0. Use 'AppContext' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return AppContext\n\n    raise AttributeError(name)",
    "start_line": 504,
    "end_line": 516,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function __getattr__",
    "component_id": "src.flask.ctx.__getattr__"
  },
  "src.flask.debughelpers.UnexpectedUnicodeError": {
    "id": "src.flask.debughelpers.UnexpectedUnicodeError",
    "name": "UnexpectedUnicodeError",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [],
    "source_code": "class UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"",
    "start_line": 17,
    "end_line": 20,
    "has_docstring": true,
    "docstring": "Raised in places where we want some better error reporting for\nunexpected unicode or binary data.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "AssertionError",
      "UnicodeError"
    ],
    "class_name": null,
    "display_name": "class UnexpectedUnicodeError",
    "component_id": "src.flask.debughelpers.UnexpectedUnicodeError"
  },
  "src.flask.debughelpers.DebugFilesKeyError": {
    "id": "src.flask.debughelpers.DebugFilesKeyError",
    "name": "DebugFilesKeyError",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [],
    "source_code": "class DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError/BadRequest.\n    \"\"\"\n\n    def __init__(self, request: Request, key: str) -> None:\n        form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)\n\n    def __str__(self) -> str:\n        return self.msg",
    "start_line": 23,
    "end_line": 47,
    "has_docstring": true,
    "docstring": "Raised from request.files during debugging.  The idea is that it can\nprovide a better error message than just a generic KeyError/BadRequest.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "KeyError",
      "AssertionError"
    ],
    "class_name": null,
    "display_name": "class DebugFilesKeyError",
    "component_id": "src.flask.debughelpers.DebugFilesKeyError"
  },
  "src.flask.debughelpers.FormDataRoutingRedirect": {
    "id": "src.flask.debughelpers.FormDataRoutingRedirect",
    "name": "FormDataRoutingRedirect",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [],
    "source_code": "class FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised in debug mode if a routing redirect\n    would cause the browser to drop the method or body. This happens\n    when method is not GET, HEAD or OPTIONS and the status code is not\n    307 or 308.\n    \"\"\"\n\n    def __init__(self, request: Request) -> None:\n        exc = request.routing_exception\n        assert isinstance(exc, RequestRedirect)\n        buf = [\n            f\"A request was sent to '{request.url}', but routing issued\"\n            f\" a redirect to the canonical URL '{exc.new_url}'.\"\n        ]\n\n        if f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\n            buf.append(\n                \" The URL was defined with a trailing slash. Flask\"\n                \" will redirect to the URL with a trailing slash if it\"\n                \" was accessed without one.\"\n            )\n\n        buf.append(\n            \" Send requests to the canonical URL, or use 307 or 308 for\"\n            \" routing redirects. Otherwise, browsers will drop form\"\n            \" data.\\n\\n\"\n            \"This exception is only raised in debug mode.\"\n        )\n        super().__init__(\"\".join(buf))",
    "start_line": 50,
    "end_line": 78,
    "has_docstring": true,
    "docstring": "This exception is raised in debug mode if a routing redirect\nwould cause the browser to drop the method or body. This happens\nwhen method is not GET, HEAD or OPTIONS and the status code is not\n307 or 308.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "AssertionError"
    ],
    "class_name": null,
    "display_name": "class FormDataRoutingRedirect",
    "component_id": "src.flask.debughelpers.FormDataRoutingRedirect"
  },
  "src.flask.debughelpers.attach_enctype_error_multidict": {
    "id": "src.flask.debughelpers.attach_enctype_error_multidict",
    "name": "attach_enctype_error_multidict",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [],
    "source_code": "def attach_enctype_error_multidict(request: Request) -> None:\n    \"\"\"Patch ``request.files.__getitem__`` to raise a descriptive error\n    about ``enctype=multipart/form-data``.\n\n    :param request: The request to patch.\n    :meta private:\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):  # type: ignore[valid-type, misc]\n        def __getitem__(self, key: str) -> t.Any:\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls",
    "start_line": 81,
    "end_line": 104,
    "has_docstring": true,
    "docstring": "Patch ``request.files.__getitem__`` to raise a descriptive error\nabout ``enctype=multipart/form-data``.\n\n:param request: The request to patch.\n:meta private:",
    "parameters": [
      "request"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function attach_enctype_error_multidict",
    "component_id": "src.flask.debughelpers.attach_enctype_error_multidict"
  },
  "src.flask.debughelpers.newcls": {
    "id": "src.flask.debughelpers.newcls",
    "name": "newcls",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [
      "src.flask.debughelpers.DebugFilesKeyError"
    ],
    "source_code": "    class newcls(oldcls):  # type: ignore[valid-type, misc]\n        def __getitem__(self, key: str) -> t.Any:\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None",
    "start_line": 90,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "oldcls"
    ],
    "class_name": null,
    "display_name": "class newcls",
    "component_id": "src.flask.debughelpers.newcls"
  },
  "src.flask.debughelpers._dump_loader_info": {
    "id": "src.flask.debughelpers._dump_loader_info",
    "name": "_dump_loader_info",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [],
    "source_code": "def _dump_loader_info(loader: BaseLoader) -> t.Iterator[str]:\n    yield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, str) for x in value):\n                continue\n            yield f\"{key}:\"\n            for item in value:\n                yield f\"  - {item}\"\n            continue\n        elif not isinstance(value, (str, int, float, bool)):\n            continue\n        yield f\"{key}: {value!r}\"",
    "start_line": 107,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "loader"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _dump_loader_info",
    "component_id": "src.flask.debughelpers._dump_loader_info"
  },
  "src.flask.debughelpers.explain_template_loading_attempts": {
    "id": "src.flask.debughelpers.explain_template_loading_attempts",
    "name": "explain_template_loading_attempts",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/debughelpers.py",
    "relative_path": "src/flask/debughelpers.py",
    "depends_on": [
      "src.flask.debughelpers._dump_loader_info"
    ],
    "source_code": "def explain_template_loading_attempts(\n    app: App,\n    template: str,\n    attempts: list[\n        tuple[\n            BaseLoader,\n            Scaffold,\n            tuple[str, str | None, t.Callable[[], bool] | None] | None,\n        ]\n    ],\n) -> None:\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = [f\"Locating template {template!r}:\"]\n    total_found = 0\n    blueprint = None\n\n    if (ctx := _cv_app.get(None)) is not None and ctx.has_request:\n        blueprint = ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, App):\n            src_info = f\"application {srcobj.import_name!r}\"\n        elif isinstance(srcobj, Blueprint):\n            src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f\"{idx + 1:5}: trying loader of {src_info}\")\n\n        for line in _dump_loader_info(loader):\n            info.append(f\"       {line}\")\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = f\"found ({triple[1] or '<string>'!r})\"\n            total_found += 1\n        info.append(f\"       -> {detail}\")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that belongs\"\n            f\" to the blueprint {blueprint!r}.\"\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n\n    app.logger.info(\"\\n\".join(info))",
    "start_line": 124,
    "end_line": 179,
    "has_docstring": true,
    "docstring": "This should help developers understand what failed",
    "parameters": [
      "app",
      "template",
      "attempts"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function explain_template_loading_attempts",
    "component_id": "src.flask.debughelpers.explain_template_loading_attempts"
  },
  "src.flask.globals.ProxyMixin": {
    "id": "src.flask.globals.ProxyMixin",
    "name": "ProxyMixin",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "    class ProxyMixin(t.Protocol[T]):\n        def _get_current_object(self) -> T: ...",
    "start_line": 17,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ProxyMixin",
    "component_id": "src.flask.globals.ProxyMixin"
  },
  "src.flask.globals.FlaskProxy": {
    "id": "src.flask.globals.FlaskProxy",
    "name": "FlaskProxy",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "    class FlaskProxy(ProxyMixin[Flask], Flask): ...",
    "start_line": 22,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Flask"
    ],
    "class_name": null,
    "display_name": "class FlaskProxy",
    "component_id": "src.flask.globals.FlaskProxy"
  },
  "src.flask.globals.AppContextProxy": {
    "id": "src.flask.globals.AppContextProxy",
    "name": "AppContextProxy",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "    class AppContextProxy(ProxyMixin[AppContext], AppContext): ...",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "AppContext"
    ],
    "class_name": null,
    "display_name": "class AppContextProxy",
    "component_id": "src.flask.globals.AppContextProxy"
  },
  "src.flask.globals._AppCtxGlobalsProxy": {
    "id": "src.flask.globals._AppCtxGlobalsProxy",
    "name": "_AppCtxGlobalsProxy",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "    class _AppCtxGlobalsProxy(ProxyMixin[_AppCtxGlobals], _AppCtxGlobals): ...",
    "start_line": 26,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "_AppCtxGlobals"
    ],
    "class_name": null,
    "display_name": "class _AppCtxGlobalsProxy",
    "component_id": "src.flask.globals._AppCtxGlobalsProxy"
  },
  "src.flask.globals.RequestProxy": {
    "id": "src.flask.globals.RequestProxy",
    "name": "RequestProxy",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "    class RequestProxy(ProxyMixin[Request], Request): ...",
    "start_line": 28,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Request"
    ],
    "class_name": null,
    "display_name": "class RequestProxy",
    "component_id": "src.flask.globals.RequestProxy"
  },
  "src.flask.globals.SessionMixinProxy": {
    "id": "src.flask.globals.SessionMixinProxy",
    "name": "SessionMixinProxy",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "    class SessionMixinProxy(ProxyMixin[SessionMixin], SessionMixin): ...",
    "start_line": 30,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SessionMixin"
    ],
    "class_name": null,
    "display_name": "class SessionMixinProxy",
    "component_id": "src.flask.globals.SessionMixinProxy"
  },
  "src.flask.globals.__getattr__": {
    "id": "src.flask.globals.__getattr__",
    "name": "__getattr__",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/globals.py",
    "relative_path": "src/flask/globals.py",
    "depends_on": [],
    "source_code": "def __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"request_ctx\":\n        warnings.warn(\n            \"'request_ctx' has merged with 'app_ctx', and will be removed\"\n            \" in Flask 4.0. Use 'app_ctx' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return app_ctx\n\n    raise AttributeError(name)",
    "start_line": 65,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function __getattr__",
    "component_id": "src.flask.globals.__getattr__"
  },
  "src.flask.helpers.get_debug_flag": {
    "id": "src.flask.helpers.get_debug_flag",
    "name": "get_debug_flag",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})",
    "start_line": 27,
    "end_line": 32,
    "has_docstring": true,
    "docstring": "Get whether debug mode should be enabled for the app, indicated by the\n:envvar:`FLASK_DEBUG` environment variable. The default is ``False``.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_debug_flag",
    "component_id": "src.flask.helpers.get_debug_flag"
  },
  "src.flask.helpers.get_load_dotenv": {
    "id": "src.flask.helpers.get_load_dotenv",
    "name": "get_load_dotenv",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")",
    "start_line": 35,
    "end_line": 47,
    "has_docstring": true,
    "docstring": "Get whether the user has disabled loading default dotenv files by\nsetting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\nthe files.\n\n:param default: What to return if the env var isn't set.",
    "parameters": [
      "default"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_load_dotenv",
    "component_id": "src.flask.helpers.get_load_dotenv"
  },
  "src.flask.helpers.stream_with_context": {
    "id": "src.flask.helpers.stream_with_context",
    "name": "stream_with_context",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Wrap a response generator function so that it runs inside the current\n    request context. This keeps :data:`.request`, :data:`.session`, and :data:`.g`\n    available, even though at the point the generator runs the request context\n    will typically have ended.\n\n    Use it as a decorator on a generator function:\n\n    .. code-block:: python\n\n        from flask import stream_with_context, request, Response\n\n        @app.get(\"/stream\")\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield \"Hello \"\n                yield request.args[\"name\"]\n                yield \"!\"\n\n            return Response(generate())\n\n    Or use it as a wrapper around a created generator:\n\n    .. code-block:: python\n\n        from flask import stream_with_context, request, Response\n\n        @app.get(\"/stream\")\n        def streamed_response():\n            def generate():\n                yield \"Hello \"\n                yield request.args[\"name\"]\n                yield \"!\"\n\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr]:\n        if (ctx := _cv_app.get(None)) is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n\n        with ctx:\n            yield None  # type: ignore[misc]\n\n            try:\n                yield from gen\n            finally:\n                # Clean up in case the user wrapped a WSGI iterator.\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # Execute the generator to the sentinel value. This captures the current\n    # context and pushes it to preserve it. Further iteration will yield from\n    # the original iterator.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g",
    "start_line": 62,
    "end_line": 135,
    "has_docstring": true,
    "docstring": "Wrap a response generator function so that it runs inside the current\nrequest context. This keeps :data:`.request`, :data:`.session`, and :data:`.g`\navailable, even though at the point the generator runs the request context\nwill typically have ended.\n\nUse it as a decorator on a generator function:\n\n.. code-block:: python\n\n    from flask import stream_with_context, request, Response\n\n    @app.get(\"/stream\")\n    def streamed_response():\n        @stream_with_context\n        def generate():\n            yield \"Hello \"\n            yield request.args[\"name\"]\n            yield \"!\"\n\n        return Response(generate())\n\nOr use it as a wrapper around a created generator:\n\n.. code-block:: python\n\n    from flask import stream_with_context, request, Response\n\n    @app.get(\"/stream\")\n    def streamed_response():\n        def generate():\n            yield \"Hello \"\n            yield request.args[\"name\"]\n            yield \"!\"\n\n        return Response(stream_with_context(generate()))\n\n.. versionadded:: 0.9",
    "parameters": [
      "generator_or_function"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function stream_with_context",
    "component_id": "src.flask.helpers.stream_with_context"
  },
  "src.flask.helpers.decorator": {
    "id": "src.flask.helpers.decorator",
    "name": "decorator",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers.stream_with_context"
    ],
    "source_code": "        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)",
    "start_line": 107,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function decorator",
    "component_id": "src.flask.helpers.decorator"
  },
  "src.flask.helpers.generator": {
    "id": "src.flask.helpers.generator",
    "name": "generator",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "    def generator() -> t.Iterator[t.AnyStr]:\n        if (ctx := _cv_app.get(None)) is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n\n        with ctx:\n            yield None  # type: ignore[misc]\n\n            try:\n                yield from gen\n            finally:\n                # Clean up in case the user wrapped a WSGI iterator.\n                if hasattr(gen, \"close\"):\n                    gen.close()",
    "start_line": 113,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generator",
    "component_id": "src.flask.helpers.generator"
  },
  "src.flask.helpers.make_response": {
    "id": "src.flask.helpers.make_response",
    "name": "make_response",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers.make_response"
    ],
    "source_code": "def make_response(*args: t.Any) -> Response:\n    \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a return\n    and you will get a response object which you can use to attach headers.\n\n    If view looked like this and you want to add a new header::\n\n        def index():\n            return render_template('index.html', foo=42)\n\n    You can now do something like this::\n\n        def index():\n            response = make_response(render_template('index.html', foo=42))\n            response.headers['X-Parachutes'] = 'parachutes are cool'\n            return response\n\n    This function accepts the very same arguments you can return from a\n    view function.  This for example creates a response with a 404 error\n    code::\n\n        response = make_response(render_template('not_found.html'), 404)\n\n    The other use case of this function is to force the return value of a\n    view function into a response which is helpful with view\n    decorators::\n\n        response = make_response(view_function())\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n\n    Internally this function does the following things:\n\n    -   if no arguments are passed, it creates a new response argument\n    -   if one argument is passed, :meth:`flask.Flask.make_response`\n        is invoked with it.\n    -   if more than one argument is passed, the arguments are passed\n        to the :meth:`flask.Flask.make_response` function as tuple.\n\n    .. versionadded:: 0.6\n    \"\"\"\n    if not args:\n        return current_app.response_class()\n    if len(args) == 1:\n        args = args[0]\n    return current_app.make_response(args)",
    "start_line": 138,
    "end_line": 184,
    "has_docstring": true,
    "docstring": "Sometimes it is necessary to set additional headers in a view.  Because\nviews do not have to return response objects but can return a value that\nis converted into a response object by Flask itself, it becomes tricky to\nadd headers to it.  This function can be called instead of using a return\nand you will get a response object which you can use to attach headers.\n\nIf view looked like this and you want to add a new header::\n\n    def index():\n        return render_template('index.html', foo=42)\n\nYou can now do something like this::\n\n    def index():\n        response = make_response(render_template('index.html', foo=42))\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n        return response\n\nThis function accepts the very same arguments you can return from a\nview function.  This for example creates a response with a 404 error\ncode::\n\n    response = make_response(render_template('not_found.html'), 404)\n\nThe other use case of this function is to force the return value of a\nview function into a response which is helpful with view\ndecorators::\n\n    response = make_response(view_function())\n    response.headers['X-Parachutes'] = 'parachutes are cool'\n\nInternally this function does the following things:\n\n-   if no arguments are passed, it creates a new response argument\n-   if one argument is passed, :meth:`flask.Flask.make_response`\n    is invoked with it.\n-   if more than one argument is passed, the arguments are passed\n    to the :meth:`flask.Flask.make_response` function as tuple.\n\n.. versionadded:: 0.6",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function make_response",
    "component_id": "src.flask.helpers.make_response"
  },
  "src.flask.helpers.url_for": {
    "id": "src.flask.helpers.url_for",
    "name": "url_for",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers.url_for"
    ],
    "source_code": "def url_for(\n    endpoint: str,\n    *,\n    _anchor: str | None = None,\n    _method: str | None = None,\n    _scheme: str | None = None,\n    _external: bool | None = None,\n    **values: t.Any,\n) -> str:\n    \"\"\"Generate a URL to the given endpoint with the given values.\n\n    This requires an active request or application context, and calls\n    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\n    for full documentation.\n\n    :param endpoint: The endpoint name associated with the URL to\n        generate. If this starts with a ``.``, the current blueprint\n        name (if any) will be used.\n    :param _anchor: If given, append this as ``#anchor`` to the URL.\n    :param _method: If given, generate the URL associated with this\n        method for the endpoint.\n    :param _scheme: If given, the URL will have this scheme if it is\n        external.\n    :param _external: If given, prefer the URL to be internal (False) or\n        require it to be external (True). External URLs include the\n        scheme and domain. When not in an active request, URLs are\n        external by default.\n    :param values: Values to use for the variable parts of the URL rule.\n        Unknown keys are appended as query string arguments, like\n        ``?a=b&c=d``.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.url_for``, allowing an app to override the\n        behavior.\n\n    .. versionchanged:: 0.10\n       The ``_scheme`` parameter was added.\n\n    .. versionchanged:: 0.9\n       The ``_anchor`` and ``_method`` parameters were added.\n\n    .. versionchanged:: 0.9\n       Calls ``app.handle_url_build_error`` on build errors.\n    \"\"\"\n    return current_app.url_for(\n        endpoint,\n        _anchor=_anchor,\n        _method=_method,\n        _scheme=_scheme,\n        _external=_external,\n        **values,\n    )",
    "start_line": 187,
    "end_line": 238,
    "has_docstring": true,
    "docstring": "Generate a URL to the given endpoint with the given values.\n\nThis requires an active request or application context, and calls\n:meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\nfor full documentation.\n\n:param endpoint: The endpoint name associated with the URL to\n    generate. If this starts with a ``.``, the current blueprint\n    name (if any) will be used.\n:param _anchor: If given, append this as ``#anchor`` to the URL.\n:param _method: If given, generate the URL associated with this\n    method for the endpoint.\n:param _scheme: If given, the URL will have this scheme if it is\n    external.\n:param _external: If given, prefer the URL to be internal (False) or\n    require it to be external (True). External URLs include the\n    scheme and domain. When not in an active request, URLs are\n    external by default.\n:param values: Values to use for the variable parts of the URL rule.\n    Unknown keys are appended as query string arguments, like\n    ``?a=b&c=d``.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.url_for``, allowing an app to override the\n    behavior.\n\n.. versionchanged:: 0.10\n   The ``_scheme`` parameter was added.\n\n.. versionchanged:: 0.9\n   The ``_anchor`` and ``_method`` parameters were added.\n\n.. versionchanged:: 0.9\n   Calls ``app.handle_url_build_error`` on build errors.",
    "parameters": [
      "endpoint"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function url_for",
    "component_id": "src.flask.helpers.url_for"
  },
  "src.flask.helpers.redirect": {
    "id": "src.flask.helpers.redirect",
    "name": "redirect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers.redirect"
    ],
    "source_code": "def redirect(\n    location: str, code: int = 302, Response: type[BaseResponse] | None = None\n) -> BaseResponse:\n    \"\"\"Create a redirect response object.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`~flask.Flask.redirect` method, otherwise it will use\n    :func:`werkzeug.utils.redirect`.\n\n    :param location: The URL to redirect to.\n    :param code: The status code for the redirect.\n    :param Response: The response class to use. Not used when\n        ``current_app`` is active, which uses ``app.response_class``.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.redirect`` if available instead of always\n        using Werkzeug's default ``redirect``.\n    \"\"\"\n    if (ctx := _cv_app.get(None)) is not None:\n        return ctx.app.redirect(location, code=code)\n\n    return _wz_redirect(location, code=code, Response=Response)",
    "start_line": 241,
    "end_line": 262,
    "has_docstring": true,
    "docstring": "Create a redirect response object.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`~flask.Flask.redirect` method, otherwise it will use\n:func:`werkzeug.utils.redirect`.\n\n:param location: The URL to redirect to.\n:param code: The status code for the redirect.\n:param Response: The response class to use. Not used when\n    ``current_app`` is active, which uses ``app.response_class``.\n\n.. versionadded:: 2.2\n    Calls ``current_app.redirect`` if available instead of always\n    using Werkzeug's default ``redirect``.",
    "parameters": [
      "location",
      "code",
      "Response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function redirect",
    "component_id": "src.flask.helpers.redirect"
  },
  "src.flask.helpers.abort": {
    "id": "src.flask.helpers.abort",
    "name": "abort",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n    \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n    status code.\n\n    If :data:`~flask.current_app` is available, it will call its\n    :attr:`~flask.Flask.aborter` object, otherwise it will use\n    :func:`werkzeug.exceptions.abort`.\n\n    :param code: The status code for the exception, which must be\n        registered in ``app.aborter``.\n    :param args: Passed to the exception.\n    :param kwargs: Passed to the exception.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.aborter`` if available instead of always\n        using Werkzeug's default ``abort``.\n    \"\"\"\n    if (ctx := _cv_app.get(None)) is not None:\n        ctx.app.aborter(code, *args, **kwargs)\n\n    _wz_abort(code, *args, **kwargs)",
    "start_line": 265,
    "end_line": 285,
    "has_docstring": true,
    "docstring": "Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\nstatus code.\n\nIf :data:`~flask.current_app` is available, it will call its\n:attr:`~flask.Flask.aborter` object, otherwise it will use\n:func:`werkzeug.exceptions.abort`.\n\n:param code: The status code for the exception, which must be\n    registered in ``app.aborter``.\n:param args: Passed to the exception.\n:param kwargs: Passed to the exception.\n\n.. versionadded:: 2.2\n    Calls ``current_app.aborter`` if available instead of always\n    using Werkzeug's default ``abort``.",
    "parameters": [
      "code"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function abort",
    "component_id": "src.flask.helpers.abort"
  },
  "src.flask.helpers.get_template_attribute": {
    "id": "src.flask.helpers.get_template_attribute",
    "name": "get_template_attribute",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n    \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n    invoke a macro from within Python code.  If you for example have a\n    template named :file:`_cider.html` with the following contents:\n\n    .. sourcecode:: html+jinja\n\n       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\n    You can access this from Python code like this::\n\n        hello = get_template_attribute('_cider.html', 'hello')\n        return hello('World')\n\n    .. versionadded:: 0.2\n\n    :param template_name: the name of the template\n    :param attribute: the name of the variable of macro to access\n    \"\"\"\n    return getattr(current_app.jinja_env.get_template(template_name).module, attribute)",
    "start_line": 288,
    "end_line": 307,
    "has_docstring": true,
    "docstring": "Loads a macro (or variable) a template exports.  This can be used to\ninvoke a macro from within Python code.  If you for example have a\ntemplate named :file:`_cider.html` with the following contents:\n\n.. sourcecode:: html+jinja\n\n   {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\nYou can access this from Python code like this::\n\n    hello = get_template_attribute('_cider.html', 'hello')\n    return hello('World')\n\n.. versionadded:: 0.2\n\n:param template_name: the name of the template\n:param attribute: the name of the variable of macro to access",
    "parameters": [
      "template_name",
      "attribute"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_template_attribute",
    "component_id": "src.flask.helpers.get_template_attribute"
  },
  "src.flask.helpers.flash": {
    "id": "src.flask.helpers.flash",
    "name": "flash",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def flash(message: str, category: str = \"message\") -> None:\n    \"\"\"Flashes a message to the next request.  In order to remove the\n    flashed message from the session and to display it to the user,\n    the template has to call :func:`get_flashed_messages`.\n\n    .. versionchanged:: 0.3\n       `category` parameter added.\n\n    :param message: the message to be flashed.\n    :param category: the category for the message.  The following values\n                     are recommended: ``'message'`` for any kind of message,\n                     ``'error'`` for errors, ``'info'`` for information\n                     messages and ``'warning'`` for warnings.  However any\n                     kind of string can be used as category.\n    \"\"\"\n    # Original implementation:\n    #\n    #     session.setdefault('_flashes', []).append((category, message))\n    #\n    # This assumed that changes made to mutable structures in the session are\n    # always in sync with the session object, which is not true for session\n    # implementations that use external storage for keeping their keys/values.\n    flashes = session.get(\"_flashes\", [])\n    flashes.append((category, message))\n    session[\"_flashes\"] = flashes\n    app = current_app._get_current_object()\n    message_flashed.send(\n        app,\n        _async_wrapper=app.ensure_sync,\n        message=message,\n        category=category,\n    )",
    "start_line": 310,
    "end_line": 341,
    "has_docstring": true,
    "docstring": "Flashes a message to the next request.  In order to remove the\nflashed message from the session and to display it to the user,\nthe template has to call :func:`get_flashed_messages`.\n\n.. versionchanged:: 0.3\n   `category` parameter added.\n\n:param message: the message to be flashed.\n:param category: the category for the message.  The following values\n                 are recommended: ``'message'`` for any kind of message,\n                 ``'error'`` for errors, ``'info'`` for information\n                 messages and ``'warning'`` for warnings.  However any\n                 kind of string can be used as category.",
    "parameters": [
      "message",
      "category"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function flash",
    "component_id": "src.flask.helpers.flash"
  },
  "src.flask.helpers.get_flashed_messages": {
    "id": "src.flask.helpers.get_flashed_messages",
    "name": "get_flashed_messages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def get_flashed_messages(\n    with_categories: bool = False, category_filter: t.Iterable[str] = ()\n) -> list[str] | list[tuple[str, str]]:\n    \"\"\"Pulls all flashed messages from the session and returns them.\n    Further calls in the same request to the function will return\n    the same messages.  By default just the messages are returned,\n    but when `with_categories` is set to ``True``, the return value will\n    be a list of tuples in the form ``(category, message)`` instead.\n\n    Filter the flashed messages to one or more categories by providing those\n    categories in `category_filter`.  This allows rendering categories in\n    separate html blocks.  The `with_categories` and `category_filter`\n    arguments are distinct:\n\n    * `with_categories` controls whether categories are returned with message\n      text (``True`` gives a tuple, where ``False`` gives just the message text).\n    * `category_filter` filters the messages down to only those matching the\n      provided categories.\n\n    See :doc:`/patterns/flashing` for examples.\n\n    .. versionchanged:: 0.3\n       `with_categories` parameter added.\n\n    .. versionchanged:: 0.9\n        `category_filter` parameter added.\n\n    :param with_categories: set to ``True`` to also receive categories.\n    :param category_filter: filter of categories to limit return values.  Only\n                            categories in the list will be returned.\n    \"\"\"\n    flashes = app_ctx._flashes\n    if flashes is None:\n        flashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\n        app_ctx._flashes = flashes\n    if category_filter:\n        flashes = list(filter(lambda f: f[0] in category_filter, flashes))\n    if not with_categories:\n        return [x[1] for x in flashes]\n    return flashes",
    "start_line": 344,
    "end_line": 383,
    "has_docstring": true,
    "docstring": "Pulls all flashed messages from the session and returns them.\nFurther calls in the same request to the function will return\nthe same messages.  By default just the messages are returned,\nbut when `with_categories` is set to ``True``, the return value will\nbe a list of tuples in the form ``(category, message)`` instead.\n\nFilter the flashed messages to one or more categories by providing those\ncategories in `category_filter`.  This allows rendering categories in\nseparate html blocks.  The `with_categories` and `category_filter`\narguments are distinct:\n\n* `with_categories` controls whether categories are returned with message\n  text (``True`` gives a tuple, where ``False`` gives just the message text).\n* `category_filter` filters the messages down to only those matching the\n  provided categories.\n\nSee :doc:`/patterns/flashing` for examples.\n\n.. versionchanged:: 0.3\n   `with_categories` parameter added.\n\n.. versionchanged:: 0.9\n    `category_filter` parameter added.\n\n:param with_categories: set to ``True`` to also receive categories.\n:param category_filter: filter of categories to limit return values.  Only\n                        categories in the list will be returned.",
    "parameters": [
      "with_categories",
      "category_filter"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_flashed_messages",
    "component_id": "src.flask.helpers.get_flashed_messages"
  },
  "src.flask.helpers._prepare_send_file_kwargs": {
    "id": "src.flask.helpers._prepare_send_file_kwargs",
    "name": "_prepare_send_file_kwargs",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:\n    ctx = app_ctx._get_current_object()\n\n    if kwargs.get(\"max_age\") is None:\n        kwargs[\"max_age\"] = ctx.app.get_send_file_max_age\n\n    kwargs.update(\n        environ=ctx.request.environ,\n        use_x_sendfile=ctx.app.config[\"USE_X_SENDFILE\"],\n        response_class=ctx.app.response_class,\n        _root_path=ctx.app.root_path,\n    )\n    return kwargs",
    "start_line": 386,
    "end_line": 398,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _prepare_send_file_kwargs",
    "component_id": "src.flask.helpers._prepare_send_file_kwargs"
  },
  "src.flask.helpers.send_file": {
    "id": "src.flask.helpers.send_file",
    "name": "send_file",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers.send_file",
      "src.flask.helpers._prepare_send_file_kwargs"
    ],
    "source_code": "def send_file(\n    path_or_file: os.PathLike[t.AnyStr] | str | t.IO[bytes],\n    mimetype: str | None = None,\n    as_attachment: bool = False,\n    download_name: str | None = None,\n    conditional: bool = True,\n    etag: bool | str = True,\n    last_modified: datetime | int | float | None = None,\n    max_age: None | (int | t.Callable[[str | None], int | None]) = None,\n) -> Response:\n    \"\"\"Send the contents of a file to the client.\n\n    The first argument can be a file path or a file-like object. Paths\n    are preferred in most cases because Werkzeug can manage the file and\n    get extra information from the path. Passing a file-like object\n    requires that the file is opened in binary mode, and is mostly\n    useful when building a file in memory with :class:`io.BytesIO`.\n\n    Never pass file paths provided by a user. The path is assumed to be\n    trusted, so a user could craft a path to access a file you didn't\n    intend. Use :func:`send_from_directory` to safely serve\n    user-requested paths from within a directory.\n\n    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is\n    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,\n    if the HTTP server supports ``X-Sendfile``, configuring Flask with\n    ``USE_X_SENDFILE = True`` will tell the server to send the given\n    path, which is much more efficient than reading it in Python.\n\n    :param path_or_file: The path to the file to send, relative to the\n        current working directory if a relative path is given.\n        Alternatively, a file-like object opened in binary mode. Make\n        sure the file pointer is seeked to the start of the data.\n    :param mimetype: The MIME type to send for the file. If not\n        provided, it will try to detect it from the file name.\n    :param as_attachment: Indicate to a browser that it should offer to\n        save the file instead of displaying it.\n    :param download_name: The default name browsers will use when saving\n        the file. Defaults to the passed file name.\n    :param conditional: Enable conditional and range responses based on\n        request headers. Requires passing a file path and ``environ``.\n    :param etag: Calculate an ETag for the file, which requires passing\n        a file path. Can also be a string to use instead.\n    :param last_modified: The last modified time to send for the file,\n        in seconds. If not provided, it will try to detect it from the\n        file path.\n    :param max_age: How long the client should cache the file, in\n        seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n        it will be ``no-cache`` to prefer conditional caching.\n\n    .. versionchanged:: 2.0\n        ``download_name`` replaces the ``attachment_filename``\n        parameter. If ``as_attachment=False``, it is passed with\n        ``Content-Disposition: inline`` instead.\n\n    .. versionchanged:: 2.0\n        ``max_age`` replaces the ``cache_timeout`` parameter.\n        ``conditional`` is enabled and ``max_age`` is not set by\n        default.\n\n    .. versionchanged:: 2.0\n        ``etag`` replaces the ``add_etags`` parameter. It can be a\n        string to use instead of generating one.\n\n    .. versionchanged:: 2.0\n        Passing a file-like object that inherits from\n        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n        than sending an empty file.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionchanged:: 1.1\n        ``filename`` may be a :class:`~os.PathLike` object.\n\n    .. versionchanged:: 1.1\n        Passing a :class:`~io.BytesIO` object supports range requests.\n\n    .. versionchanged:: 1.0.3\n        Filenames are encoded with ASCII instead of Latin-1 for broader\n        compatibility with WSGI servers.\n\n    .. versionchanged:: 1.0\n        UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n    .. versionchanged:: 0.12\n        The filename is no longer automatically inferred from file\n        objects. If you want to use automatic MIME and etag support,\n        pass a filename via ``filename_or_fp`` or\n        ``attachment_filename``.\n\n    .. versionchanged:: 0.12\n        ``attachment_filename`` is preferred over ``filename`` for MIME\n        detection.\n\n    .. versionchanged:: 0.9\n        ``cache_timeout`` defaults to\n        :meth:`Flask.get_send_file_max_age`.\n\n    .. versionchanged:: 0.7\n        MIME guessing and etag support for file-like objects was\n        removed because it was unreliable. Pass a filename if you are\n        able to, otherwise attach an etag yourself.\n\n    .. versionchanged:: 0.5\n        The ``add_etags``, ``cache_timeout`` and ``conditional``\n        parameters were added. The default behavior is to add etags.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return werkzeug.utils.send_file(  # type: ignore[return-value]\n        **_prepare_send_file_kwargs(\n            path_or_file=path_or_file,\n            environ=request.environ,\n            mimetype=mimetype,\n            as_attachment=as_attachment,\n            download_name=download_name,\n            conditional=conditional,\n            etag=etag,\n            last_modified=last_modified,\n            max_age=max_age,\n        )\n    )",
    "start_line": 401,
    "end_line": 524,
    "has_docstring": true,
    "docstring": "Send the contents of a file to the client.\n\nThe first argument can be a file path or a file-like object. Paths\nare preferred in most cases because Werkzeug can manage the file and\nget extra information from the path. Passing a file-like object\nrequires that the file is opened in binary mode, and is mostly\nuseful when building a file in memory with :class:`io.BytesIO`.\n\nNever pass file paths provided by a user. The path is assumed to be\ntrusted, so a user could craft a path to access a file you didn't\nintend. Use :func:`send_from_directory` to safely serve\nuser-requested paths from within a directory.\n\nIf the WSGI server sets a ``file_wrapper`` in ``environ``, it is\nused, otherwise Werkzeug's built-in wrapper is used. Alternatively,\nif the HTTP server supports ``X-Sendfile``, configuring Flask with\n``USE_X_SENDFILE = True`` will tell the server to send the given\npath, which is much more efficient than reading it in Python.\n\n:param path_or_file: The path to the file to send, relative to the\n    current working directory if a relative path is given.\n    Alternatively, a file-like object opened in binary mode. Make\n    sure the file pointer is seeked to the start of the data.\n:param mimetype: The MIME type to send for the file. If not\n    provided, it will try to detect it from the file name.\n:param as_attachment: Indicate to a browser that it should offer to\n    save the file instead of displaying it.\n:param download_name: The default name browsers will use when saving\n    the file. Defaults to the passed file name.\n:param conditional: Enable conditional and range responses based on\n    request headers. Requires passing a file path and ``environ``.\n:param etag: Calculate an ETag for the file, which requires passing\n    a file path. Can also be a string to use instead.\n:param last_modified: The last modified time to send for the file,\n    in seconds. If not provided, it will try to detect it from the\n    file path.\n:param max_age: How long the client should cache the file, in\n    seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n    it will be ``no-cache`` to prefer conditional caching.\n\n.. versionchanged:: 2.0\n    ``download_name`` replaces the ``attachment_filename``\n    parameter. If ``as_attachment=False``, it is passed with\n    ``Content-Disposition: inline`` instead.\n\n.. versionchanged:: 2.0\n    ``max_age`` replaces the ``cache_timeout`` parameter.\n    ``conditional`` is enabled and ``max_age`` is not set by\n    default.\n\n.. versionchanged:: 2.0\n    ``etag`` replaces the ``add_etags`` parameter. It can be a\n    string to use instead of generating one.\n\n.. versionchanged:: 2.0\n    Passing a file-like object that inherits from\n    :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n    than sending an empty file.\n\n.. versionadded:: 2.0\n    Moved the implementation to Werkzeug. This is now a wrapper to\n    pass some Flask-specific arguments.\n\n.. versionchanged:: 1.1\n    ``filename`` may be a :class:`~os.PathLike` object.\n\n.. versionchanged:: 1.1\n    Passing a :class:`~io.BytesIO` object supports range requests.\n\n.. versionchanged:: 1.0.3\n    Filenames are encoded with ASCII instead of Latin-1 for broader\n    compatibility with WSGI servers.\n\n.. versionchanged:: 1.0\n    UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n.. versionchanged:: 0.12\n    The filename is no longer automatically inferred from file\n    objects. If you want to use automatic MIME and etag support,\n    pass a filename via ``filename_or_fp`` or\n    ``attachment_filename``.\n\n.. versionchanged:: 0.12\n    ``attachment_filename`` is preferred over ``filename`` for MIME\n    detection.\n\n.. versionchanged:: 0.9\n    ``cache_timeout`` defaults to\n    :meth:`Flask.get_send_file_max_age`.\n\n.. versionchanged:: 0.7\n    MIME guessing and etag support for file-like objects was\n    removed because it was unreliable. Pass a filename if you are\n    able to, otherwise attach an etag yourself.\n\n.. versionchanged:: 0.5\n    The ``add_etags``, ``cache_timeout`` and ``conditional``\n    parameters were added. The default behavior is to add etags.\n\n.. versionadded:: 0.2",
    "parameters": [
      "path_or_file",
      "mimetype",
      "as_attachment",
      "download_name",
      "conditional",
      "etag",
      "last_modified",
      "max_age"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function send_file",
    "component_id": "src.flask.helpers.send_file"
  },
  "src.flask.helpers.send_from_directory": {
    "id": "src.flask.helpers.send_from_directory",
    "name": "send_from_directory",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers._prepare_send_file_kwargs",
      "src.flask.helpers.send_from_directory"
    ],
    "source_code": "def send_from_directory(\n    directory: os.PathLike[str] | str,\n    path: os.PathLike[str] | str,\n    **kwargs: t.Any,\n) -> Response:\n    \"\"\"Send a file from within a directory using :func:`send_file`.\n\n    .. code-block:: python\n\n        @app.route(\"/uploads/<path:name>\")\n        def download_file(name):\n            return send_from_directory(\n                app.config['UPLOAD_FOLDER'], name, as_attachment=True\n            )\n\n    This is a secure way to serve files from a folder, such as static\n    files or uploads. Uses :func:`~werkzeug.security.safe_join` to\n    ensure the path coming from the client is not maliciously crafted to\n    point outside the specified directory.\n\n    If the final path does not point to an existing regular file,\n    raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n\n    :param directory: The directory that ``path`` must be located under,\n        relative to the current application's root path. This *must not*\n        be a value provided by the client, otherwise it becomes insecure.\n    :param path: The path to the file to send, relative to\n        ``directory``.\n    :param kwargs: Arguments to pass to :func:`send_file`.\n\n    .. versionchanged:: 2.0\n        ``path`` replaces the ``filename`` parameter.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionadded:: 0.5\n    \"\"\"\n    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n        directory, path, **_prepare_send_file_kwargs(**kwargs)\n    )",
    "start_line": 527,
    "end_line": 568,
    "has_docstring": true,
    "docstring": "Send a file from within a directory using :func:`send_file`.\n\n.. code-block:: python\n\n    @app.route(\"/uploads/<path:name>\")\n    def download_file(name):\n        return send_from_directory(\n            app.config['UPLOAD_FOLDER'], name, as_attachment=True\n        )\n\nThis is a secure way to serve files from a folder, such as static\nfiles or uploads. Uses :func:`~werkzeug.security.safe_join` to\nensure the path coming from the client is not maliciously crafted to\npoint outside the specified directory.\n\nIf the final path does not point to an existing regular file,\nraises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n\n:param directory: The directory that ``path`` must be located under,\n    relative to the current application's root path. This *must not*\n    be a value provided by the client, otherwise it becomes insecure.\n:param path: The path to the file to send, relative to\n    ``directory``.\n:param kwargs: Arguments to pass to :func:`send_file`.\n\n.. versionchanged:: 2.0\n    ``path`` replaces the ``filename`` parameter.\n\n.. versionadded:: 2.0\n    Moved the implementation to Werkzeug. This is now a wrapper to\n    pass some Flask-specific arguments.\n\n.. versionadded:: 0.5",
    "parameters": [
      "directory",
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function send_from_directory",
    "component_id": "src.flask.helpers.send_from_directory"
  },
  "src.flask.helpers.get_root_path": {
    "id": "src.flask.helpers.get_root_path",
    "name": "get_root_path",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [],
    "source_code": "def get_root_path(import_name: str) -> str:\n    \"\"\"Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n\n    Not to be confused with the value returned by :func:`find_package`.\n\n    :meta private:\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    try:\n        spec = importlib.util.find_spec(import_name)\n\n        if spec is None:\n            raise ValueError\n    except (ImportError, ValueError):\n        loader = None\n    else:\n        loader = spec.loader\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None:\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)  # pyright: ignore\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))  # type: ignore[no-any-return]",
    "start_line": 571,
    "end_line": 625,
    "has_docstring": true,
    "docstring": "Find the root path of a package, or the path that contains a\nmodule. If it cannot be found, returns the current working\ndirectory.\n\nNot to be confused with the value returned by :func:`find_package`.\n\n:meta private:",
    "parameters": [
      "import_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_root_path",
    "component_id": "src.flask.helpers.get_root_path"
  },
  "src.flask.helpers._split_blueprint_path": {
    "id": "src.flask.helpers._split_blueprint_path",
    "name": "_split_blueprint_path",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/helpers.py",
    "relative_path": "src/flask/helpers.py",
    "depends_on": [
      "src.flask.helpers._split_blueprint_path"
    ],
    "source_code": "def _split_blueprint_path(name: str) -> list[str]:\n    out: list[str] = [name]\n\n    if \".\" in name:\n        out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n\n    return out",
    "start_line": 629,
    "end_line": 635,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _split_blueprint_path",
    "component_id": "src.flask.helpers._split_blueprint_path"
  },
  "src.flask.json.__init__.dumps": {
    "id": "src.flask.json.__init__.dumps",
    "name": "dumps",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/__init__.py",
    "relative_path": "src/flask/json/__init__.py",
    "depends_on": [
      "src.flask.json.__init__.dumps"
    ],
    "source_code": "def dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)",
    "start_line": 13,
    "end_line": 44,
    "has_docstring": true,
    "docstring": "Serialize data as JSON.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\nmethod, otherwise it will use :func:`json.dumps`.\n\n:param obj: The data to serialize.\n:param kwargs: Arguments passed to the ``dumps`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.dumps``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0.2\n    :class:`decimal.Decimal` is supported by converting to a string.\n\n.. versionchanged:: 2.0\n    ``encoding`` will be removed in Flask 2.1.\n\n.. versionchanged:: 1.0.3\n    ``app`` can be passed directly, rather than requiring an app\n    context for configuration.",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function dumps",
    "component_id": "src.flask.json.__init__.dumps"
  },
  "src.flask.json.__init__.dump": {
    "id": "src.flask.json.__init__.dump",
    "name": "dump",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/__init__.py",
    "relative_path": "src/flask/json/__init__.py",
    "depends_on": [
      "src.flask.json.__init__.dump"
    ],
    "source_code": "def dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n    \"\"\"Serialize data as JSON and write to a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n    method, otherwise it will use :func:`json.dump`.\n\n    :param obj: The data to serialize.\n    :param fp: A file opened for writing text. Should use the UTF-8\n        encoding to be valid JSON.\n    :param kwargs: Arguments passed to the ``dump`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dump``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, will be\n        removed in Flask 2.1.\n    \"\"\"\n    if current_app:\n        current_app.json.dump(obj, fp, **kwargs)\n    else:\n        kwargs.setdefault(\"default\", _default)\n        _json.dump(obj, fp, **kwargs)",
    "start_line": 47,
    "end_line": 74,
    "has_docstring": true,
    "docstring": "Serialize data as JSON and write to a file.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\nmethod, otherwise it will use :func:`json.dump`.\n\n:param obj: The data to serialize.\n:param fp: A file opened for writing text. Should use the UTF-8\n    encoding to be valid JSON.\n:param kwargs: Arguments passed to the ``dump`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.dump``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0\n    Writing to a binary file, and the ``encoding`` argument, will be\n    removed in Flask 2.1.",
    "parameters": [
      "obj",
      "fp"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function dump",
    "component_id": "src.flask.json.__init__.dump"
  },
  "src.flask.json.__init__.loads": {
    "id": "src.flask.json.__init__.loads",
    "name": "loads",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/__init__.py",
    "relative_path": "src/flask/json/__init__.py",
    "depends_on": [
      "src.flask.json.__init__.loads"
    ],
    "source_code": "def loads(s: str | bytes, **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\n    method, otherwise it will use :func:`json.loads`.\n\n    :param s: Text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``loads`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.loads``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The data must be a\n        string or UTF-8 bytes.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.loads(s, **kwargs)\n\n    return _json.loads(s, **kwargs)",
    "start_line": 77,
    "end_line": 105,
    "has_docstring": true,
    "docstring": "Deserialize data as JSON.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\nmethod, otherwise it will use :func:`json.loads`.\n\n:param s: Text or UTF-8 bytes.\n:param kwargs: Arguments passed to the ``loads`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.loads``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0\n    ``encoding`` will be removed in Flask 2.1. The data must be a\n    string or UTF-8 bytes.\n\n.. versionchanged:: 1.0.3\n    ``app`` can be passed directly, rather than requiring an app\n    context for configuration.",
    "parameters": [
      "s"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function loads",
    "component_id": "src.flask.json.__init__.loads"
  },
  "src.flask.json.__init__.load": {
    "id": "src.flask.json.__init__.load",
    "name": "load",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/__init__.py",
    "relative_path": "src/flask/json/__init__.py",
    "depends_on": [
      "src.flask.json.__init__.load"
    ],
    "source_code": "def load(fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON read from a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\n    method, otherwise it will use :func:`json.load`.\n\n    :param fp: A file opened for reading text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``load`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.load``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.2\n        The ``app`` parameter will be removed in Flask 2.3.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The file must be text\n        mode, or binary mode with UTF-8 bytes.\n    \"\"\"\n    if current_app:\n        return current_app.json.load(fp, **kwargs)\n\n    return _json.load(fp, **kwargs)",
    "start_line": 108,
    "end_line": 135,
    "has_docstring": true,
    "docstring": "Deserialize data as JSON read from a file.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\nmethod, otherwise it will use :func:`json.load`.\n\n:param fp: A file opened for reading text or UTF-8 bytes.\n:param kwargs: Arguments passed to the ``load`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.load``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.2\n    The ``app`` parameter will be removed in Flask 2.3.\n\n.. versionchanged:: 2.0\n    ``encoding`` will be removed in Flask 2.1. The file must be text\n    mode, or binary mode with UTF-8 bytes.",
    "parameters": [
      "fp"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load",
    "component_id": "src.flask.json.__init__.load"
  },
  "src.flask.json.__init__.jsonify": {
    "id": "src.flask.json.__init__.jsonify",
    "name": "jsonify",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/__init__.py",
    "relative_path": "src/flask/json/__init__.py",
    "depends_on": [],
    "source_code": "def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n    \"\"\"Serialize the given arguments as JSON, and return a\n    :class:`~flask.Response` object with the ``application/json``\n    mimetype. A dict or list returned from a view will be converted to a\n    JSON response automatically without needing to call this.\n\n    This requires an active app context, and calls\n    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\n    In debug mode, the output is formatted with indentation to make it\n    easier to read. This may also be controlled by the provider.\n\n    Either positional or keyword arguments can be given, not both.\n    If no arguments are given, ``None`` is serialized.\n\n    :param args: A single value to serialize, or multiple values to\n        treat as a list to serialize.\n    :param kwargs: Treat as a dict to serialize.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.response``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 0.11\n        Added support for serializing top-level arrays. This was a\n        security risk in ancient browsers. See :ref:`security-json`.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return current_app.json.response(*args, **kwargs)  # type: ignore[return-value]",
    "start_line": 138,
    "end_line": 170,
    "has_docstring": true,
    "docstring": "Serialize the given arguments as JSON, and return a\n:class:`~flask.Response` object with the ``application/json``\nmimetype. A dict or list returned from a view will be converted to a\nJSON response automatically without needing to call this.\n\nThis requires an active app context, and calls\n:meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\nIn debug mode, the output is formatted with indentation to make it\neasier to read. This may also be controlled by the provider.\n\nEither positional or keyword arguments can be given, not both.\nIf no arguments are given, ``None`` is serialized.\n\n:param args: A single value to serialize, or multiple values to\n    treat as a list to serialize.\n:param kwargs: Treat as a dict to serialize.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.response``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0.2\n    :class:`decimal.Decimal` is supported by converting to a string.\n\n.. versionchanged:: 0.11\n    Added support for serializing top-level arrays. This was a\n    security risk in ancient browsers. See :ref:`security-json`.\n\n.. versionadded:: 0.2",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function jsonify",
    "component_id": "src.flask.json.__init__.jsonify"
  },
  "src.flask.json.provider.JSONProvider": {
    "id": "src.flask.json.provider.JSONProvider",
    "name": "JSONProvider",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/provider.py",
    "relative_path": "src/flask/json/provider.py",
    "depends_on": [
      "src.flask.json.__init__.dumps",
      "src.flask.json.__init__.loads"
    ],
    "source_code": "class JSONProvider:\n    \"\"\"A standard set of JSON operations for an application. Subclasses\n    of this can be used to customize JSON behavior or use different\n    JSON libraries.\n\n    To implement a provider for a specific library, subclass this base\n    class and implement at least :meth:`dumps` and :meth:`loads`. All\n    other methods have default implementations.\n\n    To use a different provider, either subclass ``Flask`` and set\n    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n\n    :param app: An application instance. This will be stored as a\n        :class:`weakref.proxy` on the :attr:`_app` attribute.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self._app: App = weakref.proxy(app)\n\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON.\n\n        :param obj: The data to serialize.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n\n    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n        \"\"\"Serialize data as JSON and write to a file.\n\n        :param obj: The data to serialize.\n        :param fp: A file opened for writing text. Should use the UTF-8\n            encoding to be valid JSON.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        fp.write(self.dumps(obj, **kwargs))\n\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n\n    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON read from a file.\n\n        :param fp: A file opened for reading text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        return self.loads(fp.read(), **kwargs)\n\n    def _prepare_response_obj(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> t.Any:\n        if args and kwargs:\n            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n\n        if not args and not kwargs:\n            return None\n\n        if len(args) == 1:\n            return args[0]\n\n        return args or kwargs\n\n    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n        \"\"\"Serialize the given arguments as JSON, and return a\n        :class:`~flask.Response` object with the ``application/json``\n        mimetype.\n\n        The :func:`~flask.json.jsonify` function calls this method for\n        the current application.\n\n        Either positional or keyword arguments can be given, not both.\n        If no arguments are given, ``None`` is serialized.\n\n        :param args: A single value to serialize, or multiple values to\n            treat as a list to serialize.\n        :param kwargs: Treat as a dict to serialize.\n        \"\"\"\n        obj = self._prepare_response_obj(args, kwargs)\n        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")",
    "start_line": 19,
    "end_line": 105,
    "has_docstring": true,
    "docstring": "A standard set of JSON operations for an application. Subclasses\nof this can be used to customize JSON behavior or use different\nJSON libraries.\n\nTo implement a provider for a specific library, subclass this base\nclass and implement at least :meth:`dumps` and :meth:`loads`. All\nother methods have default implementations.\n\nTo use a different provider, either subclass ``Flask`` and set\n:attr:`~flask.Flask.json_provider_class` to a provider class, or set\n:attr:`app.json <flask.Flask.json>` to an instance of the class.\n\n:param app: An application instance. This will be stored as a\n    :class:`weakref.proxy` on the :attr:`_app` attribute.\n\n.. versionadded:: 2.2",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class JSONProvider",
    "component_id": "src.flask.json.provider.JSONProvider"
  },
  "src.flask.json.provider._default": {
    "id": "src.flask.json.provider._default",
    "name": "_default",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/provider.py",
    "relative_path": "src/flask/json/provider.py",
    "depends_on": [],
    "source_code": "def _default(o: t.Any) -> t.Any:\n    if isinstance(o, date):\n        return http_date(o)\n\n    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n        return str(o)\n\n    if dataclasses and dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)  # type: ignore[arg-type]\n\n    if hasattr(o, \"__html__\"):\n        return str(o.__html__())\n\n    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")",
    "start_line": 108,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "o"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _default",
    "component_id": "src.flask.json.provider._default"
  },
  "src.flask.json.provider.DefaultJSONProvider": {
    "id": "src.flask.json.provider.DefaultJSONProvider",
    "name": "DefaultJSONProvider",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/provider.py",
    "relative_path": "src/flask/json/provider.py",
    "depends_on": [
      "src.flask.json.__init__.dumps",
      "src.flask.json.__init__.loads",
      "src.flask.json.provider.JSONProvider"
    ],
    "source_code": "class DefaultJSONProvider(JSONProvider):\n    \"\"\"Provide JSON operations using Python's built-in :mod:`json`\n    library. Serializes the following additional data types:\n\n    -   :class:`datetime.datetime` and :class:`datetime.date` are\n        serialized to :rfc:`822` strings. This is the same as the HTTP\n        date format.\n    -   :class:`uuid.UUID` is serialized to a string.\n    -   :class:`dataclasses.dataclass` is passed to\n        :func:`dataclasses.asdict`.\n    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n        method) will call the ``__html__`` method to get a string.\n    \"\"\"\n\n    default: t.Callable[[t.Any], t.Any] = staticmethod(_default)\n    \"\"\"Apply this function to any object that :meth:`json.dumps` does\n    not know how to serialize. It should return a valid JSON type or\n    raise a ``TypeError``.\n    \"\"\"\n\n    ensure_ascii = True\n    \"\"\"Replace non-ASCII characters with escape sequences. This may be\n    more compatible with some clients, but can be disabled for better\n    performance and size.\n    \"\"\"\n\n    sort_keys = True\n    \"\"\"Sort the keys in any serialized dicts. This may be useful for\n    some caching situations, but can be disabled for better performance.\n    When enabled, keys must all be strings, they are not converted\n    before sorting.\n    \"\"\"\n\n    compact: bool | None = None\n    \"\"\"If ``True``, or ``None`` out of debug mode, the :meth:`response`\n    output will not add indentation, newlines, or spaces. If ``False``,\n    or ``None`` in debug mode, it will use a non-compact representation.\n    \"\"\"\n\n    mimetype = \"application/json\"\n    \"\"\"The mimetype set in :meth:`response`.\"\"\"\n\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON to a string.\n\n        Keyword arguments are passed to :func:`json.dumps`. Sets some\n        parameter defaults from the :attr:`default`,\n        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n\n        :param obj: The data to serialize.\n        :param kwargs: Passed to :func:`json.dumps`.\n        \"\"\"\n        kwargs.setdefault(\"default\", self.default)\n        kwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\n        kwargs.setdefault(\"sort_keys\", self.sort_keys)\n        return json.dumps(obj, **kwargs)\n\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON from a string or bytes.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: Passed to :func:`json.loads`.\n        \"\"\"\n        return json.loads(s, **kwargs)\n\n    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n        \"\"\"Serialize the given arguments as JSON, and return a\n        :class:`~flask.Response` object with it. The response mimetype\n        will be \"application/json\" and can be changed with\n        :attr:`mimetype`.\n\n        If :attr:`compact` is ``False`` or debug mode is enabled, the\n        output will be formatted to be easier to read.\n\n        Either positional or keyword arguments can be given, not both.\n        If no arguments are given, ``None`` is serialized.\n\n        :param args: A single value to serialize, or multiple values to\n            treat as a list to serialize.\n        :param kwargs: Treat as a dict to serialize.\n        \"\"\"\n        obj = self._prepare_response_obj(args, kwargs)\n        dump_args: dict[str, t.Any] = {}\n\n        if (self.compact is None and self._app.debug) or self.compact is False:\n            dump_args.setdefault(\"indent\", 2)\n        else:\n            dump_args.setdefault(\"separators\", (\",\", \":\"))\n\n        return self._app.response_class(\n            f\"{self.dumps(obj, **dump_args)}\\n\", mimetype=self.mimetype\n        )",
    "start_line": 124,
    "end_line": 215,
    "has_docstring": true,
    "docstring": "Provide JSON operations using Python's built-in :mod:`json`\nlibrary. Serializes the following additional data types:\n\n-   :class:`datetime.datetime` and :class:`datetime.date` are\n    serialized to :rfc:`822` strings. This is the same as the HTTP\n    date format.\n-   :class:`uuid.UUID` is serialized to a string.\n-   :class:`dataclasses.dataclass` is passed to\n    :func:`dataclasses.asdict`.\n-   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n    method) will call the ``__html__`` method to get a string.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONProvider"
    ],
    "class_name": null,
    "display_name": "class DefaultJSONProvider",
    "component_id": "src.flask.json.provider.DefaultJSONProvider"
  },
  "src.flask.json.tag.JSONTag": {
    "id": "src.flask.json.tag.JSONTag",
    "name": "JSONTag",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [],
    "source_code": "class JSONTag:\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = (\"serializer\",)\n\n    #: The tag to mark the serialized object with. If empty, this tag is\n    #: only used as an intermediate step during tagging.\n    key: str = \"\"\n\n    def __init__(self, serializer: TaggedJSONSerializer) -> None:\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n\n    def check(self, value: t.Any) -> bool:\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n\n    def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n\n    def tag(self, value: t.Any) -> dict[str, t.Any]:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}",
    "start_line": 60,
    "end_line": 90,
    "has_docstring": true,
    "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class JSONTag",
    "component_id": "src.flask.json.tag.JSONTag"
  },
  "src.flask.json.tag.TagDict": {
    "id": "src.flask.json.tag.TagDict",
    "name": "TagDict",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class TagDict(JSONTag):\n    \"\"\"Tag for 1-item dicts whose only key matches a registered tag.\n\n    Internally, the dict key is suffixed with `__`, and the suffix is removed\n    when deserializing.\n    \"\"\"\n\n    __slots__ = ()\n    key = \" di\"\n\n    def check(self, value: t.Any) -> bool:\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )\n\n    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n\n    def to_python(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {key[:-2]: value[key]}",
    "start_line": 93,
    "end_line": 116,
    "has_docstring": true,
    "docstring": "Tag for 1-item dicts whose only key matches a registered tag.\n\nInternally, the dict key is suffixed with `__`, and the suffix is removed\nwhen deserializing.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class TagDict",
    "component_id": "src.flask.json.tag.TagDict"
  },
  "src.flask.json.tag.PassDict": {
    "id": "src.flask.json.tag.PassDict",
    "name": "PassDict",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class PassDict(JSONTag):\n    __slots__ = ()\n\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, dict)\n\n    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n\n    tag = to_json",
    "start_line": 119,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class PassDict",
    "component_id": "src.flask.json.tag.PassDict"
  },
  "src.flask.json.tag.TagTuple": {
    "id": "src.flask.json.tag.TagTuple",
    "name": "TagTuple",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class TagTuple(JSONTag):\n    __slots__ = ()\n    key = \" t\"\n\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, tuple)\n\n    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n\n    def to_python(self, value: t.Any) -> t.Any:\n        return tuple(value)",
    "start_line": 133,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class TagTuple",
    "component_id": "src.flask.json.tag.TagTuple"
  },
  "src.flask.json.tag.PassList": {
    "id": "src.flask.json.tag.PassList",
    "name": "PassList",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class PassList(JSONTag):\n    __slots__ = ()\n\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, list)\n\n    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n\n    tag = to_json",
    "start_line": 147,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class PassList",
    "component_id": "src.flask.json.tag.PassList"
  },
  "src.flask.json.tag.TagBytes": {
    "id": "src.flask.json.tag.TagBytes",
    "name": "TagBytes",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class TagBytes(JSONTag):\n    __slots__ = ()\n    key = \" b\"\n\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, bytes)\n\n    def to_json(self, value: t.Any) -> t.Any:\n        return b64encode(value).decode(\"ascii\")\n\n    def to_python(self, value: t.Any) -> t.Any:\n        return b64decode(value)",
    "start_line": 159,
    "end_line": 170,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class TagBytes",
    "component_id": "src.flask.json.tag.TagBytes"
  },
  "src.flask.json.tag.TagMarkup": {
    "id": "src.flask.json.tag.TagMarkup",
    "name": "TagMarkup",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class TagMarkup(JSONTag):\n    \"\"\"Serialize anything matching the :class:`~markupsafe.Markup` API by\n    having a ``__html__`` method to the result of that method. Always\n    deserializes to an instance of :class:`~markupsafe.Markup`.\"\"\"\n\n    __slots__ = ()\n    key = \" m\"\n\n    def check(self, value: t.Any) -> bool:\n        return callable(getattr(value, \"__html__\", None))\n\n    def to_json(self, value: t.Any) -> t.Any:\n        return str(value.__html__())\n\n    def to_python(self, value: t.Any) -> t.Any:\n        return Markup(value)",
    "start_line": 173,
    "end_line": 188,
    "has_docstring": true,
    "docstring": "Serialize anything matching the :class:`~markupsafe.Markup` API by\nhaving a ``__html__`` method to the result of that method. Always\ndeserializes to an instance of :class:`~markupsafe.Markup`.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class TagMarkup",
    "component_id": "src.flask.json.tag.TagMarkup"
  },
  "src.flask.json.tag.TagUUID": {
    "id": "src.flask.json.tag.TagUUID",
    "name": "TagUUID",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class TagUUID(JSONTag):\n    __slots__ = ()\n    key = \" u\"\n\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, UUID)\n\n    def to_json(self, value: t.Any) -> t.Any:\n        return value.hex\n\n    def to_python(self, value: t.Any) -> t.Any:\n        return UUID(value)",
    "start_line": 191,
    "end_line": 202,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class TagUUID",
    "component_id": "src.flask.json.tag.TagUUID"
  },
  "src.flask.json.tag.TagDateTime": {
    "id": "src.flask.json.tag.TagDateTime",
    "name": "TagDateTime",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.tag.JSONTag"
    ],
    "source_code": "class TagDateTime(JSONTag):\n    __slots__ = ()\n    key = \" d\"\n\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, datetime)\n\n    def to_json(self, value: t.Any) -> t.Any:\n        return http_date(value)\n\n    def to_python(self, value: t.Any) -> t.Any:\n        return parse_date(value)",
    "start_line": 205,
    "end_line": 216,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "JSONTag"
    ],
    "class_name": null,
    "display_name": "class TagDateTime",
    "component_id": "src.flask.json.tag.TagDateTime"
  },
  "src.flask.json.tag.TaggedJSONSerializer": {
    "id": "src.flask.json.tag.TaggedJSONSerializer",
    "name": "TaggedJSONSerializer",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/json/tag.py",
    "relative_path": "src/flask/json/tag.py",
    "depends_on": [
      "src.flask.json.__init__.dumps",
      "src.flask.json.__init__.loads"
    ],
    "source_code": "class TaggedJSONSerializer:\n    \"\"\"Serializer that uses a tag system to compactly represent objects that\n    are not JSON types. Passed as the intermediate serializer to\n    :class:`itsdangerous.Serializer`.\n\n    The following extra types are supported:\n\n    * :class:`dict`\n    * :class:`tuple`\n    * :class:`bytes`\n    * :class:`~markupsafe.Markup`\n    * :class:`~uuid.UUID`\n    * :class:`~datetime.datetime`\n    \"\"\"\n\n    __slots__ = (\"tags\", \"order\")\n\n    #: Tag classes to bind when creating the serializer. Other tags can be\n    #: added later using :meth:`~register`.\n    default_tags = [\n        TagDict,\n        PassDict,\n        TagTuple,\n        PassList,\n        TagBytes,\n        TagMarkup,\n        TagUUID,\n        TagDateTime,\n    ]\n\n    def __init__(self) -> None:\n        self.tags: dict[str, JSONTag] = {}\n        self.order: list[JSONTag] = []\n\n        for cls in self.default_tags:\n            self.register(cls)\n\n    def register(\n        self,\n        tag_class: type[JSONTag],\n        force: bool = False,\n        index: int | None = None,\n    ) -> None:\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If ``None``\n            (default), the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key:\n            if not force and key in self.tags:\n                raise KeyError(f\"Tag '{key}' is already registered.\")\n\n            self.tags[key] = tag\n\n        if index is None:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)\n\n    def tag(self, value: t.Any) -> t.Any:\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n\n    def untag(self, value: dict[str, t.Any]) -> t.Any:\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n\n    def _untag_scan(self, value: t.Any) -> t.Any:\n        if isinstance(value, dict):\n            # untag each item recursively\n            value = {k: self._untag_scan(v) for k, v in value.items()}\n            # untag the dict itself\n            value = self.untag(value)\n        elif isinstance(value, list):\n            # untag each item recursively\n            value = [self._untag_scan(item) for item in value]\n\n        return value\n\n    def dumps(self, value: t.Any) -> str:\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))\n\n    def loads(self, value: str) -> t.Any:\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return self._untag_scan(loads(value))",
    "start_line": 219,
    "end_line": 327,
    "has_docstring": true,
    "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class TaggedJSONSerializer",
    "component_id": "src.flask.json.tag.TaggedJSONSerializer"
  },
  "src.flask.logging.wsgi_errors_stream": {
    "id": "src.flask.logging.wsgi_errors_stream",
    "name": "wsgi_errors_stream",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/logging.py",
    "relative_path": "src/flask/logging.py",
    "depends_on": [],
    "source_code": "def wsgi_errors_stream() -> t.TextIO:\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    if request:\n        return request.environ[\"wsgi.errors\"]  # type: ignore[no-any-return]\n\n    return sys.stderr",
    "start_line": 16,
    "end_line": 28,
    "has_docstring": true,
    "docstring": "Find the most appropriate error stream for the application. If a request\nis active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\nIf you configure your own :class:`logging.StreamHandler`, you may want to\nuse this for the stream. If you are using file or dict configuration and\ncan't import this directly, you can refer to it as\n``ext://flask.logging.wsgi_errors_stream``.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function wsgi_errors_stream",
    "component_id": "src.flask.logging.wsgi_errors_stream"
  },
  "src.flask.logging.has_level_handler": {
    "id": "src.flask.logging.has_level_handler",
    "name": "has_level_handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/logging.py",
    "relative_path": "src/flask/logging.py",
    "depends_on": [],
    "source_code": "def has_level_handler(logger: logging.Logger) -> bool:\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent  # type: ignore\n\n    return False",
    "start_line": 31,
    "end_line": 47,
    "has_docstring": true,
    "docstring": "Check if there is a handler in the logging chain that will handle the\ngiven logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.",
    "parameters": [
      "logger"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function has_level_handler",
    "component_id": "src.flask.logging.has_level_handler"
  },
  "src.flask.logging.create_logger": {
    "id": "src.flask.logging.create_logger",
    "name": "create_logger",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/logging.py",
    "relative_path": "src/flask/logging.py",
    "depends_on": [
      "src.flask.logging.has_level_handler"
    ],
    "source_code": "def create_logger(app: App) -> logging.Logger:\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger",
    "start_line": 58,
    "end_line": 79,
    "has_docstring": true,
    "docstring": "Get the Flask app's logger and configure it if needed.\n\nThe logger name will be the same as\n:attr:`app.import_name <flask.Flask.name>`.\n\nWhen :attr:`~flask.Flask.debug` is enabled, set the logger level to\n:data:`logging.DEBUG` if it is not set.\n\nIf there is no handler for the logger's effective level, add a\n:class:`~logging.StreamHandler` for\n:func:`~flask.logging.wsgi_errors_stream` with a basic format.",
    "parameters": [
      "app"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_logger",
    "component_id": "src.flask.logging.create_logger"
  },
  "src.flask.sansio.app._make_timedelta": {
    "id": "src.flask.sansio.app._make_timedelta",
    "name": "_make_timedelta",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/app.py",
    "relative_path": "src/flask/sansio/app.py",
    "depends_on": [],
    "source_code": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
    "start_line": 52,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _make_timedelta",
    "component_id": "src.flask.sansio.app._make_timedelta"
  },
  "src.flask.sansio.app.App": {
    "id": "src.flask.sansio.app.App",
    "name": "App",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/app.py",
    "relative_path": "src/flask/sansio/app.py",
    "depends_on": [
      "src.flask.helpers._split_blueprint_path",
      "src.flask.sansio.scaffold.find_package",
      "src.flask.logging.create_logger",
      "src.flask.templating.DispatchingJinjaLoader",
      "src.flask.sansio.scaffold._endpoint_from_view_func",
      "src.flask.helpers.get_debug_flag"
    ],
    "source_code": "class App(Scaffold):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: The folder with static files that is served at\n        ``static_url_path``. Relative to the application ``root_path``\n        or an absolute path. Defaults to ``'static'``.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: The path to the root of the application files.\n        This should only be set manually when it can't be detected\n        automatically, such as for namespace packages.\n    \"\"\"\n\n    #: The class of the object assigned to :attr:`aborter`, created by\n    #: :meth:`create_aborter`. That object is called by\n    #: :func:`flask.abort` to raise HTTP errors, and can be\n    #: called directly as well.\n    #:\n    #: Defaults to :class:`werkzeug.exceptions.Aborter`.\n    #:\n    #: .. versionadded:: 2.2\n    aborter_class = Aborter\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: .. versionadded:: 0.10\n    #:     Renamed from ``request_globals_class`.\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute[bool](\"TESTING\")\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute[str | bytes | None](\"SECRET_KEY\")\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute[timedelta](\n        \"PERMANENT_SESSION_LIFETIME\",\n        get_converter=_make_timedelta,  # type: ignore[arg-type]\n    )\n\n    json_provider_class: type[JSONProvider] = DefaultJSONProvider\n    \"\"\"A subclass of :class:`~flask.json.provider.JSONProvider`. An\n    instance is created and assigned to :attr:`app.json` when creating\n    the app.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses\n    Python's built-in :mod:`json` library. A different provider can use\n    a different JSON library.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    #: Options that are passed to the Jinja environment in\n    #: :meth:`create_jinja_environment`. Changing these options after\n    #: the environment is created (accessing :attr:`jinja_env`) will\n    #: have no effect.\n    #:\n    #: .. versionchanged:: 1.1.0\n    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow\n    #:     easier configuration.\n    #:\n    jinja_options: dict[str, t.Any] = {}\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: The map object to use for storing the URL rules and routing\n    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.\n    #:\n    #: .. versionadded:: 1.1.0\n    url_map_class = Map\n\n    #: The :meth:`test_client` method creates an instance of this test\n    #: client class. Defaults to :class:`~flask.testing.FlaskClient`.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class: type[FlaskClient] | None = None\n\n    #: The :class:`~click.testing.CliRunner` subclass, by default\n    #: :class:`~flask.testing.FlaskCliRunner` that is used by\n    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a\n    #: Flask app object as the first argument.\n    #:\n    #: .. versionadded:: 1.0\n    test_cli_runner_class: type[FlaskCliRunner] | None = None\n\n    default_config: dict[str, t.Any]\n    response_class: type[Response]\n\n    def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ) -> None:\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n\n    @cached_property\n    def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn: str | None = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @cached_property\n    def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`name` rather than\n            hard-coding ``\"flask.app\"``.\n\n        .. versionchanged:: 1.0.0\n            Behavior was simplified. The logger is always named\n            ``\"flask.app\"``. The level is only set during configuration,\n            it doesn't check ``app.debug`` each time. Only one format is\n            used, not different ones depending on ``app.debug``. No\n            handlers are removed, and a handler is only added if no\n            handlers are already configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n\n    @cached_property\n    def jinja_env(self) -> Environment:\n        \"\"\"The Jinja environment used to load templates.\n\n        The environment is created the first time this property is\n        accessed. Changing :attr:`jinja_options` after that will have no\n        effect.\n        \"\"\"\n        return self.create_jinja_environment()\n\n    def create_jinja_environment(self) -> Environment:\n        raise NotImplementedError()\n\n    def make_config(self, instance_relative: bool = False) -> Config:\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n\n    def make_aborter(self) -> Aborter:\n        \"\"\"Create the object to assign to :attr:`aborter`. That object\n        is called by :func:`flask.abort` to raise HTTP errors, and can\n        be called directly as well.\n\n        By default, this creates an instance of :attr:`aborter_class`,\n        which defaults to :class:`werkzeug.exceptions.Aborter`.\n\n        .. versionadded:: 2.2\n        \"\"\"\n        return self.aborter_class()\n\n    def auto_find_instance_path(self) -> str:\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n\n    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n        \"\"\"Creates the loader for the Jinja environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename: str) -> bool:\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionchanged:: 2.2\n            Autoescaping is now enabled by default for ``.svg`` files.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))\n\n    @property\n    def debug(self) -> bool:\n        \"\"\"Whether debug mode is enabled. When using ``flask run`` to start the\n        development server, an interactive debugger will be shown for unhandled\n        exceptions, and the server will be reloaded when code changes. This maps to the\n        :data:`DEBUG` config key. It may not behave as expected if set late.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``False``\n        \"\"\"\n        return self.config[\"DEBUG\"]  # type: ignore[no-any-return]\n\n    @debug.setter\n    def debug(self, value: bool) -> None:\n        self.config[\"DEBUG\"] = value\n\n        if self.config[\"TEMPLATES_AUTO_RELOAD\"] is None:\n            self.jinja_env.auto_reload = value\n\n    @setupmethod\n    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        blueprint.register(self, options)\n\n    def iter_blueprints(self) -> t.ValuesView[Blueprint]:\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.blueprints.values()\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods and self.config[\"PROVIDE_AUTOMATIC_OPTIONS\"]:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule_obj = self.url_rule_class(rule, methods=methods, **options)\n        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]\n\n        self.url_map.add(rule_obj)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n\n    @t.overload\n    def template_filter(self, name: T_template_filter) -> T_template_filter: ...\n    @t.overload\n    def template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]: ...\n    @setupmethod\n    def template_filter(\n        self, name: T_template_filter | str | None = None\n    ) -> T_template_filter | t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Decorate a function to register it as a custom Jinja filter. The name\n        is optional. The decorator may be used without parentheses.\n\n        .. code-block:: python\n\n            @app.template_filter(\"reverse\")\n            def reverse_filter(s):\n                return reversed(s)\n\n        The :meth:`add_template_filter` method may be used to register a\n        function later rather than decorating.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n        if callable(name):\n            self.add_template_filter(name)\n            return name\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja filter.\n\n        The :meth:`template_filter` decorator can be used to register a function\n        by decorating instead.\n\n        :param f: The function to register.\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @t.overload\n    def template_test(self, name: T_template_test) -> T_template_test: ...\n    @t.overload\n    def template_test(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_test], T_template_test]: ...\n    @setupmethod\n    def template_test(\n        self, name: T_template_test | str | None = None\n    ) -> T_template_test | t.Callable[[T_template_test], T_template_test]:\n        \"\"\"Decorate a function to register it as a custom Jinja test. The name\n        is optional. The decorator may be used without parentheses.\n\n        .. code-block:: python\n\n            @app.template_test(\"prime\")\n            def is_prime_test(n):\n                if n == 2:\n                    return True\n                for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                    if n % i == 0:\n                        return False\n              return True\n\n        The :meth:`add_template_test` method may be used to register a function\n        later rather than decorating.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_template_test(name)\n            return name\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_test(\n        self, f: ft.TemplateTestCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja test.\n\n        The :meth:`template_test` decorator can be used to register a function\n        by decorating instead.\n\n        :param f: The function to register.\n        :param name: The name to register the test as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @t.overload\n    def template_global(self, name: T_template_global) -> T_template_global: ...\n    @t.overload\n    def template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]: ...\n    @setupmethod\n    def template_global(\n        self, name: T_template_global | str | None = None\n    ) -> T_template_global | t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Decorate a function to register it as a custom Jinja global. The name\n        is optional. The decorator may be used without parentheses.\n\n        .. code-block:: python\n\n            @app.template_global\n            def double(n):\n                return 2 * n\n\n        The :meth:`add_template_global` method may be used to register a\n        function later rather than decorating.\n\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_template_global(name)\n            return name\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja global.\n\n        The :meth:`template_global` decorator can be used to register a function\n        by decorating instead.\n\n        :param f: The function to register.\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def teardown_appcontext(self, f: T_teardown) -> T_teardown:\n        \"\"\"Registers a function to be called when the app context is popped. The\n        context is popped at the end of a request, CLI command, or manual ``with``\n        block.\n\n        .. code-block:: python\n\n            with app.app_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the app context is\n        made inactive.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(\n        self, f: T_shell_context_processor\n    ) -> T_shell_context_processor:\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    def _find_error_handler(\n        self, e: Exception, blueprints: list[str]\n    ) -> ft.ErrorHandlerCallable | None:\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        names = (*blueprints, None)\n\n        for c in (code, None) if code is not None else (None,):\n            for name in names:\n                handler_map = self.error_handler_spec[name][c]\n\n                if not handler_map:\n                    continue\n\n                for cls in exc_class.__mro__:\n                    handler = handler_map.get(cls)\n\n                    if handler is not None:\n                        return handler\n        return None\n\n    def trap_http_exception(self, e: Exception) -> bool:\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def should_ignore_error(self, error: BaseException | None) -> bool:\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def redirect(self, location: str, code: int = 302) -> BaseResponse:\n        \"\"\"Create a redirect response object.\n\n        This is called by :func:`flask.redirect`, and can be called\n        directly as well.\n\n        :param location: The URL to redirect to.\n        :param code: The status code for the redirect.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.redirect``, which calls this method.\n        \"\"\"\n        return _wz_redirect(\n            location,\n            code=code,\n            Response=self.response_class,  # type: ignore[arg-type]\n        )\n\n    def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -> None:\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        names: t.Iterable[str | None] = (None,)\n\n        # url_for may be called outside a request context, parse the\n        # passed endpoint instead of using request.blueprints.\n        if \".\" in endpoint:\n            names = chain(\n                names, reversed(_split_blueprint_path(endpoint.rpartition(\".\")[0]))\n            )\n\n        for name in names:\n            if name in self.url_default_functions:\n                for func in self.url_default_functions[name]:\n                    func(endpoint, values)\n\n    def handle_url_build_error(\n        self, error: BuildError, endpoint: str, values: dict[str, t.Any]\n    ) -> str:\n        \"\"\"Called by :meth:`.url_for` if a\n        :exc:`~werkzeug.routing.BuildError` was raised. If this returns\n        a value, it will be returned by ``url_for``, otherwise the error\n        will be re-raised.\n\n        Each function in :attr:`url_build_error_handlers` is called with\n        ``error``, ``endpoint`` and ``values``. If a function returns\n        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,\n        its return value is returned by ``url_for``.\n\n        :param error: The active ``BuildError`` being handled.\n        :param endpoint: The endpoint being built.\n        :param values: The keyword arguments passed to ``url_for``.\n        \"\"\"\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error",
    "start_line": 59,
    "end_line": 1006,
    "has_docstring": true,
    "docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the\npackage or the folder the module is contained in depending on if the\npackage parameter resolves to an actual python package (a folder with\nan :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\nFor more information about resource loading, see :func:`open_resource`.\n\nUsually you create a :class:`Flask` instance in your main module or\nin the :file:`__init__.py` file of your package like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n.. admonition:: About the First Parameter\n\n    The idea of the first parameter is to give Flask an idea of what\n    belongs to your application.  This name is used to find resources\n    on the filesystem, can be used by extensions to improve debugging\n    information and a lot more.\n\n    So it's important what you provide there.  If you are using a single\n    module, `__name__` is always the correct value.  If you however are\n    using a package, it's usually recommended to hardcode the name of\n    your package there.\n\n    For example if your application is defined in :file:`yourapplication/app.py`\n    you should create it with one of the two versions below::\n\n        app = Flask('yourapplication')\n        app = Flask(__name__.split('.')[0])\n\n    Why is that?  The application will work even with `__name__`, thanks\n    to how resources are looked up.  However it will make debugging more\n    painful.  Certain extensions can make assumptions based on the\n    import name of your application.  For example the Flask-SQLAlchemy\n    extension will look for the code in your application that triggered\n    an SQL query in debug mode.  If the import name is not properly set\n    up, that debugging information is lost.  (For example it would only\n    pick up SQL queries in `yourapplication.app` and not\n    `yourapplication.views.frontend`)\n\n.. versionadded:: 0.7\n   The `static_url_path`, `static_folder`, and `template_folder`\n   parameters were added.\n\n.. versionadded:: 0.8\n   The `instance_path` and `instance_relative_config` parameters were\n   added.\n\n.. versionadded:: 0.11\n   The `root_path` parameter was added.\n\n.. versionadded:: 1.0\n   The ``host_matching`` and ``static_host`` parameters were added.\n\n.. versionadded:: 1.0\n   The ``subdomain_matching`` parameter was added. Subdomain\n   matching needs to be enabled manually now. Setting\n   :data:`SERVER_NAME` does not implicitly enable it.\n\n:param import_name: the name of the application package\n:param static_url_path: can be used to specify a different path for the\n                        static files on the web.  Defaults to the name\n                        of the `static_folder` folder.\n:param static_folder: The folder with static files that is served at\n    ``static_url_path``. Relative to the application ``root_path``\n    or an absolute path. Defaults to ``'static'``.\n:param static_host: the host to use when adding the static route.\n    Defaults to None. Required when using ``host_matching=True``\n    with a ``static_folder`` configured.\n:param host_matching: set ``url_map.host_matching`` attribute.\n    Defaults to False.\n:param subdomain_matching: consider the subdomain relative to\n    :data:`SERVER_NAME` when matching routes. Defaults to False.\n:param template_folder: the folder that contains the templates that should\n                        be used by the application.  Defaults to\n                        ``'templates'`` folder in the root path of the\n                        application.\n:param instance_path: An alternative instance path for the application.\n                      By default the folder ``'instance'`` next to the\n                      package or module is assumed to be the instance\n                      path.\n:param instance_relative_config: if set to ``True`` relative filenames\n                                 for loading the config are assumed to\n                                 be relative to the instance path instead\n                                 of the application root.\n:param root_path: The path to the root of the application files.\n    This should only be set manually when it can't be detected\n    automatically, such as for namespace packages.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Scaffold"
    ],
    "class_name": null,
    "display_name": "class App",
    "component_id": "src.flask.sansio.app.App"
  },
  "src.flask.sansio.blueprints.BlueprintSetupState": {
    "id": "src.flask.sansio.blueprints.BlueprintSetupState",
    "name": "BlueprintSetupState",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/blueprints.py",
    "relative_path": "src/flask/sansio/blueprints.py",
    "depends_on": [
      "src.flask.sansio.scaffold._endpoint_from_view_func"
    ],
    "source_code": "class BlueprintSetupState:\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )",
    "start_line": 34,
    "end_line": 116,
    "has_docstring": true,
    "docstring": "Temporary holder object for registering a blueprint with the\napplication.  An instance of this class is created by the\n:meth:`~flask.Blueprint.make_setup_state` method and later passed\nto all register callback functions.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class BlueprintSetupState",
    "component_id": "src.flask.sansio.blueprints.BlueprintSetupState"
  },
  "src.flask.sansio.blueprints.Blueprint": {
    "id": "src.flask.sansio.blueprints.Blueprint",
    "name": "Blueprint",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/blueprints.py",
    "relative_path": "src/flask/sansio/blueprints.py",
    "depends_on": [
      "src.flask.sansio.blueprints.BlueprintSetupState"
    ],
    "source_code": "class Blueprint(Scaffold):\n    \"\"\"Represents a blueprint, a collection of routes and other\n    app-related functions that can be registered on a real application\n    later.\n\n    A blueprint is an object that allows defining application functions\n    without requiring an application object ahead of time. It uses the\n    same decorators as :class:`~flask.Flask`, but defers the need for an\n    application by recording them for later registration.\n\n    Decorating a function with a blueprint creates a deferred function\n    that is called with :class:`~flask.blueprints.BlueprintSetupState`\n    when the blueprint is registered on an application.\n\n    See :doc:`/blueprints` for more information.\n\n    :param name: The name of the blueprint. Will be prepended to each\n        endpoint name.\n    :param import_name: The name of the blueprint package, usually\n        ``__name__``. This helps locate the ``root_path`` for the\n        blueprint.\n    :param static_folder: A folder with static files that should be\n        served by the blueprint's static route. The path is relative to\n        the blueprint's root path. Blueprint static files are disabled\n        by default.\n    :param static_url_path: The url to serve static files from.\n        Defaults to ``static_folder``. If the blueprint does not have\n        a ``url_prefix``, the app's static route will take precedence,\n        and the blueprint's static files won't be accessible.\n    :param template_folder: A folder with templates that should be added\n        to the app's template search path. The path is relative to the\n        blueprint's root path. Blueprint templates are disabled by\n        default. Blueprint templates have a lower precedence than those\n        in the app's templates folder.\n    :param url_prefix: A path to prepend to all of the blueprint's URLs,\n        to make them distinct from the rest of the app's routes.\n    :param subdomain: A subdomain that blueprint routes will match on by\n        default.\n    :param url_defaults: A dict of default values that blueprint routes\n        will receive by default.\n    :param root_path: By default, the blueprint will automatically set\n        this based on ``import_name``. In certain situations this\n        automatic detection can fail, so the path can be specified\n        manually instead.\n\n    .. versionchanged:: 1.1.0\n        Blueprints have a ``cli`` group to register nested CLI commands.\n        The ``cli_group`` parameter controls the name of the group under\n        the ``flask`` command.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    _got_registered_once = False\n\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n\n    @setupmethod\n    def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)\n\n    @setupmethod\n    def record_once(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n\n        def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)\n\n        self.record(update_wrapper(wrapper, func))\n\n    def make_setup_state(\n        self, app: App, options: dict[str, t.Any], first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n\n    @setupmethod\n    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n        arguments passed to this method will override the defaults set\n        on the blueprint.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if blueprint is self:\n            raise ValueError(\"Cannot register a blueprint on itself\")\n        self._blueprints.append((blueprint, options))\n\n    def register(self, app: App, options: dict[str, t.Any]) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n            existing_at = f\" '{name}'\" if self_name != name else \"\"\n\n            raise ValueError(\n                f\"The name '{self_name}' is already registered for\"\n                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n                f\" provide a unique name.\"\n            )\n\n        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n        first_name_registration = name not in app.blueprints\n\n        app.blueprints[name] = self\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_bp_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,  # type: ignore[attr-defined]\n                endpoint=\"static\",\n            )\n\n        # Merge blueprint data into parent.\n        if first_bp_registration or first_name_registration:\n            self._merge_blueprint_funcs(app, name)\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if self.cli.commands:\n            if cli_resolved_group is None:\n                app.cli.commands.update(self.cli.commands)\n            elif cli_resolved_group is _sentinel:\n                self.cli.name = name\n                app.cli.add_command(self.cli)\n            else:\n                self.cli.name = cli_resolved_group\n                app.cli.add_command(self.cli)\n\n        for blueprint, bp_options in self._blueprints:\n            bp_options = bp_options.copy()\n            bp_url_prefix = bp_options.get(\"url_prefix\")\n            bp_subdomain = bp_options.get(\"subdomain\")\n\n            if bp_subdomain is None:\n                bp_subdomain = blueprint.subdomain\n\n            if state.subdomain is not None and bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n            elif bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain\n            elif state.subdomain is not None:\n                bp_options[\"subdomain\"] = state.subdomain\n\n            if bp_url_prefix is None:\n                bp_url_prefix = blueprint.url_prefix\n\n            if state.url_prefix is not None and bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = (\n                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                )\n            elif bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = bp_url_prefix\n            elif state.url_prefix is not None:\n                bp_options[\"url_prefix\"] = state.url_prefix\n\n            bp_options[\"name_prefix\"] = name\n            blueprint.register(app, bp_options)\n\n    def _merge_blueprint_funcs(self, app: App, name: str) -> None:\n        def extend(\n            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n        ) -> None:\n            for key, values in bp_dict.items():\n                key = name if key is None else f\"{name}.{key}\"\n                parent_dict[key].extend(values)\n\n        for key, value in self.error_handler_spec.items():\n            key = name if key is None else f\"{name}.{key}\"\n            value = defaultdict(\n                dict,\n                {\n                    code: {exc_class: func for exc_class, func in code_values.items()}\n                    for code, code_values in value.items()\n                },\n            )\n            app.error_handler_spec[key] = value\n\n        for endpoint, func in self.view_functions.items():\n            app.view_functions[endpoint] = func\n\n        extend(self.before_request_funcs, app.before_request_funcs)\n        extend(self.after_request_funcs, app.after_request_funcs)\n        extend(\n            self.teardown_request_funcs,\n            app.teardown_request_funcs,\n        )\n        extend(self.url_default_functions, app.url_default_functions)\n        extend(self.url_value_preprocessors, app.url_value_preprocessors)\n        extend(self.template_context_processors, app.template_context_processors)\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n        full documentation.\n\n        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n        used with :func:`url_for`, is prefixed with the blueprint's name.\n        \"\"\"\n        if endpoint and \".\" in endpoint:\n            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n\n        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n\n        self.record(\n            lambda s: s.add_url_rule(\n                rule,\n                endpoint,\n                view_func,\n                provide_automatic_options=provide_automatic_options,\n                **options,\n            )\n        )\n\n    @t.overload\n    def app_template_filter(self, name: T_template_filter) -> T_template_filter: ...\n    @t.overload\n    def app_template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]: ...\n    @setupmethod\n    def app_template_filter(\n        self, name: T_template_filter | str | None = None\n    ) -> T_template_filter | t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Decorate a function to register it as a custom Jinja filter. The name\n        is optional. The decorator may be used without parentheses.\n\n        The :meth:`add_app_template_filter` method may be used to register a\n        function later rather than decorating.\n\n        The filter is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.template_filter`.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n        if callable(name):\n            self.add_app_template_filter(name)\n            return name\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_app_template_filter(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_app_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja filter.\n\n        The :meth:`app_template_filter` decorator can be used to register a\n        function by decorating instead.\n\n        The filter is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.add_template_filter`.\n\n        :param f: The function to register.\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n\n        def register_template_filter(state: BlueprintSetupState) -> None:\n            state.app.add_template_filter(f, name=name)\n\n        self.record_once(register_template_filter)\n\n    @t.overload\n    def app_template_test(self, name: T_template_test) -> T_template_test: ...\n    @t.overload\n    def app_template_test(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_test], T_template_test]: ...\n    @setupmethod\n    def app_template_test(\n        self, name: T_template_test | str | None = None\n    ) -> T_template_test | t.Callable[[T_template_test], T_template_test]:\n        \"\"\"Decorate a function to register it as a custom Jinja test. The name\n        is optional. The decorator may be used without parentheses.\n\n        The :meth:`add_app_template_test` method may be used to register a\n        function later rather than decorating.\n\n        The test is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.template_test`.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_app_template_test(name)\n            return name\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_app_template_test(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_app_template_test(\n        self, f: ft.TemplateTestCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja test.\n\n        The :meth:`app_template_test` decorator can be used to register a\n        function by decorating instead.\n\n        The test is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.add_template_test`.\n\n        :param f: The function to register.\n        :param name: The name to register the test as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n\n        def register_template_test(state: BlueprintSetupState) -> None:\n            state.app.add_template_test(f, name=name)\n\n        self.record_once(register_template_test)\n\n    @t.overload\n    def app_template_global(self, name: T_template_global) -> T_template_global: ...\n    @t.overload\n    def app_template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]: ...\n    @setupmethod\n    def app_template_global(\n        self, name: T_template_global | str | None = None\n    ) -> T_template_global | t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Decorate a function to register it as a custom Jinja global. The name\n        is optional. The decorator may be used without parentheses.\n\n        The :meth:`add_app_template_global` method may be used to register a\n        function later rather than decorating.\n\n        The global is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.template_global`.\n\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_app_template_global(name)\n            return name\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_app_template_global(f, name=name)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_app_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja global.\n\n        The :meth:`app_template_global` decorator can be used to register a function\n        by decorating instead.\n\n        The global is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.add_template_global`.\n\n        :param f: The function to register.\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n\n        def register_template_global(state: BlueprintSetupState) -> None:\n            state.app.add_template_global(f, name=name)\n\n        self.record_once(register_template_global)\n\n    @setupmethod\n    def before_app_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Like :meth:`before_request`, but before every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.before_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)\n        )\n        return f\n\n    @setupmethod\n    def after_app_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Like :meth:`after_request`, but after every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.after_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)\n        )\n        return f\n\n    @setupmethod\n    def teardown_app_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Like :meth:`teardown_request`, but after every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)\n        )\n        return f\n\n    @setupmethod\n    def app_context_processor(\n        self, f: T_template_context_processor\n    ) -> T_template_context_processor:\n        \"\"\"Like :meth:`context_processor`, but for templates rendered by every view, not\n        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)\n        )\n        return f\n\n    @setupmethod\n    def app_errorhandler(\n        self, code: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Like :meth:`errorhandler`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)\n\n            self.record_once(from_blueprint)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def app_url_value_preprocessor(\n        self, f: T_url_value_preprocessor\n    ) -> T_url_value_preprocessor:\n        \"\"\"Like :meth:`url_value_preprocessor`, but for every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n        )\n        return f\n\n    @setupmethod\n    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Like :meth:`url_defaults`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n        )\n        return f",
    "start_line": 119,
    "end_line": 692,
    "has_docstring": true,
    "docstring": "Represents a blueprint, a collection of routes and other\napp-related functions that can be registered on a real application\nlater.\n\nA blueprint is an object that allows defining application functions\nwithout requiring an application object ahead of time. It uses the\nsame decorators as :class:`~flask.Flask`, but defers the need for an\napplication by recording them for later registration.\n\nDecorating a function with a blueprint creates a deferred function\nthat is called with :class:`~flask.blueprints.BlueprintSetupState`\nwhen the blueprint is registered on an application.\n\nSee :doc:`/blueprints` for more information.\n\n:param name: The name of the blueprint. Will be prepended to each\n    endpoint name.\n:param import_name: The name of the blueprint package, usually\n    ``__name__``. This helps locate the ``root_path`` for the\n    blueprint.\n:param static_folder: A folder with static files that should be\n    served by the blueprint's static route. The path is relative to\n    the blueprint's root path. Blueprint static files are disabled\n    by default.\n:param static_url_path: The url to serve static files from.\n    Defaults to ``static_folder``. If the blueprint does not have\n    a ``url_prefix``, the app's static route will take precedence,\n    and the blueprint's static files won't be accessible.\n:param template_folder: A folder with templates that should be added\n    to the app's template search path. The path is relative to the\n    blueprint's root path. Blueprint templates are disabled by\n    default. Blueprint templates have a lower precedence than those\n    in the app's templates folder.\n:param url_prefix: A path to prepend to all of the blueprint's URLs,\n    to make them distinct from the rest of the app's routes.\n:param subdomain: A subdomain that blueprint routes will match on by\n    default.\n:param url_defaults: A dict of default values that blueprint routes\n    will receive by default.\n:param root_path: By default, the blueprint will automatically set\n    this based on ``import_name``. In certain situations this\n    automatic detection can fail, so the path can be specified\n    manually instead.\n\n.. versionchanged:: 1.1.0\n    Blueprints have a ``cli`` group to register nested CLI commands.\n    The ``cli_group`` parameter controls the name of the group under\n    the ``flask`` command.\n\n.. versionadded:: 0.7",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Scaffold"
    ],
    "class_name": null,
    "display_name": "class Blueprint",
    "component_id": "src.flask.sansio.blueprints.Blueprint"
  },
  "src.flask.sansio.scaffold.setupmethod": {
    "id": "src.flask.sansio.scaffold.setupmethod",
    "name": "setupmethod",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/scaffold.py",
    "relative_path": "src/flask/sansio/scaffold.py",
    "depends_on": [],
    "source_code": "def setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))",
    "start_line": 42,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "f"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setupmethod",
    "component_id": "src.flask.sansio.scaffold.setupmethod"
  },
  "src.flask.sansio.scaffold.wrapper_func": {
    "id": "src.flask.sansio.scaffold.wrapper_func",
    "name": "wrapper_func",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/scaffold.py",
    "relative_path": "src/flask/sansio/scaffold.py",
    "depends_on": [],
    "source_code": "    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)",
    "start_line": 45,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function wrapper_func",
    "component_id": "src.flask.sansio.scaffold.wrapper_func"
  },
  "src.flask.sansio.scaffold.Scaffold": {
    "id": "src.flask.sansio.scaffold.Scaffold",
    "name": "Scaffold",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/scaffold.py",
    "relative_path": "src/flask/sansio/scaffold.py",
    "depends_on": [
      "src.flask.helpers.get_root_path"
    ],
    "source_code": "class Scaffold:\n    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n    :class:`~flask.blueprints.Blueprint`.\n\n    :param import_name: The import name of the module where this object\n        is defined. Usually :attr:`__name__` should be used.\n    :param static_folder: Path to a folder of static files to serve.\n        If this is set, a static route will be added.\n    :param static_url_path: URL prefix for the static route.\n    :param template_folder: Path to a folder containing template files.\n        for rendering. If this is set, a Jinja loader will be added.\n    :param root_path: The path that static, template, and resource files\n        are relative to. Typically not set, it is discovered based on\n        the ``import_name``.\n\n    .. versionadded:: 2.0\n    \"\"\"\n\n    cli: Group\n    name: str\n    _static_folder: str | None = None\n    _static_url_path: str | None = None\n\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: dict[str, ft.RouteCallable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n        #: the name of a blueprint the handlers are active for, or\n        #: ``None`` for all requests. The ``code`` key is the HTTP\n        #: status code for ``HTTPException``, or ``None`` for\n        #: other exceptions. The innermost dictionary maps exception\n        #: classes to handler functions.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.error_handler_spec: dict[\n            ft.AppOrBlueprintKey,\n            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],\n        ] = defaultdict(lambda: defaultdict(dict))\n\n        #: A data structure of functions to call at the beginning of\n        #: each request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`before_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.before_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`after_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.after_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request even if an exception is raised, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`teardown_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.teardown_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.TeardownCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to pass extra context\n        #: values when rendering templates, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`context_processor`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.template_context_processors: dict[\n            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]\n        ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments passed to the view function, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the\n        #: :meth:`url_value_preprocessor` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_value_preprocessors: dict[\n            ft.AppOrBlueprintKey,\n            list[ft.URLValuePreprocessorCallable],\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments when generating URLs, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`url_defaults`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_default_functions: dict[\n            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]\n        ] = defaultdict(list)\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.name!r}>\"\n\n    def _check_setup_finished(self, f_name: str) -> None:\n        raise NotImplementedError\n\n    @property\n    def static_folder(self) -> str | None:\n        \"\"\"The absolute path to the configured static folder. ``None``\n        if no static folder is set.\n        \"\"\"\n        if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)\n        else:\n            return None\n\n    @static_folder.setter\n    def static_folder(self, value: str | os.PathLike[str] | None) -> None:\n        if value is not None:\n            value = os.fspath(value).rstrip(r\"\\/\")\n\n        self._static_folder = value\n\n    @property\n    def has_static_folder(self) -> bool:\n        \"\"\"``True`` if :attr:`static_folder` is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        return self.static_folder is not None\n\n    @property\n    def static_url_path(self) -> str | None:\n        \"\"\"The URL prefix that the static route will be accessible from.\n\n        If it was not configured during init, it is derived from\n        :attr:`static_folder`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n\n    @static_url_path.setter\n    def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n\n    @cached_property\n    def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n\n    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n\n    @setupmethod\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n\n    @setupmethod\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n\n    @setupmethod\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n\n    @setupmethod\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n\n    @setupmethod\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n\n    @setupmethod\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n\n    @setupmethod\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n\n    @setupmethod\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run after each request to this object.\n\n        The function is called with the response object, and must return\n        a response object. This allows the functions to modify or\n        replace the response before it is sent.\n\n        If a function raises an exception, any remaining\n        ``after_request`` functions will not be called. Therefore, this\n        should not be used for actions that must execute, such as to\n        close resources. Use :meth:`teardown_request` for that.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.after_app_request`.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Register a function to be called when the request context is\n        popped. Typically, this happens at the end of each request, but\n        contexts may be pushed manually during testing.\n\n        .. code-block:: python\n\n            with app.test_request_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the request context is\n        made inactive.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.teardown_app_request`.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def context_processor(\n        self,\n        f: T_template_context_processor,\n    ) -> T_template_context_processor:\n        \"\"\"Registers a template context processor function. These functions run before\n        rendering a template. The keys of the returned dict are added as variables\n        available in the template.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every rendered template. When used on a blueprint, this is called\n        for templates rendered from the blueprint's views. To register with a blueprint\n        and affect every template, use :meth:`.Blueprint.app_context_processor`.\n        \"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(\n        self,\n        f: T_url_value_preprocessor,\n    ) -> T_url_value_preprocessor:\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.\n        \"\"\"\n        self.url_value_preprocessors[None].append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_defaults`.\n        \"\"\"\n        self.url_default_functions[None].append(f)\n        return f\n\n    @setupmethod\n    def errorhandler(\n        self, code_or_exception: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        This is available on both app and blueprint objects. When used on an app, this\n        can handle errors from every request. When used on a blueprint, this can handle\n        errors from requests that the blueprint handles. To register with a blueprint\n        and affect every request, use :meth:`.Blueprint.app_errorhandler`.\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            self.register_error_handler(code_or_exception, f)\n            return f\n\n        return decorator\n\n    @setupmethod\n    def register_error_handler(\n        self,\n        code_or_exception: type[Exception] | int,\n        f: ft.ErrorHandlerCallable,\n    ) -> None:\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        self.error_handler_spec[None][code][exc_class] = f\n\n    @staticmethod\n    def _get_exc_class_and_code(\n        exc_class_or_code: type[Exception] | int,\n    ) -> tuple[type[Exception], int | None]:\n        \"\"\"Get the exception class being handled. For HTTP status codes\n        or ``HTTPException`` subclasses, return both the exception and\n        status code.\n\n        :param exc_class_or_code: Any exception class, or an HTTP status\n            code as an integer.\n        \"\"\"\n        exc_class: type[Exception]\n\n        if isinstance(exc_class_or_code, int):\n            try:\n                exc_class = default_exceptions[exc_class_or_code]\n            except KeyError:\n                raise ValueError(\n                    f\"'{exc_class_or_code}' is not a recognized HTTP\"\n                    \" error code. Use a subclass of HTTPException with\"\n                    \" that code instead.\"\n                ) from None\n        else:\n            exc_class = exc_class_or_code\n\n        if isinstance(exc_class, Exception):\n            raise TypeError(\n                f\"{exc_class!r} is an instance, not a class. Handlers\"\n                \" can only be registered for Exception classes or HTTP\"\n                \" error codes.\"\n            )\n\n        if not issubclass(exc_class, Exception):\n            raise ValueError(\n                f\"'{exc_class.__name__}' is not a subclass of Exception.\"\n                \" Handlers can only be registered for Exception classes\"\n                \" or HTTP error codes.\"\n            )\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None",
    "start_line": 52,
    "end_line": 698,
    "has_docstring": true,
    "docstring": "Common behavior shared between :class:`~flask.Flask` and\n:class:`~flask.blueprints.Blueprint`.\n\n:param import_name: The import name of the module where this object\n    is defined. Usually :attr:`__name__` should be used.\n:param static_folder: Path to a folder of static files to serve.\n    If this is set, a static route will be added.\n:param static_url_path: URL prefix for the static route.\n:param template_folder: Path to a folder containing template files.\n    for rendering. If this is set, a Jinja loader will be added.\n:param root_path: The path that static, template, and resource files\n    are relative to. Typically not set, it is discovered based on\n    the ``import_name``.\n\n.. versionadded:: 2.0",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class Scaffold",
    "component_id": "src.flask.sansio.scaffold.Scaffold"
  },
  "src.flask.sansio.scaffold._endpoint_from_view_func": {
    "id": "src.flask.sansio.scaffold._endpoint_from_view_func",
    "name": "_endpoint_from_view_func",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/scaffold.py",
    "relative_path": "src/flask/sansio/scaffold.py",
    "depends_on": [],
    "source_code": "def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:\n    \"\"\"Internal helper that returns the default endpoint for a given\n    function.  This always is the function name.\n    \"\"\"\n    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n    return view_func.__name__",
    "start_line": 701,
    "end_line": 706,
    "has_docstring": true,
    "docstring": "Internal helper that returns the default endpoint for a given\nfunction.  This always is the function name.",
    "parameters": [
      "view_func"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _endpoint_from_view_func",
    "component_id": "src.flask.sansio.scaffold._endpoint_from_view_func"
  },
  "src.flask.sansio.scaffold._find_package_path": {
    "id": "src.flask.sansio.scaffold._find_package_path",
    "name": "_find_package_path",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/scaffold.py",
    "relative_path": "src/flask/sansio/scaffold.py",
    "depends_on": [],
    "source_code": "def _find_package_path(import_name: str) -> str:\n    \"\"\"Find the path that contains the package or module.\"\"\"\n    root_mod_name, _, _ = import_name.partition(\".\")\n\n    try:\n        root_spec = importlib.util.find_spec(root_mod_name)\n\n        if root_spec is None:\n            raise ValueError(\"not found\")\n    except (ImportError, ValueError):\n        # ImportError: the machinery told us it does not exist\n        # ValueError:\n        #    - the module name was invalid\n        #    - the module name is __main__\n        #    - we raised `ValueError` due to `root_spec` being `None`\n        return os.getcwd()\n\n    if root_spec.submodule_search_locations:\n        if root_spec.origin is None or root_spec.origin == \"namespace\":\n            # namespace package\n            package_spec = importlib.util.find_spec(import_name)\n\n            if package_spec is not None and package_spec.submodule_search_locations:\n                # Pick the path in the namespace that contains the submodule.\n                package_path = pathlib.Path(\n                    os.path.commonpath(package_spec.submodule_search_locations)\n                )\n                search_location = next(\n                    location\n                    for location in root_spec.submodule_search_locations\n                    if package_path.is_relative_to(location)\n                )\n            else:\n                # Pick the first path.\n                search_location = root_spec.submodule_search_locations[0]\n\n            return os.path.dirname(search_location)\n        else:\n            # package with __init__.py\n            return os.path.dirname(os.path.dirname(root_spec.origin))\n    else:\n        # module\n        return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]",
    "start_line": 709,
    "end_line": 751,
    "has_docstring": true,
    "docstring": "Find the path that contains the package or module.",
    "parameters": [
      "import_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _find_package_path",
    "component_id": "src.flask.sansio.scaffold._find_package_path"
  },
  "src.flask.sansio.scaffold.find_package": {
    "id": "src.flask.sansio.scaffold.find_package",
    "name": "find_package",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sansio/scaffold.py",
    "relative_path": "src/flask/sansio/scaffold.py",
    "depends_on": [
      "src.flask.sansio.scaffold._find_package_path"
    ],
    "source_code": "def find_package(import_name: str) -> tuple[str | None, str]:\n    \"\"\"Find the prefix that a package is installed under, and the path\n    that it would be imported from.\n\n    The prefix is the directory containing the standard directory\n    hierarchy (lib, bin, etc.). If the package is not installed to the\n    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n    ``None`` is returned.\n\n    The path is the entry in :attr:`sys.path` that contains the package\n    for import. If the package is not installed, it's assumed that the\n    package was imported from the current working directory.\n    \"\"\"\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if pathlib.PurePath(package_path).is_relative_to(py_prefix):\n        return py_prefix, package_path\n\n    site_parent, site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == \"site-packages\":\n        parent, folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == \"lib\":\n            return parent, package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == \"lib\":\n            return os.path.dirname(parent), package_path\n\n        # something else (prefix/site-packages)\n        return site_parent, package_path\n\n    # not installed\n    return None, package_path",
    "start_line": 754,
    "end_line": 792,
    "has_docstring": true,
    "docstring": "Find the prefix that a package is installed under, and the path\nthat it would be imported from.\n\nThe prefix is the directory containing the standard directory\nhierarchy (lib, bin, etc.). If the package is not installed to the\nsystem (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n``None`` is returned.\n\nThe path is the entry in :attr:`sys.path` that contains the package\nfor import. If the package is not installed, it's assumed that the\npackage was imported from the current working directory.",
    "parameters": [
      "import_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function find_package",
    "component_id": "src.flask.sansio.scaffold.find_package"
  },
  "src.flask.sessions.SessionMixin": {
    "id": "src.flask.sessions.SessionMixin",
    "name": "SessionMixin",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sessions.py",
    "relative_path": "src/flask/sessions.py",
    "depends_on": [],
    "source_code": "class SessionMixin(MutableMapping[str, t.Any]):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self) -> bool:\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)  # type: ignore[no-any-return]\n\n    @permanent.setter\n    def permanent(self, value: bool) -> None:\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True",
    "start_line": 24,
    "end_line": 49,
    "has_docstring": true,
    "docstring": "Expands a basic dictionary with session attributes.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class SessionMixin",
    "component_id": "src.flask.sessions.SessionMixin"
  },
  "src.flask.sessions.SecureCookieSession": {
    "id": "src.flask.sessions.SecureCookieSession",
    "name": "SecureCookieSession",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sessions.py",
    "relative_path": "src/flask/sessions.py",
    "depends_on": [
      "src.flask.sessions.SessionMixin"
    ],
    "source_code": "class SecureCookieSession(CallbackDict[str, t.Any], SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(\n        self,\n        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,\n    ) -> None:\n        def on_update(self: te.Self) -> None:\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n\n    def __getitem__(self, key: str) -> t.Any:\n        self.accessed = True\n        return super().__getitem__(key)\n\n    def get(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().get(key, default)\n\n    def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().setdefault(key, default)",
    "start_line": 52,
    "end_line": 94,
    "has_docstring": true,
    "docstring": "Base class for sessions based on signed cookies.\n\nThis session backend will set the :attr:`modified` and\n:attr:`accessed` attributes. It cannot reliably track whether a\nsession is new (vs. empty), so :attr:`new` remains hard coded to\n``False``.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SessionMixin"
    ],
    "class_name": null,
    "display_name": "class SecureCookieSession",
    "component_id": "src.flask.sessions.SecureCookieSession"
  },
  "src.flask.sessions.NullSession": {
    "id": "src.flask.sessions.NullSession",
    "name": "NullSession",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sessions.py",
    "relative_path": "src/flask/sessions.py",
    "depends_on": [
      "src.flask.sessions.SecureCookieSession"
    ],
    "source_code": "class NullSession(SecureCookieSession):\n    \"\"\"Class used to generate nicer error messages if sessions are not\n    available.  Will still allow read-only access to the empty session\n    but fail on setting.\n    \"\"\"\n\n    def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n\n    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail  # noqa: B950\n    del _fail",
    "start_line": 97,
    "end_line": 111,
    "has_docstring": true,
    "docstring": "Class used to generate nicer error messages if sessions are not\navailable.  Will still allow read-only access to the empty session\nbut fail on setting.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SecureCookieSession"
    ],
    "class_name": null,
    "display_name": "class NullSession",
    "component_id": "src.flask.sessions.NullSession"
  },
  "src.flask.sessions.SessionInterface": {
    "id": "src.flask.sessions.SessionInterface",
    "name": "SessionInterface",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sessions.py",
    "relative_path": "src/flask/sessions.py",
    "depends_on": [],
    "source_code": "class SessionInterface:\n    \"\"\"The basic interface you have to implement in order to replace the\n    default session interface which uses werkzeug's securecookie\n    implementation.  The only methods you have to implement are\n    :meth:`open_session` and :meth:`save_session`, the others have\n    useful defaults which you don't need to change.\n\n    The session object returned by the :meth:`open_session` method has to\n    provide a dictionary like interface plus the properties and methods\n    from the :class:`SessionMixin`.  We recommend just subclassing a dict\n    and adding that mixin::\n\n        class Session(dict, SessionMixin):\n            pass\n\n    If :meth:`open_session` returns ``None`` Flask will call into\n    :meth:`make_null_session` to create a session that acts as replacement\n    if the session support cannot work because some requirement is not\n    fulfilled.  The default :class:`NullSession` class that is created\n    will complain that the secret key was not set.\n\n    To replace the session interface on an application all you have to do\n    is to assign :attr:`flask.Flask.session_interface`::\n\n        app = Flask(__name__)\n        app.session_interface = MySessionInterface()\n\n    Multiple requests with the same session may be sent and handled\n    concurrently. When implementing a new session interface, consider\n    whether reads or writes to the backing store must be synchronized.\n    There is no guarantee on the order in which the session for each\n    request is opened or saved, it will occur in the order that requests\n    begin and end processing.\n\n    .. versionadded:: 0.8\n    \"\"\"\n\n    #: :meth:`make_null_session` will look here for the class that should\n    #: be created when a null session is requested.  Likewise the\n    #: :meth:`is_null_session` method will perform a typecheck against\n    #: this type.\n    null_session_class = NullSession\n\n    #: A flag that indicates if the session interface is pickle based.\n    #: This can be used by Flask extensions to make a decision in regards\n    #: to how to deal with the session object.\n    #:\n    #: .. versionadded:: 0.10\n    pickle_based = False\n\n    def make_null_session(self, app: Flask) -> NullSession:\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n\n    def is_null_session(self, obj: object) -> bool:\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n\n    def get_cookie_name(self, app: Flask) -> str:\n        \"\"\"The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.\"\"\"\n        return app.config[\"SESSION_COOKIE_NAME\"]  # type: ignore[no-any-return]\n\n    def get_cookie_domain(self, app: Flask) -> str | None:\n        \"\"\"The value of the ``Domain`` parameter on the session cookie. If not set,\n        browsers will only send the cookie to the exact domain it was set from.\n        Otherwise, they will send it to any subdomain of the given value as well.\n\n        Uses the :data:`SESSION_COOKIE_DOMAIN` config.\n\n        .. versionchanged:: 2.3\n            Not set by default, does not fall back to ``SERVER_NAME``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_DOMAIN\"]  # type: ignore[no-any-return]\n\n    def get_cookie_path(self, app: Flask) -> str:\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]  # type: ignore[no-any-return]\n\n    def get_cookie_httponly(self, app: Flask) -> bool:\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]  # type: ignore[no-any-return]\n\n    def get_cookie_secure(self, app: Flask) -> bool:\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]  # type: ignore[no-any-return]\n\n    def get_cookie_samesite(self, app: Flask) -> str | None:\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]  # type: ignore[no-any-return]\n\n    def get_cookie_partitioned(self, app: Flask) -> bool:\n        \"\"\"Returns True if the cookie should be partitioned. By default, uses\n        the value of :data:`SESSION_COOKIE_PARTITIONED`.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PARTITIONED\"]  # type: ignore[no-any-return]\n\n    def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.now(timezone.utc) + app.permanent_session_lifetime\n        return None\n\n    def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n\n    def open_session(self, app: Flask, request: Request) -> SessionMixin | None:\n        \"\"\"This is called at the beginning of each request, after\n        pushing the request context, before matching the URL.\n\n        This must return an object which implements a dictionary-like\n        interface as well as the :class:`SessionMixin` interface.\n\n        This will return ``None`` to indicate that loading failed in\n        some way that is not immediately an error. The request\n        context will fall back to using :meth:`make_null_session`\n        in this case.\n        \"\"\"\n        raise NotImplementedError()\n\n    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        \"\"\"This is called at the end of each request, after generating\n        a response, before removing the request context. It is skipped\n        if :meth:`is_null_session` returns ``True``.\n        \"\"\"\n        raise NotImplementedError()",
    "start_line": 114,
    "end_line": 284,
    "has_docstring": true,
    "docstring": "The basic interface you have to implement in order to replace the\ndefault session interface which uses werkzeug's securecookie\nimplementation.  The only methods you have to implement are\n:meth:`open_session` and :meth:`save_session`, the others have\nuseful defaults which you don't need to change.\n\nThe session object returned by the :meth:`open_session` method has to\nprovide a dictionary like interface plus the properties and methods\nfrom the :class:`SessionMixin`.  We recommend just subclassing a dict\nand adding that mixin::\n\n    class Session(dict, SessionMixin):\n        pass\n\nIf :meth:`open_session` returns ``None`` Flask will call into\n:meth:`make_null_session` to create a session that acts as replacement\nif the session support cannot work because some requirement is not\nfulfilled.  The default :class:`NullSession` class that is created\nwill complain that the secret key was not set.\n\nTo replace the session interface on an application all you have to do\nis to assign :attr:`flask.Flask.session_interface`::\n\n    app = Flask(__name__)\n    app.session_interface = MySessionInterface()\n\nMultiple requests with the same session may be sent and handled\nconcurrently. When implementing a new session interface, consider\nwhether reads or writes to the backing store must be synchronized.\nThere is no guarantee on the order in which the session for each\nrequest is opened or saved, it will occur in the order that requests\nbegin and end processing.\n\n.. versionadded:: 0.8",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class SessionInterface",
    "component_id": "src.flask.sessions.SessionInterface"
  },
  "src.flask.sessions._lazy_sha1": {
    "id": "src.flask.sessions._lazy_sha1",
    "name": "_lazy_sha1",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sessions.py",
    "relative_path": "src/flask/sessions.py",
    "depends_on": [],
    "source_code": "def _lazy_sha1(string: bytes = b\"\") -> t.Any:\n    \"\"\"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\n    SHA-1, in which case the import and use as a default would fail before the\n    developer can configure something else.\n    \"\"\"\n    return hashlib.sha1(string)",
    "start_line": 290,
    "end_line": 295,
    "has_docstring": true,
    "docstring": "Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\nSHA-1, in which case the import and use as a default would fail before the\ndeveloper can configure something else.",
    "parameters": [
      "string"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _lazy_sha1",
    "component_id": "src.flask.sessions._lazy_sha1"
  },
  "src.flask.sessions.SecureCookieSessionInterface": {
    "id": "src.flask.sessions.SecureCookieSessionInterface",
    "name": "SecureCookieSessionInterface",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/sessions.py",
    "relative_path": "src/flask/sessions.py",
    "depends_on": [
      "src.flask.json.__init__.dumps",
      "src.flask.json.__init__.loads",
      "src.flask.sessions.SessionInterface"
    ],
    "source_code": "class SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(_lazy_sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:\n        if not app.secret_key:\n            return None\n\n        keys: list[str | bytes] = []\n\n        if fallbacks := app.config[\"SECRET_KEY_FALLBACKS\"]:\n            keys.extend(fallbacks)\n\n        keys.append(app.secret_key)  # itsdangerous expects current key at top\n        return URLSafeTimedSerializer(\n            keys,  # type: ignore[arg-type]\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs={\n                \"key_derivation\": self.key_derivation,\n                \"digest_method\": self.digest_method,\n            },\n        )\n\n    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n        secure = self.get_cookie_secure(app)\n        partitioned = self.get_cookie_partitioned(app)\n        samesite = self.get_cookie_samesite(app)\n        httponly = self.get_cookie_httponly(app)\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    name,\n                    domain=domain,\n                    path=path,\n                    secure=secure,\n                    partitioned=partitioned,\n                    samesite=samesite,\n                    httponly=httponly,\n                )\n                response.vary.add(\"Cookie\")\n\n            return\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            partitioned=partitioned,\n            samesite=samesite,\n        )\n        response.vary.add(\"Cookie\")",
    "start_line": 298,
    "end_line": 399,
    "has_docstring": true,
    "docstring": "The default session interface that stores sessions in signed cookies\nthrough the :mod:`itsdangerous` module.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SessionInterface"
    ],
    "class_name": null,
    "display_name": "class SecureCookieSessionInterface",
    "component_id": "src.flask.sessions.SecureCookieSessionInterface"
  },
  "src.flask.templating._default_template_ctx_processor": {
    "id": "src.flask.templating._default_template_ctx_processor",
    "name": "_default_template_ctx_processor",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [],
    "source_code": "def _default_template_ctx_processor() -> dict[str, t.Any]:\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    rv: dict[str, t.Any] = {\"g\": ctx.g}\n\n    if ctx.has_request:\n        rv[\"request\"] = ctx.request\n        rv[\"session\"] = ctx.session\n\n    return rv",
    "start_line": 21,
    "end_line": 32,
    "has_docstring": true,
    "docstring": "Default template context processor.  Injects `request`,\n`session` and `g`.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _default_template_ctx_processor",
    "component_id": "src.flask.templating._default_template_ctx_processor"
  },
  "src.flask.templating.Environment": {
    "id": "src.flask.templating.Environment",
    "name": "Environment",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [],
    "source_code": "class Environment(BaseEnvironment):\n    \"\"\"Works like a regular Jinja environment but has some additional\n    knowledge of how Flask's blueprint works so that it can prepend the\n    name of the blueprint to referenced templates if necessary.\n    \"\"\"\n\n    def __init__(self, app: App, **options: t.Any) -> None:\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app",
    "start_line": 35,
    "end_line": 45,
    "has_docstring": true,
    "docstring": "Works like a regular Jinja environment but has some additional\nknowledge of how Flask's blueprint works so that it can prepend the\nname of the blueprint to referenced templates if necessary.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseEnvironment"
    ],
    "class_name": null,
    "display_name": "class Environment",
    "component_id": "src.flask.templating.Environment"
  },
  "src.flask.templating.DispatchingJinjaLoader": {
    "id": "src.flask.templating.DispatchingJinjaLoader",
    "name": "DispatchingJinjaLoader",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [
      "src.flask.debughelpers.explain_template_loading_attempts"
    ],
    "source_code": "class DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self.app = app\n\n    def get_source(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)\n\n    def _get_source_explained(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        attempts = []\n        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None\n        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)\n\n    def _get_source_fast(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        for _srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)\n\n    def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:\n        loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader\n\n    def list_templates(self) -> list[str]:\n        result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)",
    "start_line": 48,
    "end_line": 119,
    "has_docstring": true,
    "docstring": "A loader that looks for templates in the application and all\nthe blueprint folders.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseLoader"
    ],
    "class_name": null,
    "display_name": "class DispatchingJinjaLoader",
    "component_id": "src.flask.templating.DispatchingJinjaLoader"
  },
  "src.flask.templating._render": {
    "id": "src.flask.templating._render",
    "name": "_render",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [],
    "source_code": "def _render(ctx: AppContext, template: Template, context: dict[str, t.Any]) -> str:\n    app = ctx.app\n    app.update_template_context(ctx, context)\n    before_render_template.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n    rv = template.render(context)\n    template_rendered.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n    return rv",
    "start_line": 122,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ctx",
      "template",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _render",
    "component_id": "src.flask.templating._render"
  },
  "src.flask.templating.render_template": {
    "id": "src.flask.templating.render_template",
    "name": "render_template",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [
      "src.flask.templating._render"
    ],
    "source_code": "def render_template(\n    template_name_or_list: str | Template | list[str | Template],\n    **context: t.Any,\n) -> str:\n    \"\"\"Render a template by name with the given context.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.get_or_select_template(template_name_or_list)\n    return _render(ctx, template, context)",
    "start_line": 135,
    "end_line": 147,
    "has_docstring": true,
    "docstring": "Render a template by name with the given context.\n\n:param template_name_or_list: The name of the template to render. If\n    a list is given, the first name to exist will be rendered.\n:param context: The variables to make available in the template.",
    "parameters": [
      "template_name_or_list"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function render_template",
    "component_id": "src.flask.templating.render_template"
  },
  "src.flask.templating.render_template_string": {
    "id": "src.flask.templating.render_template_string",
    "name": "render_template_string",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [
      "src.flask.templating._render"
    ],
    "source_code": "def render_template_string(source: str, **context: t.Any) -> str:\n    \"\"\"Render a template from the given source string with the given\n    context.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.from_string(source)\n    return _render(ctx, template, context)",
    "start_line": 150,
    "end_line": 159,
    "has_docstring": true,
    "docstring": "Render a template from the given source string with the given\ncontext.\n\n:param source: The source code of the template to render.\n:param context: The variables to make available in the template.",
    "parameters": [
      "source"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function render_template_string",
    "component_id": "src.flask.templating.render_template_string"
  },
  "src.flask.templating._stream": {
    "id": "src.flask.templating._stream",
    "name": "_stream",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [],
    "source_code": "def _stream(\n    ctx: AppContext, template: Template, context: dict[str, t.Any]\n) -> t.Iterator[str]:\n    app = ctx.app\n    app.update_template_context(ctx, context)\n    before_render_template.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n\n    def generate() -> t.Iterator[str]:\n        yield from template.generate(context)\n        template_rendered.send(\n            app, _async_wrapper=app.ensure_sync, template=template, context=context\n        )\n\n    return stream_with_context(generate())",
    "start_line": 162,
    "end_line": 177,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ctx",
      "template",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _stream",
    "component_id": "src.flask.templating._stream"
  },
  "src.flask.templating.generate": {
    "id": "src.flask.templating.generate",
    "name": "generate",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [
      "src.flask.templating.generate"
    ],
    "source_code": "    def generate() -> t.Iterator[str]:\n        yield from template.generate(context)\n        template_rendered.send(\n            app, _async_wrapper=app.ensure_sync, template=template, context=context\n        )",
    "start_line": 171,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate",
    "component_id": "src.flask.templating.generate"
  },
  "src.flask.templating.stream_template": {
    "id": "src.flask.templating.stream_template",
    "name": "stream_template",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [
      "src.flask.templating._stream"
    ],
    "source_code": "def stream_template(\n    template_name_or_list: str | Template | list[str | Template],\n    **context: t.Any,\n) -> t.Iterator[str]:\n    \"\"\"Render a template by name with the given context as a stream.\n    This returns an iterator of strings, which can be used as a\n    streaming response from a view.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.get_or_select_template(template_name_or_list)\n    return _stream(ctx, template, context)",
    "start_line": 180,
    "end_line": 196,
    "has_docstring": true,
    "docstring": "Render a template by name with the given context as a stream.\nThis returns an iterator of strings, which can be used as a\nstreaming response from a view.\n\n:param template_name_or_list: The name of the template to render. If\n    a list is given, the first name to exist will be rendered.\n:param context: The variables to make available in the template.\n\n.. versionadded:: 2.2",
    "parameters": [
      "template_name_or_list"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function stream_template",
    "component_id": "src.flask.templating.stream_template"
  },
  "src.flask.templating.stream_template_string": {
    "id": "src.flask.templating.stream_template_string",
    "name": "stream_template_string",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/templating.py",
    "relative_path": "src/flask/templating.py",
    "depends_on": [
      "src.flask.templating._stream"
    ],
    "source_code": "def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:\n    \"\"\"Render a template from the given source string with the given\n    context as a stream. This returns an iterator of strings, which can\n    be used as a streaming response from a view.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.from_string(source)\n    return _stream(ctx, template, context)",
    "start_line": 199,
    "end_line": 211,
    "has_docstring": true,
    "docstring": "Render a template from the given source string with the given\ncontext as a stream. This returns an iterator of strings, which can\nbe used as a streaming response from a view.\n\n:param source: The source code of the template to render.\n:param context: The variables to make available in the template.\n\n.. versionadded:: 2.2",
    "parameters": [
      "source"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function stream_template_string",
    "component_id": "src.flask.templating.stream_template_string"
  },
  "src.flask.testing.EnvironBuilder": {
    "id": "src.flask.testing.EnvironBuilder",
    "name": "EnvironBuilder",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/testing.py",
    "relative_path": "src/flask/testing.py",
    "depends_on": [
      "src.flask.json.__init__.dumps"
    ],
    "source_code": "class EnvironBuilder(werkzeug.test.EnvironBuilder):\n    \"\"\"An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\n    application.\n\n    :param app: The Flask application to configure the environment from.\n    :param path: URL path being requested.\n    :param base_url: Base URL where the app is being served, which\n        ``path`` is relative to. If not given, built from\n        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n    :param url_scheme: Scheme to use instead of\n        :data:`PREFERRED_URL_SCHEME`.\n    :param json: If given, this is serialized as JSON and passed as\n        ``data``. Also defaults ``content_type`` to\n        ``application/json``.\n    :param args: other positional arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    :param kwargs: other keyword arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        path: str = \"/\",\n        base_url: str | None = None,\n        subdomain: str | None = None,\n        url_scheme: str | None = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(subdomain or url_scheme), (\n            'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n        )\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = urlsplit(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                path = f\"{path}?{url.query}\"\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)\n\n    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)",
    "start_line": 27,
    "end_line": 94,
    "has_docstring": true,
    "docstring": "An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\napplication.\n\n:param app: The Flask application to configure the environment from.\n:param path: URL path being requested.\n:param base_url: Base URL where the app is being served, which\n    ``path`` is relative to. If not given, built from\n    :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n    :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n:param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n:param url_scheme: Scheme to use instead of\n    :data:`PREFERRED_URL_SCHEME`.\n:param json: If given, this is serialized as JSON and passed as\n    ``data``. Also defaults ``content_type`` to\n    ``application/json``.\n:param args: other positional arguments passed to\n    :class:`~werkzeug.test.EnvironBuilder`.\n:param kwargs: other keyword arguments passed to\n    :class:`~werkzeug.test.EnvironBuilder`.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "werkzeug.test.EnvironBuilder"
    ],
    "class_name": null,
    "display_name": "class EnvironBuilder",
    "component_id": "src.flask.testing.EnvironBuilder"
  },
  "src.flask.testing._get_werkzeug_version": {
    "id": "src.flask.testing._get_werkzeug_version",
    "name": "_get_werkzeug_version",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/testing.py",
    "relative_path": "src/flask/testing.py",
    "depends_on": [],
    "source_code": "def _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version",
    "start_line": 100,
    "end_line": 106,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _get_werkzeug_version",
    "component_id": "src.flask.testing._get_werkzeug_version"
  },
  "src.flask.testing.FlaskClient": {
    "id": "src.flask.testing.FlaskClient",
    "name": "FlaskClient",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/testing.py",
    "relative_path": "src/flask/testing.py",
    "depends_on": [
      "src.flask.testing._get_werkzeug_version",
      "src.flask.testing.EnvironBuilder"
    ],
    "source_code": "class FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client, with additional behavior for\n    Flask. Can defer the cleanup of the request context until the end of a\n    ``with`` block. For general information about how to use this class refer to\n    :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`/testing` chapter.\n    \"\"\"\n\n    application: Flask\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }\n\n    @contextmanager\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Iterator[SessionMixin]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"\n        if self._cookies is None:\n            raise TypeError(\n                \"Cookies are disabled. Create a client with 'use_cookies=True'.\"\n            )\n\n        app = self.application\n        ctx = app.test_request_context(*args, **kwargs)\n        self._add_cookies_to_wsgi(ctx.request.environ)\n\n        with ctx:\n            sess = app.session_interface.open_session(app, ctx.request)\n\n        if sess is None:\n            raise RuntimeError(\"Session backend did not open a session.\")\n\n        yield sess\n        resp = app.response_class()\n\n        if app.session_interface.is_null_session(sess):\n            return\n\n        with ctx:\n            app.session_interface.save_session(app, sess, resp)\n\n        self._update_cookies_from_response(\n            ctx.request.host.partition(\":\")[0],\n            ctx.request.path,\n            resp.headers.getlist(\"Set-Cookie\"),\n        )\n\n    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:\n        out = {**self.environ_base, **other}\n\n        if self.preserve_context:\n            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n\n        return out\n\n    def _request_from_builder_args(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> BaseRequest:\n        kwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\n        builder = EnvironBuilder(self.application, *args, **kwargs)\n\n        try:\n            return builder.get_request()\n        finally:\n            builder.close()\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        if args and isinstance(\n            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)\n        ):\n            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n                builder = copy(args[0])\n                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]\n                request = builder.get_request()\n            elif isinstance(args[0], dict):\n                request = EnvironBuilder.from_environ(\n                    args[0], app=self.application, environ_base=self._copy_environ({})\n                ).get_request()\n            else:\n                # isinstance(args[0], BaseRequest)\n                request = copy(args[0])\n                request.environ = self._copy_environ(request.environ)\n        else:\n            # request is None\n            request = self._request_from_builder_args(args, kwargs)\n\n        # Pop any previously preserved contexts. This prevents contexts\n        # from being preserved across redirects or multiple requests\n        # within a single block.\n        self._context_stack.close()\n\n        response = super().open(\n            request,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )\n        response.json_module = self.application.json  # type: ignore[assignment]\n\n        # Re-push contexts that were preserved during the request.\n        for cm in self._new_contexts:\n            self._context_stack.enter_context(cm)\n\n        self._new_contexts.clear()\n        return response\n\n    def __enter__(self) -> FlaskClient:\n        if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.preserve_context = False\n        self._context_stack.close()",
    "start_line": 109,
    "end_line": 262,
    "has_docstring": true,
    "docstring": "Works like a regular Werkzeug test client, with additional behavior for\nFlask. Can defer the cleanup of the request context until the end of a\n``with`` block. For general information about how to use this class refer to\n:class:`werkzeug.test.Client`.\n\n.. versionchanged:: 0.12\n   `app.test_client()` includes preset default environment, which can be\n   set after instantiation of the `app.test_client()` object in\n   `client.environ_base`.\n\nBasic usage is outlined in the :doc:`/testing` chapter.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Client"
    ],
    "class_name": null,
    "display_name": "class FlaskClient",
    "component_id": "src.flask.testing.FlaskClient"
  },
  "src.flask.testing.FlaskCliRunner": {
    "id": "src.flask.testing.FlaskCliRunner",
    "name": "FlaskCliRunner",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/testing.py",
    "relative_path": "src/flask/testing.py",
    "depends_on": [
      "src.flask.cli.ScriptInfo"
    ],
    "source_code": "class FlaskCliRunner(CliRunner):\n    \"\"\"A :class:`~click.testing.CliRunner` for testing a Flask app's\n    CLI commands. Typically created using\n    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.\n    \"\"\"\n\n    def __init__(self, app: Flask, **kwargs: t.Any) -> None:\n        self.app = app\n        super().__init__(**kwargs)\n\n    def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> Result:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)",
    "start_line": 265,
    "end_line": 298,
    "has_docstring": true,
    "docstring": "A :class:`~click.testing.CliRunner` for testing a Flask app's\nCLI commands. Typically created using\n:meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "CliRunner"
    ],
    "class_name": null,
    "display_name": "class FlaskCliRunner",
    "component_id": "src.flask.testing.FlaskCliRunner"
  },
  "src.flask.views.View": {
    "id": "src.flask.views.View",
    "name": "View",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/views.py",
    "relative_path": "src/flask/views.py",
    "depends_on": [
      "src.flask.helpers.decorator"
    ],
    "source_code": "class View:\n    \"\"\"Subclass this class and override :meth:`dispatch_request` to\n    create a generic class-based view. Call :meth:`as_view` to create a\n    view function that creates an instance of the class with the given\n    arguments and calls its ``dispatch_request`` method with any URL\n    variables.\n\n    See :doc:`views` for a detailed guide.\n\n    .. code-block:: python\n\n        class Hello(View):\n            init_every_request = False\n\n            def dispatch_request(self, name):\n                return f\"Hello, {name}!\"\n\n        app.add_url_rule(\n            \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n        )\n\n    Set :attr:`methods` on the class to change what methods the view\n    accepts.\n\n    Set :attr:`decorators` on the class to apply a list of decorators to\n    the generated view function. Decorators applied to the class itself\n    will not be applied to the generated view function!\n\n    Set :attr:`init_every_request` to ``False`` for efficiency, unless\n    you need to store request-global data on ``self``.\n    \"\"\"\n\n    #: The methods this view is registered for. Uses the same default\n    #: (``[\"GET\", \"HEAD\", \"OPTIONS\"]``) as ``route`` and\n    #: ``add_url_rule`` by default.\n    methods: t.ClassVar[t.Collection[str] | None] = None\n\n    #: Control whether the ``OPTIONS`` method is handled automatically.\n    #: Uses the same default (``True``) as ``route`` and\n    #: ``add_url_rule`` by default.\n    provide_automatic_options: t.ClassVar[bool | None] = None\n\n    #: A list of decorators to apply, in order, to the generated view\n    #: function. Remember that ``@decorator`` syntax is applied bottom\n    #: to top, so the first decorator in the list would be the bottom\n    #: decorator.\n    #:\n    #: .. versionadded:: 0.8\n    decorators: t.ClassVar[list[t.Callable[..., t.Any]]] = []\n\n    #: Create a new instance of this view class for every request by\n    #: default. If a view subclass sets this to ``False``, the same\n    #: instance is used for every request.\n    #:\n    #: A single instance is more efficient, especially if complex setup\n    #: is done during init. However, storing data on ``self`` is no\n    #: longer safe across requests, and :data:`~flask.g` should be used\n    #: instead.\n    #:\n    #: .. versionadded:: 2.2\n    init_every_request: t.ClassVar[bool] = True\n\n    def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"The actual view function behavior. Subclasses must override\n        this and return a valid response. Any variables from the URL\n        rule are passed as keyword arguments.\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def as_view(\n        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any\n    ) -> ft.RouteCallable:\n        \"\"\"Convert the class into a view function that can be registered\n        for a route.\n\n        By default, the generated view will create a new instance of the\n        view class for every request and call its\n        :meth:`dispatch_request` method. If the view class sets\n        :attr:`init_every_request` to ``False``, the same instance will\n        be used for every request.\n\n        Except for ``name``, all other arguments passed to this method\n        are forwarded to the view class ``__init__`` method.\n\n        .. versionchanged:: 2.2\n            Added the ``init_every_request`` class attribute.\n        \"\"\"\n        if cls.init_every_request:\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                self = view.view_class(  # type: ignore[attr-defined]\n                    *class_args, **class_kwargs\n                )\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]\n\n        else:\n            self = cls(*class_args, **class_kwargs)  # pyright: ignore\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]\n\n        if cls.decorators:\n            view.__name__ = name\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        # We attach the view class to the view function for two reasons:\n        # first of all it allows us to easily figure out what class-based\n        # view this thing came from, secondly it's also used for instantiating\n        # the view class so you can actually replace it with something else\n        # for testing purposes and debugging.\n        view.view_class = cls  # type: ignore\n        view.__name__ = name\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.methods = cls.methods  # type: ignore\n        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore\n        return view",
    "start_line": 16,
    "end_line": 135,
    "has_docstring": true,
    "docstring": "Subclass this class and override :meth:`dispatch_request` to\ncreate a generic class-based view. Call :meth:`as_view` to create a\nview function that creates an instance of the class with the given\narguments and calls its ``dispatch_request`` method with any URL\nvariables.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class Hello(View):\n        init_every_request = False\n\n        def dispatch_request(self, name):\n            return f\"Hello, {name}!\"\n\n    app.add_url_rule(\n        \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n    )\n\nSet :attr:`methods` on the class to change what methods the view\naccepts.\n\nSet :attr:`decorators` on the class to apply a list of decorators to\nthe generated view function. Decorators applied to the class itself\nwill not be applied to the generated view function!\n\nSet :attr:`init_every_request` to ``False`` for efficiency, unless\nyou need to store request-global data on ``self``.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class View",
    "component_id": "src.flask.views.View"
  },
  "src.flask.views.MethodView": {
    "id": "src.flask.views.MethodView",
    "name": "MethodView",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/views.py",
    "relative_path": "src/flask/views.py",
    "depends_on": [
      "src.flask.views.View"
    ],
    "source_code": "class MethodView(View):\n    \"\"\"Dispatches request methods to the corresponding instance methods.\n    For example, if you implement a ``get`` method, it will be used to\n    handle ``GET`` requests.\n\n    This can be useful for defining a REST API.\n\n    :attr:`methods` is automatically set based on the methods defined on\n    the class.\n\n    See :doc:`views` for a detailed guide.\n\n    .. code-block:: python\n\n        class CounterAPI(MethodView):\n            def get(self):\n                return str(session.get(\"counter\", 0))\n\n            def post(self):\n                session[\"counter\"] = session.get(\"counter\", 0) + 1\n                return redirect(url_for(\"counter\"))\n\n        app.add_url_rule(\n            \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n        )\n    \"\"\"\n\n    def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        super().__init_subclass__(**kwargs)\n\n        if \"methods\" not in cls.__dict__:\n            methods = set()\n\n            for base in cls.__bases__:\n                if getattr(base, \"methods\", None):\n                    methods.update(base.methods)  # type: ignore[attr-defined]\n\n            for key in http_method_funcs:\n                if hasattr(cls, key):\n                    methods.add(key.upper())\n\n            if methods:\n                cls.methods = methods\n\n    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n        meth = getattr(self, request.method.lower(), None)\n\n        # If the request method is HEAD and we don't have a handler for it\n        # retry with GET.\n        if meth is None and request.method == \"HEAD\":\n            meth = getattr(self, \"get\", None)\n\n        assert meth is not None, f\"Unimplemented method {request.method!r}\"\n        return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]",
    "start_line": 138,
    "end_line": 191,
    "has_docstring": true,
    "docstring": "Dispatches request methods to the corresponding instance methods.\nFor example, if you implement a ``get`` method, it will be used to\nhandle ``GET`` requests.\n\nThis can be useful for defining a REST API.\n\n:attr:`methods` is automatically set based on the methods defined on\nthe class.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class CounterAPI(MethodView):\n        def get(self):\n            return str(session.get(\"counter\", 0))\n\n        def post(self):\n            session[\"counter\"] = session.get(\"counter\", 0) + 1\n            return redirect(url_for(\"counter\"))\n\n    app.add_url_rule(\n        \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n    )",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "View"
    ],
    "class_name": null,
    "display_name": "class MethodView",
    "component_id": "src.flask.views.MethodView"
  },
  "src.flask.wrappers.Request": {
    "id": "src.flask.wrappers.Request",
    "name": "Request",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/wrappers.py",
    "relative_path": "src/flask/wrappers.py",
    "depends_on": [
      "src.flask.helpers._split_blueprint_path",
      "src.flask.debughelpers.attach_enctype_error_multidict"
    ],
    "source_code": "class Request(RequestBase):\n    \"\"\"The request object used by default in Flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n\n    The request object is a :class:`~werkzeug.wrappers.Request` subclass and\n    provides all of the attributes Werkzeug defines plus a few Flask\n    specific ones.\n    \"\"\"\n\n    json_module: t.Any = json\n\n    #: The internal URL rule that matched the request.  This can be\n    #: useful to inspect which methods are allowed for the URL from\n    #: a before/after handler (``request.url_rule.methods``) etc.\n    #: Though if the request's method was invalid for the URL rule,\n    #: the valid list is available in ``routing_exception.valid_methods``\n    #: instead (an attribute of the Werkzeug exception\n    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)\n    #: because the request was never internally bound.\n    #:\n    #: .. versionadded:: 0.6\n    url_rule: Rule | None = None\n\n    #: A dict of view arguments that matched the request.  If an exception\n    #: happened when matching, this will be ``None``.\n    view_args: dict[str, t.Any] | None = None\n\n    #: If matching the URL failed, this is the exception that will be\n    #: raised / was raised as part of the request handling.  This is\n    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n    #: something similar.\n    routing_exception: HTTPException | None = None\n\n    _max_content_length: int | None = None\n    _max_form_memory_size: int | None = None\n    _max_form_parts: int | None = None\n\n    @property\n    def max_content_length(self) -> int | None:\n        \"\"\"The maximum number of bytes that will be read during this request. If\n        this limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`\n        error is raised. If it is set to ``None``, no limit is enforced at the\n        Flask application level. However, if it is ``None`` and the request has\n        no ``Content-Length`` header and the WSGI server does not indicate that\n        it terminates the stream, then no data is read to avoid an infinite\n        stream.\n\n        Each request defaults to the :data:`MAX_CONTENT_LENGTH` config, which\n        defaults to ``None``. It can be set on a specific ``request`` to apply\n        the limit to that specific view. This should be set appropriately based\n        on an application's or view's specific needs.\n\n        .. versionchanged:: 3.1\n            This can be set per-request.\n\n        .. versionchanged:: 0.6\n            This is configurable through Flask config.\n        \"\"\"\n        if self._max_content_length is not None:\n            return self._max_content_length\n\n        if not current_app:\n            return super().max_content_length\n\n        return current_app.config[\"MAX_CONTENT_LENGTH\"]  # type: ignore[no-any-return]\n\n    @max_content_length.setter\n    def max_content_length(self, value: int | None) -> None:\n        self._max_content_length = value\n\n    @property\n    def max_form_memory_size(self) -> int | None:\n        \"\"\"The maximum size in bytes any non-file form field may be in a\n        ``multipart/form-data`` body. If this limit is exceeded, a 413\n        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it\n        is set to ``None``, no limit is enforced at the Flask application level.\n\n        Each request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which\n        defaults to ``500_000``. It can be set on a specific ``request`` to\n        apply the limit to that specific view. This should be set appropriately\n        based on an application's or view's specific needs.\n\n        .. versionchanged:: 3.1\n            This is configurable through Flask config.\n        \"\"\"\n        if self._max_form_memory_size is not None:\n            return self._max_form_memory_size\n\n        if not current_app:\n            return super().max_form_memory_size\n\n        return current_app.config[\"MAX_FORM_MEMORY_SIZE\"]  # type: ignore[no-any-return]\n\n    @max_form_memory_size.setter\n    def max_form_memory_size(self, value: int | None) -> None:\n        self._max_form_memory_size = value\n\n    @property  # type: ignore[override]\n    def max_form_parts(self) -> int | None:\n        \"\"\"The maximum number of fields that may be present in a\n        ``multipart/form-data`` body. If this limit is exceeded, a 413\n        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it\n        is set to ``None``, no limit is enforced at the Flask application level.\n\n        Each request defaults to the :data:`MAX_FORM_PARTS` config, which\n        defaults to ``1_000``. It can be set on a specific ``request`` to apply\n        the limit to that specific view. This should be set appropriately based\n        on an application's or view's specific needs.\n\n        .. versionchanged:: 3.1\n            This is configurable through Flask config.\n        \"\"\"\n        if self._max_form_parts is not None:\n            return self._max_form_parts\n\n        if not current_app:\n            return super().max_form_parts\n\n        return current_app.config[\"MAX_FORM_PARTS\"]  # type: ignore[no-any-return]\n\n    @max_form_parts.setter\n    def max_form_parts(self, value: int | None) -> None:\n        self._max_form_parts = value\n\n    @property\n    def endpoint(self) -> str | None:\n        \"\"\"The endpoint that matched the request URL.\n\n        This will be ``None`` if matching failed or has not been\n        performed yet.\n\n        This in combination with :attr:`view_args` can be used to\n        reconstruct the same URL or a modified URL.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint  # type: ignore[no-any-return]\n\n        return None\n\n    @property\n    def blueprint(self) -> str | None:\n        \"\"\"The registered name of the current blueprint.\n\n        This will be ``None`` if the endpoint is not part of a\n        blueprint, or if URL matching failed or has not been performed\n        yet.\n\n        This does not necessarily match the name the blueprint was\n        created with. It may have been nested, or registered with a\n        different name.\n        \"\"\"\n        endpoint = self.endpoint\n\n        if endpoint is not None and \".\" in endpoint:\n            return endpoint.rpartition(\".\")[0]\n\n        return None\n\n    @property\n    def blueprints(self) -> list[str]:\n        \"\"\"The registered names of the current blueprint upwards through\n        parent blueprints.\n\n        This will be an empty list if there is no current blueprint, or\n        if URL matching failed.\n\n        .. versionadded:: 2.0.1\n        \"\"\"\n        name = self.blueprint\n\n        if name is None:\n            return []\n\n        return _split_blueprint_path(name)\n\n    def _load_form_data(self) -> None:\n        super()._load_form_data()\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)\n\n    def on_json_loading_failed(self, e: ValueError | None) -> t.Any:\n        try:\n            return super().on_json_loading_failed(e)\n        except BadRequest as ebr:\n            if current_app and current_app.debug:\n                raise\n\n            raise BadRequest() from ebr",
    "start_line": 18,
    "end_line": 219,
    "has_docstring": true,
    "docstring": "The request object used by default in Flask.  Remembers the\nmatched endpoint and view arguments.\n\nIt is what ends up as :class:`~flask.request`.  If you want to replace\nthe request object used you can subclass this and set\n:attr:`~flask.Flask.request_class` to your subclass.\n\nThe request object is a :class:`~werkzeug.wrappers.Request` subclass and\nprovides all of the attributes Werkzeug defines plus a few Flask\nspecific ones.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "RequestBase"
    ],
    "class_name": null,
    "display_name": "class Request",
    "component_id": "src.flask.wrappers.Request"
  },
  "src.flask.wrappers.Response": {
    "id": "src.flask.wrappers.Response",
    "name": "Response",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/flask/src/flask/wrappers.py",
    "relative_path": "src/flask/wrappers.py",
    "depends_on": [],
    "source_code": "class Response(ResponseBase):\n    \"\"\"The response object that is used by default in Flask.  Works like the\n    response object from Werkzeug but is set to have an HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.response_class` to your subclass.\n\n    .. versionchanged:: 1.0\n        JSON support is added to the response, like the request. This is useful\n        when testing to get the test client response data as JSON.\n\n    .. versionchanged:: 1.0\n\n        Added :attr:`max_cookie_size`.\n    \"\"\"\n\n    default_mimetype: str | None = \"text/html\"\n\n    json_module = json\n\n    autocorrect_location_header = False\n\n    @property\n    def max_cookie_size(self) -> int:  # type: ignore\n        \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"\n        if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]  # type: ignore[no-any-return]\n\n        # return Werkzeug's default when not in an app context\n        return super().max_cookie_size",
    "start_line": 222,
    "end_line": 257,
    "has_docstring": true,
    "docstring": "The response object that is used by default in Flask.  Works like the\nresponse object from Werkzeug but is set to have an HTML mimetype by\ndefault.  Quite often you don't have to create this object yourself because\n:meth:`~flask.Flask.make_response` will take care of that for you.\n\nIf you want to replace the response object used you can subclass this and\nset :attr:`~flask.Flask.response_class` to your subclass.\n\n.. versionchanged:: 1.0\n    JSON support is added to the response, like the request. This is useful\n    when testing to get the test client response data as JSON.\n\n.. versionchanged:: 1.0\n\n    Added :attr:`max_cookie_size`.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ResponseBase"
    ],
    "class_name": null,
    "display_name": "class Response",
    "component_id": "src.flask.wrappers.Response"
  }
}