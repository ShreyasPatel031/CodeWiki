{
  "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec": {
    "id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec",
    "name": "ElastiServiceSpec",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type ElastiServiceSpec struct {\n\t// ScaleTargetRef of the target resource to scale\n\tScaleTargetRef ScaleTargetRef `json:\"scaleTargetRef\"`\n\t// Service to scale\n\tService string `json:\"service\"`\n\t// Minimum number of replicas to scale to\n\t// +kubebuilder:validation:Minimum=1\n\tMinTargetReplicas int32 `json:\"minTargetReplicas,omitempty\" default:\"1\"`\n\t// Cooldown period in seconds.\n\t// It tells how long a target resource can be idle before scaling it down\n\t// +kubebuilder:validation:Minimum=0\n\t// +kubebuilder:validation:Maximum=604800\n\t// +kubebuilder:default=900\n\tCooldownPeriod int32 `json:\"cooldownPeriod,omitempty\"`\n\t// Triggers to scale the target resource\n\t// +kubebuilder:validation:MinItems=1\n\tTriggers   []ScaleTrigger  `json:\"triggers,omitempty\"`\n\tAutoscaler *AutoscalerSpec `json:\"autoscaler,omitempty\"`\n}",
    "start_line": 30,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ElastiServiceSpec",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec"
  },
  "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec.GetScaleTargetRef": {
    "id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec.GetScaleTargetRef",
    "name": "ElastiServiceSpec.GetScaleTargetRef",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "func (es *ElastiServiceSpec) GetScaleTargetRef() ScaleTargetRef {\n\t// NOTE: Required for backwards compatibility, since so far, we have been using \"deployments\" instead of \"Deployment\" in exisiting\n\t// CRD files. Since calse doesn't recognize \"deployments\" as a valid kind, we need to convert it to \"Deployment\".\n\t// We can remove it once we have migrated all the existing CRD files to use \"Deployment\" instead of \"deployments\".\n\tswitch es.ScaleTargetRef.Kind {\n\tcase \"deployments\":\n\t\tes.ScaleTargetRef.Kind = \"Deployment\"\n\tcase \"rollouts\":\n\t\tes.ScaleTargetRef.Kind = \"Rollout\"\n\tdefault:\n\t\treturn es.ScaleTargetRef\n\t}\n\n\treturn es.ScaleTargetRef\n}",
    "start_line": 50,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceSpec.GetScaleTargetRef",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec.GetScaleTargetRef"
  },
  "operator.api.v1alpha1.elastiservice_types.ScaleTargetRef": {
    "id": "operator.api.v1alpha1.elastiservice_types.ScaleTargetRef",
    "name": "ScaleTargetRef",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type ScaleTargetRef struct {\n\t// API version of the target resource\n\t// +kubebuilder:validation:Enum=apps/v1;argoproj.io/v1alpha1\n\tAPIVersion string `json:\"apiVersion\"`\n\t// Kind of the target resource\n\t// +kubebuilder:validation:Enum=deployments;rollouts;Deployment;StatefulSet;Rollout\n\tKind string `json:\"kind\"`\n\t// Name of the target resource\n\tName string `json:\"name\"`\n}",
    "start_line": 66,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ScaleTargetRef",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ScaleTargetRef"
  },
  "operator.api.v1alpha1.elastiservice_types.ElastiServiceStatus": {
    "id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceStatus",
    "name": "ElastiServiceStatus",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type ElastiServiceStatus struct {\n\t// Last time the ElastiService was reconciled\n\tLastReconciledTime metav1.Time `json:\"lastReconciledTime,omitempty\"`\n\t// Last time the ElastiService was scaled up\n\tLastScaledUpTime *metav1.Time `json:\"lastScaledUpTime,omitempty\"`\n\t// Current mode of the ElastiService, either \"proxy\" or \"serve\".\n\t// \"proxy\" mode is when the ScaleTargetRef is scaled to 0 replicas.\n\t// \"serve\" mode is when the ScaleTargetRef is scaled to at least 1 replica.\n\tMode string `json:\"mode,omitempty\"`\n}",
    "start_line": 77,
    "end_line": 86,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ElastiServiceStatus",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceStatus"
  },
  "operator.api.v1alpha1.elastiservice_types.ElastiService": {
    "id": "operator.api.v1alpha1.elastiservice_types.ElastiService",
    "name": "ElastiService",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type ElastiService struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tSpec   ElastiServiceSpec   `json:\"spec,omitempty\"`\n\tStatus ElastiServiceStatus `json:\"status,omitempty\"`\n}",
    "start_line": 92,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ElastiService",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ElastiService"
  },
  "operator.api.v1alpha1.elastiservice_types.ElastiService.GetSpec": {
    "id": "operator.api.v1alpha1.elastiservice_types.ElastiService.GetSpec",
    "name": "ElastiService.GetSpec",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [
      "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec.GetScaleTargetRef"
    ],
    "source_code": "func (es *ElastiService) GetSpec() ElastiServiceSpec {\n\tes.Spec.ScaleTargetRef = es.Spec.GetScaleTargetRef()\n\treturn es.Spec\n}",
    "start_line": 100,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiService.GetSpec",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ElastiService.GetSpec"
  },
  "operator.api.v1alpha1.elastiservice_types.ElastiServiceList": {
    "id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceList",
    "name": "ElastiServiceList",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type ElastiServiceList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tmetav1.ListMeta `json:\"metadata,omitempty\"`\n\tItems           []ElastiService `json:\"items\"`\n}",
    "start_line": 108,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ElastiServiceList",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ElastiServiceList"
  },
  "operator.api.v1alpha1.elastiservice_types.ScaleTrigger": {
    "id": "operator.api.v1alpha1.elastiservice_types.ScaleTrigger",
    "name": "ScaleTrigger",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type ScaleTrigger struct {\n\t// Type of the trigger, currently only prometheus is supported\n\t// +kubebuilder:validation:Enum=prometheus\n\tType string `json:\"type\"`\n\t// Metadata like query, serverAddress, threshold, uptimeFilter etc.\n\t// +kubebuilder:pruning:PreserveUnknownFields\n\t// +kubebuilder:validation:Schemaless\n\tMetadata json.RawMessage `json:\"metadata,omitempty\"`\n}",
    "start_line": 114,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ScaleTrigger",
    "component_id": "operator.api.v1alpha1.elastiservice_types.ScaleTrigger"
  },
  "operator.api.v1alpha1.elastiservice_types.AutoscalerSpec": {
    "id": "operator.api.v1alpha1.elastiservice_types.AutoscalerSpec",
    "name": "AutoscalerSpec",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "type AutoscalerSpec struct {\n\t// +kubebuilder:validation:Enum=hpa;keda\n\tType string `json:\"type\"`\n\tName string `json:\"name\"`\n}",
    "start_line": 124,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct AutoscalerSpec",
    "component_id": "operator.api.v1alpha1.elastiservice_types.AutoscalerSpec"
  },
  "operator.api.v1alpha1.elastiservice_types.init": {
    "id": "operator.api.v1alpha1.elastiservice_types.init",
    "name": "init",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/elastiservice_types.go",
    "relative_path": "operator/api/v1alpha1/elastiservice_types.go",
    "depends_on": [],
    "source_code": "func init() {\n\tSchemeBuilder.Register(&ElastiService{}, &ElastiServiceList{})\n}",
    "start_line": 130,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function init",
    "component_id": "operator.api.v1alpha1.elastiservice_types.init"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto",
    "name": "AutoscalerSpec.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [],
    "source_code": "func (in *AutoscalerSpec) DeepCopyInto(out *AutoscalerSpec) {\n\t*out = *in\n}",
    "start_line": 29,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method AutoscalerSpec.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy",
    "name": "AutoscalerSpec.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *AutoscalerSpec) DeepCopy() *AutoscalerSpec {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(AutoscalerSpec)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 34,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method AutoscalerSpec.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopyInto",
    "name": "ElastiService.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiService) DeepCopyInto(out *ElastiService) {\n\t*out = *in\n\tout.TypeMeta = in.TypeMeta\n\tin.ObjectMeta.DeepCopyInto(&out.ObjectMeta)\n\tin.Spec.DeepCopyInto(&out.Spec)\n\tin.Status.DeepCopyInto(&out.Status)\n}",
    "start_line": 44,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiService.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopy",
    "name": "ElastiService.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiService) DeepCopy() *ElastiService {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ElastiService)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 53,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiService.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopy"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopyObject": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopyObject",
    "name": "ElastiService.DeepCopyObject",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy"
    ],
    "source_code": "func (in *ElastiService) DeepCopyObject() runtime.Object {\n\tif c := in.DeepCopy(); c != nil {\n\t\treturn c\n\t}\n\treturn nil\n}",
    "start_line": 63,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiService.DeepCopyObject",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiService.DeepCopyObject"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopyInto",
    "name": "ElastiServiceList.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiServiceList) DeepCopyInto(out *ElastiServiceList) {\n\t*out = *in\n\tout.TypeMeta = in.TypeMeta\n\tin.ListMeta.DeepCopyInto(&out.ListMeta)\n\tif in.Items != nil {\n\t\tin, out := &in.Items, &out.Items\n\t\t*out = make([]ElastiService, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n}",
    "start_line": 71,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceList.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopy",
    "name": "ElastiServiceList.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiServiceList) DeepCopy() *ElastiServiceList {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ElastiServiceList)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 85,
    "end_line": 92,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceList.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopy"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopyObject": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopyObject",
    "name": "ElastiServiceList.DeepCopyObject",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy"
    ],
    "source_code": "func (in *ElastiServiceList) DeepCopyObject() runtime.Object {\n\tif c := in.DeepCopy(); c != nil {\n\t\treturn c\n\t}\n\treturn nil\n}",
    "start_line": 95,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceList.DeepCopyObject",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceList.DeepCopyObject"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceSpec.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceSpec.DeepCopyInto",
    "name": "ElastiServiceSpec.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiServiceSpec) DeepCopyInto(out *ElastiServiceSpec) {\n\t*out = *in\n\tout.ScaleTargetRef = in.ScaleTargetRef\n\tif in.Triggers != nil {\n\t\tin, out := &in.Triggers, &out.Triggers\n\t\t*out = make([]ScaleTrigger, len(*in))\n\t\tfor i := range *in {\n\t\t\t(*in)[i].DeepCopyInto(&(*out)[i])\n\t\t}\n\t}\n\tif in.Autoscaler != nil {\n\t\tin, out := &in.Autoscaler, &out.Autoscaler\n\t\t*out = new(AutoscalerSpec)\n\t\t**out = **in\n\t}\n}",
    "start_line": 103,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceSpec.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceSpec.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceSpec.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceSpec.DeepCopy",
    "name": "ElastiServiceSpec.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiServiceSpec) DeepCopy() *ElastiServiceSpec {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ElastiServiceSpec)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 121,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceSpec.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceSpec.DeepCopy"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceStatus.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceStatus.DeepCopyInto",
    "name": "ElastiServiceStatus.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy",
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiServiceStatus) DeepCopyInto(out *ElastiServiceStatus) {\n\t*out = *in\n\tin.LastReconciledTime.DeepCopyInto(&out.LastReconciledTime)\n\tif in.LastScaledUpTime != nil {\n\t\tin, out := &in.LastScaledUpTime, &out.LastScaledUpTime\n\t\t*out = (*in).DeepCopy()\n\t}\n}",
    "start_line": 131,
    "end_line": 138,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceStatus.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceStatus.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceStatus.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceStatus.DeepCopy",
    "name": "ElastiServiceStatus.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ElastiServiceStatus) DeepCopy() *ElastiServiceStatus {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ElastiServiceStatus)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 141,
    "end_line": 148,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceStatus.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ElastiServiceStatus.DeepCopy"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTargetRef.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTargetRef.DeepCopyInto",
    "name": "ScaleTargetRef.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [],
    "source_code": "func (in *ScaleTargetRef) DeepCopyInto(out *ScaleTargetRef) {\n\t*out = *in\n}",
    "start_line": 151,
    "end_line": 153,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleTargetRef.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTargetRef.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTargetRef.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTargetRef.DeepCopy",
    "name": "ScaleTargetRef.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ScaleTargetRef) DeepCopy() *ScaleTargetRef {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ScaleTargetRef)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 156,
    "end_line": 163,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleTargetRef.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTargetRef.DeepCopy"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTrigger.DeepCopyInto": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTrigger.DeepCopyInto",
    "name": "ScaleTrigger.DeepCopyInto",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [],
    "source_code": "func (in *ScaleTrigger) DeepCopyInto(out *ScaleTrigger) {\n\t*out = *in\n\tif in.Metadata != nil {\n\t\tin, out := &in.Metadata, &out.Metadata\n\t\t*out = make(json.RawMessage, len(*in))\n\t\tcopy(*out, *in)\n\t}\n}",
    "start_line": 166,
    "end_line": 173,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleTrigger.DeepCopyInto",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTrigger.DeepCopyInto"
  },
  "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTrigger.DeepCopy": {
    "id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTrigger.DeepCopy",
    "name": "ScaleTrigger.DeepCopy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/api/v1alpha1/zz_generated.deepcopy.go",
    "relative_path": "operator/api/v1alpha1/zz_generated.deepcopy.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopyInto"
    ],
    "source_code": "func (in *ScaleTrigger) DeepCopy() *ScaleTrigger {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ScaleTrigger)\n\tin.DeepCopyInto(out)\n\treturn out\n}",
    "start_line": 176,
    "end_line": 183,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleTrigger.DeepCopy",
    "component_id": "operator.api.v1alpha1.zz_generated.deepcopy.ScaleTrigger.DeepCopy"
  },
  "operator.cmd.main.init": {
    "id": "operator.cmd.main.init",
    "name": "init",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/cmd/main.go",
    "relative_path": "operator/cmd/main.go",
    "depends_on": [],
    "source_code": "func init() {\n\tutilruntime.Must(clientgoscheme.AddToScheme(scheme))\n\n\tutilruntime.Must(elastiv1alpha1.AddToScheme(scheme))\n\t//+kubebuilder:scaffold:scheme\n}",
    "start_line": 63,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function init",
    "component_id": "operator.cmd.main.init"
  },
  "operator.cmd.main.main": {
    "id": "operator.cmd.main.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/cmd/main.go",
    "relative_path": "operator/cmd/main.go",
    "depends_on": [
      "operator.cmd.main.mainWithError"
    ],
    "source_code": "func main() {\n\terr := mainWithError()\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n}",
    "start_line": 70,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "operator.cmd.main.main"
  },
  "operator.cmd.main.mainWithError": {
    "id": "operator.cmd.main.mainWithError",
    "name": "mainWithError",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/cmd/main.go",
    "relative_path": "operator/cmd/main.go",
    "depends_on": [
      "pkg.config.config.GetOperatorConfig",
      "operator.internal.elastiserver.elastiServer.Server.Start",
      "operator.internal.informer.informer.Manager.Stop",
      "operator.internal.elastiserver.elastiServer.NewServer",
      "operator.internal.informer.informer.NewInformerManager",
      "pkg.logger.logger.NewLogger",
      "pkg.scaling.scale_handler.NewScaleHandler",
      "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Initialize",
      "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.SetupWithManager",
      "operator.internal.crddirectory.directory.InitDirectory"
    ],
    "source_code": "func mainWithError() error {\n\t// Initialize Sentry\n\tsentryDsn := os.Getenv(\"SENTRY_DSN\")\n\tsentryEnabled := sentryDsn != \"\"\n\n\tif sentryEnabled {\n\t\tfmt.Println(\"Initializing Sentry\")\n\t\tif err := sentry.Init(sentry.ClientOptions{\n\t\t\tDsn:              sentryDsn,\n\t\t\tEnableTracing:    false,\n\t\t\tTracesSampleRate: 1.0,\n\t\t\tEnvironment:      os.Getenv(\"SENTRY_ENVIRONMENT\"),\n\t\t}); err != nil {\n\t\t\tfmt.Println(\"ERROR: Sentry initialization failed\")\n\t\t}\n\t\tdefer sentry.Flush(2 * time.Second)\n\t}\n\n\tvar watchNamespace string\n\tflag.StringVar(&watchNamespace, \"watch-namespace\", metav1.NamespaceAll, \"Namespace to watch for resources\")\n\n\tzapLogger, err := tfLogger.NewLogger(\"dev\", sentryEnabled)\n\tif err != nil {\n\t\tsetupLog.Error(err, \"unable to create logger\")\n\t}\n\n\tvar metricsAddr string\n\tvar enableLeaderElection bool\n\tvar probeAddr string\n\tvar secureMetrics bool\n\tvar enableHTTP2 bool\n\tflag.StringVar(&metricsAddr, \"metrics-bind-address\", \":8080\", \"The address the metric endpoint binds to.\")\n\tflag.StringVar(&probeAddr, \"health-probe-bind-address\", \":8081\", \"The address the probe endpoint binds to.\")\n\tflag.BoolVar(&enableLeaderElection, \"leader-elect\", false,\n\t\t\"Enable leader election for controller manager. \"+\n\t\t\t\"Enabling this will ensure there is only one active controller manager.\")\n\tflag.BoolVar(&secureMetrics, \"metrics-secure\", false,\n\t\t\"If set the metrics endpoint is served securely\")\n\tflag.BoolVar(&enableHTTP2, \"enable-http2\", false,\n\t\t\"If set, HTTP/2 will be enabled for the metrics and webhook servers\")\n\topts := zap.Options{\n\t\tDevelopment: true,\n\t}\n\topts.BindFlags(flag.CommandLine)\n\tflag.Parse()\n\n\tctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))\n\n\t// if the enable-http2 flag is false (the default), http/2 should be disabled\n\t// due to its vulnerabilities. More specifically, disabling http/2 will\n\t// prevent from being vulnerable to the HTTP/2 Stream Cancellation and\n\t// Rapid Reset CVEs. For more information see:\n\t// - https://github.com/advisories/GHSA-qppj-fm5r-hxr3\n\t// - https://github.com/advisories/GHSA-4374-p667-p6c8\n\tdisableHTTP2 := func(c *tls.Config) {\n\t\tsetupLog.Info(\"disabling http/2\")\n\t\tc.NextProtos = []string{\"http/1.1\"}\n\t}\n\n\tvar tlsOpts []func(*tls.Config)\n\tif !enableHTTP2 {\n\t\ttlsOpts = append(tlsOpts, disableHTTP2)\n\t}\n\n\twebhookServer := webhook.NewServer(webhook.Options{\n\t\tTLSOpts: tlsOpts,\n\t})\n\n\tmgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n\t\tScheme: scheme,\n\t\tMetrics: metricsserver.Options{\n\t\t\tBindAddress:   metricsAddr,\n\t\t\tSecureServing: secureMetrics,\n\t\t\tTLSOpts:       tlsOpts,\n\t\t},\n\t\tWebhookServer:                 webhookServer,\n\t\tHealthProbeBindAddress:        probeAddr,\n\t\tLeaderElection:                enableLeaderElection,\n\t\tLeaderElectionID:              \"acf50383.truefoundry.io\",\n\t\tLeaderElectionReleaseOnCancel: true,\n\t})\n\tif err != nil {\n\t\tsetupLog.Error(err, \"unable to start manager\")\n\t\tsentry.CaptureException(err)\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\t}\n\n\t// Start the shared CRD Directory\n\tcrddirectory.InitDirectory(zapLogger)\n\t// Initiate and start the shared informerManager manager\n\tinformerManager := informer.NewInformerManager(zapLogger, mgr.GetConfig())\n\tinformerManager.Start()\n\tdefer informerManager.Stop()\n\n\t// Initiate and start the shared scaleHandler\n\tscaleHandler := scaling.NewScaleHandler(zapLogger, mgr.GetConfig(), watchNamespace, mgr.GetEventRecorderFor(\"elasti-operator\"))\n\n\t// Set up the ElastiService controller\n\treconciler := &controller.ElastiServiceReconciler{\n\t\tClient:          mgr.GetClient(),\n\t\tScheme:          mgr.GetScheme(),\n\t\tLogger:          zapLogger,\n\t\tInformerManager: informerManager,\n\t\tScaleHandler:    scaleHandler,\n\t}\n\n\tif err = reconciler.SetupWithManager(mgr, watchNamespace); err != nil {\n\t\tsetupLog.Error(err, \"unable to create controller\", \"controller\", \"ElastiService\")\n\t\tsentry.CaptureException(err)\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\t}\n\n\t// Start the elasti server\n\teServer := elastiserver.NewServer(zapLogger, scaleHandler, 30*time.Second)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\telastiServerPort := fmt.Sprintf(\":%d\", config.GetOperatorConfig().Port)\n\t\tif err := eServer.Start(elastiServerPort); err != nil {\n\t\t\tsetupLog.Error(err, \"elasti server failed to start\")\n\t\t\tsentry.CaptureException(err)\n\t\t\terrChan <- fmt.Errorf(\"elasti server: %w\", err)\n\t\t}\n\t}()\n\n\t// Add error channel check before manager start\n\tselect {\n\tcase err := <-errChan:\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\tdefault:\n\t}\n\n\t//+kubebuilder:scaffold:builder\n\tif err := mgr.AddHealthzCheck(\"healthz\", healthz.Ping); err != nil {\n\t\tsetupLog.Error(err, \"unable to set up health check\")\n\t\tsentry.CaptureException(err)\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\t}\n\t// if err := mgr.AddReadyzCheck(\"readyz\", leaderReadinessCheck(mgr)); err != nil {\n\t// \tsetupLog.Error(err, \"unable to set up ready check\")\n\t// \tsentry.CaptureException(err)\n\t// \treturn fmt.Errorf(\"main: %w\", err)\n\t// }\n\tif err := mgr.AddReadyzCheck(\"readyz\", healthz.Ping); err != nil {\n\t\tsetupLog.Error(err, \"unable to set up ready check\")\n\t\tsentry.CaptureException(err)\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\t}\n\n\tsetupLog.Info(\"starting manager\")\n\tmgrErrChan := make(chan error, 1)\n\t// we are using a goroutine to start the manager because we don't want to block the main thread\n\tgo func() {\n\t\tif err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {\n\t\t\tsetupLog.Error(err, \"problem running manager\")\n\t\t\tmgrErrChan <- fmt.Errorf(\"manager: %w\", err)\n\t\t}\n\t}()\n\n\t// Wait for cache to sync\n\tif !mgr.GetCache().WaitForCacheSync(context.Background()) {\n\t\treturn fmt.Errorf(\"failed to sync cache\")\n\t}\n\n\tif err = reconciler.Initialize(context.Background(), watchNamespace); err != nil {\n\t\tsetupLog.Error(err, \"unable to initialize controller\")\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\t}\n\tsetupLog.Info(\"initialized controller\")\n\n\tif err := <-mgrErrChan; err != nil {\n\t\treturn fmt.Errorf(\"main: %w\", err)\n\t}\n\n\treturn nil\n}",
    "start_line": 77,
    "end_line": 251,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function mainWithError",
    "component_id": "operator.cmd.main.mainWithError"
  },
  "operator.cmd.main._": {
    "id": "operator.cmd.main._",
    "name": "_",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/cmd/main.go",
    "relative_path": "operator/cmd/main.go",
    "depends_on": [],
    "source_code": "func _(mgr ctrl.Manager) healthz.Checker {\n\treturn func(_ *http.Request) error {\n\t\tselect {\n\t\tcase <-mgr.Elected():\n\t\t\treturn nil\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"controller is not the leader yet\")\n\t\t}\n\t}\n}",
    "start_line": 253,
    "end_line": 262,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _",
    "component_id": "operator.cmd.main._"
  },
  "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler": {
    "id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler",
    "name": "ElastiServiceReconciler",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/elastiservice_controller.go",
    "relative_path": "operator/internal/controller/elastiservice_controller.go",
    "depends_on": [],
    "source_code": "type (\n\tSwitchModeFunc          func(ctx context.Context, req ctrl.Request, mode string) (res ctrl.Result, err error)\n\tElastiServiceReconciler struct {\n\t\tclient.Client\n\t\tScheme             *kRuntime.Scheme\n\t\tLogger             *zap.Logger\n\t\tInformerManager    *informer.Manager\n\t\tSwitchModeLocks    sync.Map\n\t\tScaleHandler       *scaling.ScaleHandler\n\t\tInformerStartLocks sync.Map\n\t\tReconcileLocks     sync.Map\n\t}\n)",
    "start_line": 29,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ElastiServiceReconciler",
    "component_id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler"
  },
  "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Reconcile": {
    "id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Reconcile",
    "name": "ElastiServiceReconciler.Reconcile",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/elastiservice_controller.go",
    "relative_path": "operator/internal/controller/elastiservice_controller.go",
    "depends_on": [
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.addCRDFinalizer",
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchScaleTargetRef",
      "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.getMutexForReconcile",
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.getCRD",
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRDIfDeleted",
      "operator.internal.crddirectory.directory.AddCRD"
    ],
    "source_code": "func (r *ElastiServiceReconciler) Reconcile(ctx context.Context, req ctrl.Request) (res ctrl.Result, err error) {\n\tr.Logger.Debug(\"- In Reconcile\", zap.String(\"es\", req.NamespacedName.String()))\n\tmutex := r.getMutexForReconcile(req.NamespacedName.String())\n\tmutex.Lock()\n\tdefer r.Logger.Debug(\"- Out of Reconcile\", zap.String(\"es\", req.NamespacedName.String()))\n\tdefer mutex.Unlock()\n\tstartTime := time.Now()\n\n\tdefer func() {\n\t\te := values.Success\n\t\tif err != nil {\n\t\t\te = err.Error()\n\t\t\tr.Logger.Error(\"Error reconciling ElastiService.\", zap.String(\"es\", req.NamespacedName.String()), zap.Error(err))\n\t\t}\n\t\tduration := time.Since(startTime).Seconds()\n\t\tprom.CRDReconcileHistogram.WithLabelValues(req.String(), e).Observe(duration)\n\t}()\n\n\tes, esErr := r.getCRD(ctx, req.NamespacedName)\n\tif esErr != nil {\n\t\tif errors.IsNotFound(esErr) {\n\t\t\tr.Logger.Error(\"ElastiService not found.\", zap.String(\"es\", req.String()))\n\t\t\treturn res, nil\n\t\t}\n\t\tr.Logger.Error(\"Failed to get ElastiService in Reconcile\", zap.String(\"es\", req.String()), zap.Error(esErr))\n\t\treturn res, esErr\n\t}\n\n\t// If the ElastiService is being deleted, we need to clean up the resources\n\tif isDeleted, err := r.finalizeCRDIfDeleted(ctx, es, req); err != nil {\n\t\tr.Logger.Error(\"Failed to check if CRD is deleted\", zap.String(\"es\", req.String()), zap.Error(err))\n\t\treturn res, err\n\t} else if isDeleted {\n\t\tr.Logger.Info(\"[CRD is deleted successfully]\", zap.String(\"es\", req.String()))\n\t\treturn res, nil\n\t}\n\n\t// We also check if the CRD has finalizer, and if not, we add the finalizer\n\tif err := r.addCRDFinalizer(ctx, es); err != nil {\n\t\tr.Logger.Error(\"Failed to finalize CRD\", zap.String(\"es\", req.String()), zap.Error(err))\n\t\treturn res, err\n\t}\n\tr.Logger.Info(\"Finalizer added to CRD\", zap.String(\"es\", req.String()))\n\n\t// Add watch for public service, so when the public service is modified, we can update the private service\n\tif err := r.watchScaleTargetRef(ctx, es, req); err != nil {\n\t\tr.Logger.Error(\"Failed to add watch for ScaleTargetRef\", zap.String(\"es\", req.String()), zap.Any(\"scaleTargetRef\", es.Spec.ScaleTargetRef), zap.Error(err))\n\t\treturn res, err\n\t}\n\tr.Logger.Info(\"Watch added for ScaleTargetRef\", zap.String(\"es\", req.String()), zap.Any(\"scaleTargetRef\", es.Spec.ScaleTargetRef))\n\n\t// We add the CRD details to service directory, so when elasti server received a request,\n\t// we can find the right resource to scale up\n\tsvcNamespacedName := types.NamespacedName{Name: es.Spec.Service, Namespace: es.Namespace}\n\tcrddirectory.AddCRD(svcNamespacedName.String(), &crddirectory.CRDDetails{\n\t\tCRDName: es.Name,\n\t\tSpec:    es.Spec,\n\t\tStatus:  es.Status,\n\t})\n\tr.Logger.Info(\"CRD added to service directory\", zap.String(\"es\", req.String()), zap.String(\"service\", es.Spec.Service))\n\treturn res, nil\n}",
    "start_line": 56,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.Reconcile",
    "component_id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Reconcile"
  },
  "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.SetupWithManager": {
    "id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.SetupWithManager",
    "name": "ElastiServiceReconciler.SetupWithManager",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/elastiservice_controller.go",
    "relative_path": "operator/internal/controller/elastiservice_controller.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) SetupWithManager(mgr ctrl.Manager, watchNamespace string) error {\n\terr := ctrl.NewControllerManagedBy(mgr).\n\t\tFor(&v1alpha1.ElastiService{}).\n\t\tWithEventFilter(predicate.NewPredicateFuncs(func(obj client.Object) bool {\n\t\t\tes, ok := obj.(*v1alpha1.ElastiService)\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif watchNamespace == metav1.NamespaceAll || es.Namespace == watchNamespace {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})).\n\t\tComplete(r)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"SetupWithManager: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 119,
    "end_line": 137,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.SetupWithManager",
    "component_id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.SetupWithManager"
  },
  "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.getMutexForReconcile": {
    "id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.getMutexForReconcile",
    "name": "ElastiServiceReconciler.getMutexForReconcile",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/elastiservice_controller.go",
    "relative_path": "operator/internal/controller/elastiservice_controller.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) getMutexForReconcile(key string) *sync.Mutex {\n\tl, _ := r.ReconcileLocks.LoadOrStore(key, &sync.Mutex{})\n\treturn l.(*sync.Mutex)\n}",
    "start_line": 139,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getMutexForReconcile",
    "component_id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.getMutexForReconcile"
  },
  "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Initialize": {
    "id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Initialize",
    "name": "ElastiServiceReconciler.Initialize",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/elastiservice_controller.go",
    "relative_path": "operator/internal/controller/elastiservice_controller.go",
    "depends_on": [
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getResolverChangeHandler",
      "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.reconcileExistingCRDs",
      "operator.internal.informer.informer.Manager.InitializeResolverInformer",
      "pkg.scaling.scale_handler.ScaleHandler.StartScaleDownWatcher"
    ],
    "source_code": "func (r *ElastiServiceReconciler) Initialize(ctx context.Context, watchNamespace string) error {\n\tif err := r.reconcileExistingCRDs(ctx, watchNamespace); err != nil {\n\t\treturn fmt.Errorf(\"failed to reconcile existing CRDs: %w\", err)\n\t}\n\tif err := r.InformerManager.InitializeResolverInformer(r.getResolverChangeHandler(ctx)); err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize resolver informer: %w\", err)\n\t}\n\tr.ScaleHandler.StartScaleDownWatcher(ctx)\n\treturn nil\n}",
    "start_line": 144,
    "end_line": 153,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.Initialize",
    "component_id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Initialize"
  },
  "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.reconcileExistingCRDs": {
    "id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.reconcileExistingCRDs",
    "name": "ElastiServiceReconciler.reconcileExistingCRDs",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/elastiservice_controller.go",
    "relative_path": "operator/internal/controller/elastiservice_controller.go",
    "depends_on": [
      "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.Reconcile"
    ],
    "source_code": "func (r *ElastiServiceReconciler) reconcileExistingCRDs(ctx context.Context, watchNamespace string) error {\n\tcrdList := &v1alpha1.ElastiServiceList{}\n\tif err := r.List(ctx, crdList, client.InNamespace(watchNamespace)); err != nil {\n\t\treturn fmt.Errorf(\"failed to list ElastiServices: %w\", err)\n\t}\n\tcount := 0\n\n\tfor _, es := range crdList.Items {\n\t\t// Skip if being deleted\n\t\tif !es.ObjectMeta.DeletionTimestamp.IsZero() {\n\t\t\tr.Logger.Debug(\"Skipping ElastiService because it is being deleted\", zap.String(\"name\", es.Name), zap.String(\"namespace\", es.Namespace))\n\t\t\tcontinue\n\t\t}\n\n\t\treq := ctrl.Request{\n\t\t\tNamespacedName: types.NamespacedName{\n\t\t\t\tName:      es.Name,\n\t\t\t\tNamespace: es.Namespace,\n\t\t\t},\n\t\t}\n\n\t\tif _, err := r.Reconcile(ctx, req); err != nil {\n\t\t\tr.Logger.Error(\n\t\t\t\t\"Failed to reconcile existing ElastiService\",\n\t\t\t\tzap.String(\"name\", es.Name),\n\t\t\t\tzap.String(\"namespace\", es.Namespace),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t\tcontinue\n\t\t}\n\t\tcount++\n\t\tr.Logger.Info(\n\t\t\t\"Reconciled existing ElastiService\",\n\t\t\tzap.String(\"name\", es.Name),\n\t\t\tzap.String(\"namespace\", es.Namespace),\n\t\t)\n\t}\n\n\tr.Logger.Info(\"Successfully reconciled all existing ElastiServices\", zap.Int(\"count\", count))\n\n\treturn nil\n}",
    "start_line": 155,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.reconcileExistingCRDs",
    "component_id": "operator.internal.controller.elastiservice_controller.ElastiServiceReconciler.reconcileExistingCRDs"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.getCRD": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.getCRD",
    "name": "ElastiServiceReconciler.getCRD",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get"
    ],
    "source_code": "func (r *ElastiServiceReconciler) getCRD(ctx context.Context, crdNamespacedName types.NamespacedName) (*v1alpha1.ElastiService, error) {\n\tes := &v1alpha1.ElastiService{}\n\tif err := r.Get(ctx, crdNamespacedName, es); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get ElastiService: %w\", err)\n\t}\n\treturn es, nil\n}",
    "start_line": 23,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getCRD",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.getCRD"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.updateCRDStatus": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.updateCRDStatus",
    "name": "ElastiServiceReconciler.updateCRDStatus",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy",
      "resolver.internal.handler.handler.bufferPool.Get"
    ],
    "source_code": "func (r *ElastiServiceReconciler) updateCRDStatus(ctx context.Context, crdNamespacedName types.NamespacedName, mode string) (err error) {\n\tdefer func() {\n\t\terrStr := values.Success\n\t\tif err != nil {\n\t\t\terrStr = err.Error()\n\t\t}\n\t\tprom.CRDUpdateCounter.WithLabelValues(crdNamespacedName.String(), mode, errStr).Inc()\n\t\tvar modeGauge float64\n\t\tmodeGauge = 0\n\t\tif mode == values.ProxyMode {\n\t\t\tmodeGauge = 1\n\t\t}\n\t\tprom.ModeGauge.WithLabelValues(crdNamespacedName.String()).Set(modeGauge)\n\t}()\n\tes := &v1alpha1.ElastiService{}\n\tif err = r.Client.Get(ctx, crdNamespacedName, es); err != nil {\n\t\tr.Logger.Error(\"Failed to get ElastiService for status update\", zap.String(\"es\", crdNamespacedName.String()), zap.Error(err))\n\t\treturn fmt.Errorf(\"failed to get elastiService for status update\")\n\t}\n\toriginal := es.DeepCopy()\n\n\tes.Status.LastReconciledTime = metav1.Now()\n\tes.Status.Mode = mode\n\n\tif err = r.Status().Patch(ctx, es, client.MergeFrom(original)); err != nil {\n\t\tr.Logger.Error(\"Failed to patch status\", zap.String(\"es\", crdNamespacedName.String()), zap.Error(err))\n\t\treturn fmt.Errorf(\"failed to patch CRD status\")\n\t}\n\n\tr.Logger.Info(\"CRD Status updated successfully\")\n\treturn nil\n}",
    "start_line": 31,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.updateCRDStatus",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.updateCRDStatus"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.addCRDFinalizer": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.addCRDFinalizer",
    "name": "ElastiServiceReconciler.addCRDFinalizer",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) addCRDFinalizer(ctx context.Context, es *v1alpha1.ElastiService) error {\n\t// If the CRD does not contain the finalizer, we add the finalizer\n\tif !controllerutil.ContainsFinalizer(es, v1alpha1.ElastiServiceFinalizer) {\n\t\tcontrollerutil.AddFinalizer(es, v1alpha1.ElastiServiceFinalizer)\n\t\tif err := r.Update(ctx, es); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to add finalizer: %w\", err)\n\t\t}\n\t}\n\treturn nil\n}",
    "start_line": 64,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.addCRDFinalizer",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.addCRDFinalizer"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRD": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRD",
    "name": "ElastiServiceReconciler.finalizeCRD",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.Add",
      "operator.internal.crddirectory.directory.RemoveCRD",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.resetMutexForInformer",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForTargetRef",
      "operator.internal.controller.opsServices.ElastiServiceReconciler.deletePrivateService",
      "operator.internal.informer.informer.Manager.StopForCRD",
      "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.deleteEndpointsliceToResolver",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForPublicSVC"
    ],
    "source_code": "func (r *ElastiServiceReconciler) finalizeCRD(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request) error {\n\tr.Logger.Info(\"ElastiService is being deleted\", zap.String(\"name\", es.Name), zap.Any(\"deletionTimestamp\", es.ObjectMeta.DeletionTimestamp))\n\tvar wg sync.WaitGroup\n\twg.Add(3)\n\t// Stop all active informers related to this CRD in background\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tr.InformerManager.StopForCRD(req.Name, req.Namespace)\n\t\tr.Logger.Info(\"[Done] Informer stopped for CRD\", zap.String(\"es\", req.String()))\n\t\t// Reset the informer start mutex, so if the ElastiService is recreated, we will need to reset the informer\n\t\tr.resetMutexForInformer(r.getMutexKeyForTargetRef(req))\n\t\tr.resetMutexForInformer(r.getMutexKeyForPublicSVC(req))\n\t\tr.Logger.Info(\"[Done] Informer mutex reset for ScaleTargetRef and PublicSVC\", zap.String(\"es\", req.String()))\n\t}()\n\ttargetNamespacedName := types.NamespacedName{\n\t\tName:      es.Spec.Service,\n\t\tNamespace: es.Namespace,\n\t}\n\tvar err1, err2 error\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t// Delete EndpointSlice to resolver\n\t\terr1 = r.deleteEndpointsliceToResolver(ctx, targetNamespacedName)\n\t\tif err1 == nil {\n\t\t\tr.Logger.Info(\"[Done] EndpointSlice to resolver deleted\", zap.String(\"service\", targetNamespacedName.String()))\n\t\t}\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t// Delete private service\n\t\terr2 = r.deletePrivateService(ctx, targetNamespacedName)\n\t\tif err2 == nil {\n\t\t\tr.Logger.Info(\"[Done] Private service deleted\", zap.String(\"service\", targetNamespacedName.String()))\n\t\t}\n\t}()\n\twg.Wait()\n\t// Remove CRD details from service directory\n\tcrddirectory.RemoveCRD(targetNamespacedName.String())\n\tr.Logger.Info(\"[Done] CRD removed from service directory\", zap.String(\"es\", req.String()))\n\n\tif err1 != nil || err2 != nil {\n\t\treturn fmt.Errorf(\"failed to finalize CRD. \\n Error 1: %w \\n Error 2: %w\", err1, err2)\n\t}\n\tr.Logger.Info(\"[SERVE MODE ENABLED]\")\n\treturn nil\n}",
    "start_line": 76,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.finalizeCRD",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRD"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchScaleTargetRef": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchScaleTargetRef",
    "name": "ElastiServiceReconciler.watchScaleTargetRef",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.Add",
      "operator.internal.informer.informer.Manager.StopInformer",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.resetMutexForInformer",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForTargetRef",
      "pkg.k8shelper.utils.KindToResource",
      "operator.internal.informer.informer.Manager.GetKey",
      "operator.internal.crddirectory.directory.GetCRD",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexForInformerStart",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getScaleTargetRefChangeHandler"
    ],
    "source_code": "func (r *ElastiServiceReconciler) watchScaleTargetRef(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request) error {\n\tif es.Spec.ScaleTargetRef.Name == \"\" ||\n\t\tes.Spec.ScaleTargetRef.Kind == \"\" ||\n\t\tes.Spec.ScaleTargetRef.APIVersion == \"\" {\n\t\treturn fmt.Errorf(\"scaleTargetRef is incomplete: %w\", k8shelper.ErrNoScaleTargetFound)\n\t}\n\n\tsvcNamespacedName := types.NamespacedName{Name: es.Spec.Service, Namespace: es.Namespace}\n\tcrd, found := crddirectory.GetCRD(svcNamespacedName.String())\n\tif found {\n\t\tif es.Spec.ScaleTargetRef.Name != crd.Spec.ScaleTargetRef.Name ||\n\t\t\tes.Spec.ScaleTargetRef.Kind != crd.Spec.ScaleTargetRef.Kind ||\n\t\t\tes.Spec.ScaleTargetRef.APIVersion != crd.Spec.ScaleTargetRef.APIVersion {\n\t\t\tr.Logger.Debug(\"ScaleTargetRef has changed, stopping previous informer.\", zap.String(\"es\", req.String()), zap.Any(\"scaleTargetRef\", es.Spec.ScaleTargetRef))\n\t\t\tkey := r.InformerManager.GetKey(informer.KeyParams{\n\t\t\t\tNamespace:    req.Namespace,\n\t\t\t\tCRDName:      req.Name,\n\t\t\t\tResourceName: crd.Spec.ScaleTargetRef.Name,\n\t\t\t\tResourceType: k8shelper.KindToResource(crd.Spec.ScaleTargetRef.Kind),\n\t\t\t})\n\t\t\terr := r.InformerManager.StopInformer(key)\n\t\t\tif err != nil {\n\t\t\t\tr.Logger.Error(\"Failed to stop informer for old scaleTargetRef\", zap.String(\"es\", req.String()), zap.Any(\"scaleTargetRef\", es.Spec.ScaleTargetRef), zap.Error(err))\n\t\t\t}\n\t\t\tr.Logger.Debug(\"Resetting mutex for old scaleTargetRef informer\", zap.Any(\"scaleTargetRef\", es.Spec.ScaleTargetRef))\n\t\t\tr.resetMutexForInformer(r.getMutexKeyForTargetRef(req))\n\t\t}\n\t}\n\n\tvar informerErr error\n\tr.getMutexForInformerStart(r.getMutexKeyForTargetRef(req)).Do(func() {\n\t\tgv, err := schema.ParseGroupVersion(es.Spec.ScaleTargetRef.APIVersion)\n\t\tif err != nil {\n\t\t\tinformerErr = fmt.Errorf(\"failed to parse API version: %w\", err)\n\t\t\treturn\n\t\t}\n\t\tif err := r.InformerManager.Add(&informer.RequestWatch{\n\t\t\tReq:               req,\n\t\t\tResourceName:      es.Spec.ScaleTargetRef.Name,\n\t\t\tResourceNamespace: req.Namespace,\n\t\t\tGroupVersionResource: &schema.GroupVersionResource{\n\t\t\t\tGroup:    gv.Group,\n\t\t\t\tVersion:  gv.Version,\n\t\t\t\tResource: k8shelper.KindToResource(es.Spec.ScaleTargetRef.Kind),\n\t\t\t},\n\t\t\tHandlers: r.getScaleTargetRefChangeHandler(ctx, es, req),\n\t\t}); err != nil {\n\t\t\tinformerErr = fmt.Errorf(\"failed to add scaledTargetRef Informer: %w\", err)\n\t\t\treturn\n\t\t}\n\t})\n\tif informerErr != nil {\n\t\treturn informerErr\n\t}\n\treturn nil\n}",
    "start_line": 125,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.watchScaleTargetRef",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchScaleTargetRef"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchPublicService": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchPublicService",
    "name": "ElastiServiceReconciler.watchPublicService",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForPublicSVC",
      "operator.internal.informer.informer.Manager.Add",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getPublicServiceChangeHandler",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexForInformerStart"
    ],
    "source_code": "func (r *ElastiServiceReconciler) watchPublicService(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request) error {\n\tif es.Spec.Service == \"\" {\n\t\treturn fmt.Errorf(\"null value for public service: %w\", k8shelper.ErrNoPublicServiceFound)\n\t}\n\tvar informerErr error\n\tr.getMutexForInformerStart(r.getMutexKeyForPublicSVC(req)).Do(func() {\n\t\tif err := r.InformerManager.Add(&informer.RequestWatch{\n\t\t\tReq:                  req,\n\t\t\tResourceName:         es.Spec.Service,\n\t\t\tResourceNamespace:    es.Namespace,\n\t\t\tGroupVersionResource: &values.ServiceGVR,\n\t\t\tHandlers:             r.getPublicServiceChangeHandler(ctx, es, req),\n\t\t}); err != nil {\n\t\t\tinformerErr = fmt.Errorf(\"failed to add public service Informer: %w\", err)\n\t\t\treturn\n\t\t}\n\t})\n\tif informerErr != nil {\n\t\treturn informerErr\n\t}\n\treturn nil\n}",
    "start_line": 183,
    "end_line": 204,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.watchPublicService",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchPublicService"
  },
  "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRDIfDeleted": {
    "id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRDIfDeleted",
    "name": "ElastiServiceReconciler.finalizeCRDIfDeleted",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsCRD.go",
    "relative_path": "operator/internal/controller/opsCRD.go",
    "depends_on": [
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRD"
    ],
    "source_code": "func (r *ElastiServiceReconciler) finalizeCRDIfDeleted(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request) (isDeleted bool, err error) {\n\t// If the ElastiService is being deleted, we need to clean up the resources\n\tif !es.ObjectMeta.DeletionTimestamp.IsZero() {\n\t\tdefer func() {\n\t\t\te := values.Success\n\t\t\tif err != nil {\n\t\t\t\te = err.Error()\n\t\t\t}\n\t\t\tprom.CRDFinalizerCounter.WithLabelValues(req.String(), e).Inc()\n\t\t}()\n\t\tif controllerutil.ContainsFinalizer(es, v1alpha1.ElastiServiceFinalizer) {\n\t\t\t// If CRD contains finalizer, we call the finaizer function and remove the finalizer post that\n\t\t\tif err = r.finalizeCRD(ctx, es, req); err != nil {\n\t\t\t\treturn true, err\n\t\t\t}\n\t\t\tcontrollerutil.RemoveFinalizer(es, v1alpha1.ElastiServiceFinalizer)\n\t\t\tif err = r.Update(ctx, es); err != nil {\n\t\t\t\treturn true, fmt.Errorf(\"failed to remove finalizer: %w\", err)\n\t\t\t}\n\t\t}\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}",
    "start_line": 206,
    "end_line": 229,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.finalizeCRDIfDeleted",
    "component_id": "operator.internal.controller.opsCRD.ElastiServiceReconciler.finalizeCRDIfDeleted"
  },
  "operator.internal.controller.opsDeployment.ElastiServiceReconciler.handleResolverChanges": {
    "id": "operator.internal.controller.opsDeployment.ElastiServiceReconciler.handleResolverChanges",
    "name": "ElastiServiceReconciler.handleResolverChanges",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsDeployment.go",
    "relative_path": "operator/internal/controller/opsDeployment.go",
    "depends_on": [
      "pkg.config.config.GetResolverConfig",
      "resolver.internal.handler.handler.bufferPool.Get",
      "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver",
      "pkg.k8shelper.utils.UnstructuredToResource"
    ],
    "source_code": "func (r *ElastiServiceReconciler) handleResolverChanges(ctx context.Context, obj interface{}) error {\n\tresolverDeployment := &appsv1.Deployment{}\n\terr := k8shelper.UnstructuredToResource(obj, resolverDeployment)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to convert unstructured to deployment: %w\", err)\n\t}\n\tif resolverDeployment.Name != config.GetResolverConfig().DeploymentName {\n\t\treturn nil\n\t}\n\n\tcrddirectory.CRDDirectory.Services.Range(func(key, value interface{}) bool {\n\t\tcrdDetails := value.(*crddirectory.CRDDetails)\n\t\tif crdDetails.Status.Mode != values.ProxyMode {\n\t\t\treturn true\n\t\t}\n\n\t\t// Extract namespace and service name from the key\n\t\tkeyStr := key.(string)\n\t\tparts := strings.Split(keyStr, \"/\")\n\t\tif len(parts) != 2 {\n\t\t\tr.Logger.Error(\"Invalid key format\", zap.String(\"key\", keyStr))\n\t\t\treturn true\n\t\t}\n\t\tnamespacedName := types.NamespacedName{\n\t\t\tNamespace: parts[0],\n\t\t\tName:      parts[1],\n\t\t}\n\n\t\ttargetService := &v1.Service{}\n\t\tif err := r.Get(ctx, namespacedName, targetService); err != nil {\n\t\t\tr.Logger.Warn(\"Failed to get service to update EndpointSlice\", zap.Error(err))\n\t\t\treturn true\n\t\t}\n\n\t\tif err := r.createOrUpdateEndpointsliceToResolver(ctx, targetService); err != nil {\n\t\t\tr.Logger.Error(\"Failed to update EndpointSlice\",\n\t\t\t\tzap.String(\"service\", crdDetails.CRDName),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t\treturn true\n\t})\n\n\treturn nil\n}",
    "start_line": 18,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.handleResolverChanges",
    "component_id": "operator.internal.controller.opsDeployment.ElastiServiceReconciler.handleResolverChanges"
  },
  "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.getIPsForResolver": {
    "id": "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.getIPsForResolver",
    "name": "ElastiServiceReconciler.getIPsForResolver",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsEndpointslices.go",
    "relative_path": "operator/internal/controller/opsEndpointslices.go",
    "depends_on": [
      "pkg.config.config.GetResolverConfig"
    ],
    "source_code": "func (r *ElastiServiceReconciler) getIPsForResolver(ctx context.Context) ([]string, error) {\n\tresolverSlices := &networkingv1.EndpointSliceList{}\n\tif err := r.List(ctx, resolverSlices, client.MatchingLabels{\n\t\t\"kubernetes.io/service-name\": config.GetResolverConfig().ServiceName,\n\t}); err != nil {\n\t\tr.Logger.Error(\"Failed to get Resolver endpoint slices\", zap.Error(err))\n\t\treturn nil, fmt.Errorf(\"getIPsForResolver: %w\", err)\n\t}\n\tvar resolverPodIPs []string\n\tfor _, endpointSlice := range resolverSlices.Items {\n\t\tfor _, endpoint := range endpointSlice.Endpoints {\n\t\t\tresolverPodIPs = append(resolverPodIPs, endpoint.Addresses...)\n\t\t}\n\t}\n\tif len(resolverPodIPs) == 0 {\n\t\treturn nil, ErrNoResolverPodFound\n\t}\n\treturn resolverPodIPs, nil\n}",
    "start_line": 19,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getIPsForResolver",
    "component_id": "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.getIPsForResolver"
  },
  "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.deleteEndpointsliceToResolver": {
    "id": "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.deleteEndpointsliceToResolver",
    "name": "ElastiServiceReconciler.deleteEndpointsliceToResolver",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsEndpointslices.go",
    "relative_path": "operator/internal/controller/opsEndpointslices.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get",
      "pkg.utils.utils.GetEndpointSliceToResolverName"
    ],
    "source_code": "func (r *ElastiServiceReconciler) deleteEndpointsliceToResolver(ctx context.Context, serviceNamespacedName types.NamespacedName) error {\n\tendpointSlice := &networkingv1.EndpointSlice{}\n\tserviceNamespacedName.Name = utils.GetEndpointSliceToResolverName(serviceNamespacedName.Name)\n\tif err := r.Get(ctx, serviceNamespacedName, endpointSlice); err != nil && !errors.IsNotFound(err) {\n\t\tr.Logger.Error(\"Failed to get endpoint slice\", zap.String(\"service\", serviceNamespacedName.String()), zap.Error(err))\n\t\treturn fmt.Errorf(\"failed to get endpointslice: %w\", err)\n\t} else if errors.IsNotFound(err) {\n\t\treturn nil\n\t}\n\n\tif err := r.Delete(ctx, endpointSlice); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete endpointslice: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 39,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.deleteEndpointsliceToResolver",
    "component_id": "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.deleteEndpointsliceToResolver"
  },
  "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver": {
    "id": "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver",
    "name": "ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsEndpointslices.go",
    "relative_path": "operator/internal/controller/opsEndpointslices.go",
    "depends_on": [
      "pkg.config.config.GetResolverConfig",
      "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.getIPsForResolver",
      "resolver.internal.handler.handler.bufferPool.Get",
      "pkg.utils.utils.GetEndpointSliceToResolverName"
    ],
    "source_code": "func (r *ElastiServiceReconciler) createOrUpdateEndpointsliceToResolver(ctx context.Context, service *v1.Service) error {\n\tresolverPodIPs, err := r.getIPsForResolver(ctx)\n\tif err != nil {\n\t\tr.Logger.Error(\"Failed to get IPs for Resolver\", zap.String(\"service\", service.Name), zap.Error(err))\n\t\treturn err\n\t}\n\n\t// NOTE: Suggestion is to give it a random name in end, to avoid any conflicts, which is rare, but possible.\n\t// In case of random name, we need to store the name in CRD. Right now, we provide a deterministic hashed name.\n\tnewEndpointsliceToResolverName := utils.GetEndpointSliceToResolverName(service.Name)\n\tEndpointsliceNamespacedName := types.NamespacedName{\n\t\tName:      newEndpointsliceToResolverName,\n\t\tNamespace: service.Namespace,\n\t}\n\n\tisResolverSliceFound := false\n\tsliceToResolver := &networkingv1.EndpointSlice{}\n\tif err := r.Get(ctx, EndpointsliceNamespacedName, sliceToResolver); err != nil && !errors.IsNotFound(err) {\n\t\tr.Logger.Debug(\"Error getting a endpoint slice to Resolver\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()), zap.Error(err))\n\t\treturn fmt.Errorf(\"createOrUpdateEndpointsliceToResolver: %w\", err)\n\t} else if errors.IsNotFound(err) {\n\t\t// TODO: This can be handled better\n\t\t// This is a similar case as seen in resolver informer\n\t\t// We can handler this with the same logic as that\n\t\tisResolverSliceFound = false\n\t\tr.Logger.Debug(\"EndpointSlice not found, will try creating one\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()))\n\t} else {\n\t\tisResolverSliceFound = true\n\t\tr.Logger.Debug(\"EndpointSlice Found\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()))\n\t}\n\n\tnewEndpointSlice := &networkingv1.EndpointSlice{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      newEndpointsliceToResolverName,\n\t\t\tNamespace: service.Namespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"kubernetes.io/service-name\": service.Name,\n\t\t\t},\n\t\t},\n\t\tAddressType: networkingv1.AddressTypeIPv4,\n\t\tPorts: []networkingv1.EndpointPort{\n\t\t\t{\n\t\t\t\tName:     ptr.To(service.Spec.Ports[0].Name),\n\t\t\t\tProtocol: ptr.To(v1.ProtocolTCP),\n\t\t\t\t// Make this dynamic too\n\t\t\t\tPort: ptr.To(config.GetResolverConfig().ReverseProxyPort),\n\t\t\t},\n\t\t},\n\t}\n\n\t// sliceToResolver.DeepCopy()\n\n\tfor _, ip := range resolverPodIPs {\n\t\tnewEndpointSlice.Endpoints = append(newEndpointSlice.Endpoints, networkingv1.Endpoint{\n\t\t\tAddresses: []string{ip},\n\t\t})\n\t}\n\n\tif isResolverSliceFound {\n\t\tif err := r.Update(ctx, newEndpointSlice); err != nil {\n\t\t\tr.Logger.Error(\"failed to update sliceToResolver\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()), zap.Error(err))\n\t\t\treturn fmt.Errorf(\"createOrUpdateEndpointsliceToResolver: %w\", err)\n\t\t}\n\t\tr.Logger.Info(\"EndpointSlice updated successfully\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()))\n\t} else {\n\t\t// TODOS: Make sure the private service is owned by the ElastiService\n\t\tif err := r.Create(ctx, newEndpointSlice); err != nil {\n\t\t\tr.Logger.Error(\"failed to create sliceToResolver\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()), zap.Error(err))\n\t\t\treturn fmt.Errorf(\"createOrUpdateEndpointsliceToResolver: %w\", err)\n\t\t}\n\t\tr.Logger.Info(\"EndpointSlice created successfully\", zap.String(\"endpointslice\", EndpointsliceNamespacedName.String()))\n\t}\n\n\treturn nil\n}",
    "start_line": 55,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver",
    "component_id": "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexForInformerStart": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexForInformerStart",
    "name": "ElastiServiceReconciler.getMutexForInformerStart",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) getMutexForInformerStart(key string) *sync.Once {\n\tl, _ := r.InformerStartLocks.LoadOrStore(key, &sync.Once{})\n\treturn l.(*sync.Once)\n}",
    "start_line": 31,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getMutexForInformerStart",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexForInformerStart"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.resetMutexForInformer": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.resetMutexForInformer",
    "name": "ElastiServiceReconciler.resetMutexForInformer",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) resetMutexForInformer(key string) {\n\tr.InformerStartLocks.Delete(key)\n}",
    "start_line": 36,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.resetMutexForInformer",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.resetMutexForInformer"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForPublicSVC": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForPublicSVC",
    "name": "ElastiServiceReconciler.getMutexKeyForPublicSVC",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) getMutexKeyForPublicSVC(req ctrl.Request) string {\n\treturn req.String() + lockKeyPostfixForPublicSVC\n}",
    "start_line": 40,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getMutexKeyForPublicSVC",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForPublicSVC"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForTargetRef": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForTargetRef",
    "name": "ElastiServiceReconciler.getMutexKeyForTargetRef",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) getMutexKeyForTargetRef(req ctrl.Request) string {\n\treturn req.String() + lockKeyPostfixForTargetRef\n}",
    "start_line": 44,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getMutexKeyForTargetRef",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getMutexKeyForTargetRef"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getResolverChangeHandler": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getResolverChangeHandler",
    "name": "ElastiServiceReconciler.getResolverChangeHandler",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [
      "pkg.config.config.GetResolverConfig",
      "operator.internal.controller.opsDeployment.ElastiServiceReconciler.handleResolverChanges"
    ],
    "source_code": "func (r *ElastiServiceReconciler) getResolverChangeHandler(ctx context.Context) cache.ResourceEventHandlerFuncs {\n\treturn cache.ResourceEventHandlerFuncs{\n\t\tAddFunc: func(obj interface{}) {\n\t\t\terr := r.handleResolverChanges(ctx, obj)\n\t\t\tif err != nil {\n\t\t\t\tr.Logger.Error(\"Failed to handle resolver changes\", zap.Error(err))\n\t\t\t}\n\t\t},\n\t\tUpdateFunc: func(_, newObj interface{}) {\n\t\t\terr := r.handleResolverChanges(ctx, newObj)\n\t\t\tif err != nil {\n\t\t\t\tr.Logger.Error(\"Failed to handle resolver changes\", zap.Error(err))\n\t\t\t}\n\t\t},\n\t\tDeleteFunc: func(_ interface{}) {\n\t\t\t// TODO: Handle deletion of resolver deployment\n\t\t\t// We can do two things here\n\t\t\t// 1. We can move to the serve mode\n\t\t\t// 2. We can add a finalizer to the deployent to avoid deletion\n\t\t\t//\n\t\t\t//\n\t\t\t// Another situation is, if the resolver has some issues, and is restarting.\n\t\t\t// In that case, we can wait for the resolver to come back up, and in the meanwhile, we can move to the serve mode\n\t\t\tr.Logger.Warn(\"Resolver deployment deleted\", zap.String(\"deployment_name\", config.GetResolverConfig().DeploymentName))\n\t\t},\n\t}\n}",
    "start_line": 47,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getResolverChangeHandler",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getResolverChangeHandler"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getPublicServiceChangeHandler": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getPublicServiceChangeHandler",
    "name": "ElastiServiceReconciler.getPublicServiceChangeHandler",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [
      "pkg.config.config.GetResolverConfig",
      "operator.internal.informer.informer.Manager.GetKey",
      "operator.internal.controller.opsServices.ElastiServiceReconciler.handlePublicServiceChanges"
    ],
    "source_code": "func (r *ElastiServiceReconciler) getPublicServiceChangeHandler(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request) cache.ResourceEventHandlerFuncs {\n\tkey := r.InformerManager.GetKey(informer.KeyParams{\n\t\tNamespace:    config.GetResolverConfig().Namespace,\n\t\tCRDName:      req.Name,\n\t\tResourceName: es.Spec.Service,\n\t\tResourceType: values.ResourceService,\n\t})\n\n\treturn cache.ResourceEventHandlerFuncs{\n\t\tAddFunc: func(obj interface{}) {\n\t\t\terrStr := values.Success\n\t\t\terr := r.handlePublicServiceChanges(ctx, obj, es.Spec.Service, req.Namespace)\n\t\t\tif err != nil {\n\t\t\t\terrStr = err.Error()\n\t\t\t\tr.Logger.Error(\"Failed to handle public service changes\", zap.Error(err))\n\t\t\t} else {\n\t\t\t\tr.Logger.Info(\"Public service added\", zap.String(\"service\", es.Spec.Service), zap.String(\"es\", req.String()))\n\t\t\t}\n\t\t\tprom.InformerHandlerCounter.WithLabelValues(req.String(), key, errStr).Inc()\n\t\t},\n\t\tUpdateFunc: func(_, newObj interface{}) {\n\t\t\terrStr := values.Success\n\t\t\terr := r.handlePublicServiceChanges(ctx, newObj, es.Spec.Service, req.Namespace)\n\t\t\tif err != nil {\n\t\t\t\terrStr = err.Error()\n\t\t\t\tr.Logger.Error(\"Failed to handle public service changes\", zap.Error(err))\n\t\t\t} else {\n\t\t\t\tr.Logger.Info(\"Public service updated\", zap.String(\"service\", es.Spec.Service), zap.String(\"es\", req.String()))\n\t\t\t}\n\t\t\tprom.InformerHandlerCounter.WithLabelValues(req.String(), key, errStr).Inc()\n\t\t},\n\t\tDeleteFunc: func(_ interface{}) {\n\t\t\tr.Logger.Debug(\"public deployment deleted\",\n\t\t\t\tzap.String(\"es\", req.String()),\n\t\t\t\tzap.String(\"service\", es.Spec.Service))\n\t\t},\n\t}\n}",
    "start_line": 75,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getPublicServiceChangeHandler",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getPublicServiceChangeHandler"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getScaleTargetRefChangeHandler": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getScaleTargetRefChangeHandler",
    "name": "ElastiServiceReconciler.getScaleTargetRefChangeHandler",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.GetKey",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.handleScaleTargetRefChanges"
    ],
    "source_code": "func (r *ElastiServiceReconciler) getScaleTargetRefChangeHandler(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request) cache.ResourceEventHandlerFuncs {\n\tkey := r.InformerManager.GetKey(informer.KeyParams{\n\t\tNamespace:    req.Namespace,\n\t\tCRDName:      req.Name,\n\t\tResourceName: es.Spec.ScaleTargetRef.Name,\n\t\tResourceType: es.Spec.ScaleTargetRef.Kind,\n\t})\n\treturn cache.ResourceEventHandlerFuncs{\n\t\tUpdateFunc: func(_, obj interface{}) {\n\t\t\terrStr := values.Success\n\t\t\terr := r.handleScaleTargetRefChanges(ctx, es, req, obj)\n\t\t\tif err != nil {\n\t\t\t\terrStr = err.Error()\n\t\t\t\tr.Logger.Error(\"Failed to handle ScaleTargetRef changes\", zap.Error(err))\n\t\t\t} else {\n\t\t\t\tr.Logger.Info(\"ScaleTargetRef updated\", zap.String(\"es\", req.String()), zap.String(\"scaleTargetRef\", es.Spec.ScaleTargetRef.Name))\n\t\t\t}\n\n\t\t\tprom.InformerHandlerCounter.WithLabelValues(req.String(), key, errStr).Inc()\n\t\t},\n\t}\n}",
    "start_line": 114,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getScaleTargetRefChangeHandler",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getScaleTargetRefChangeHandler"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.handleScaleTargetRefChanges": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.handleScaleTargetRefChanges",
    "name": "ElastiServiceReconciler.handleScaleTargetRefChanges",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.isTargetReady",
      "operator.internal.controller.opsInformer.ElastiServiceReconciler.getUpdateObjInfo",
      "operator.internal.controller.opsModes.ElastiServiceReconciler.switchMode"
    ],
    "source_code": "func (r *ElastiServiceReconciler) handleScaleTargetRefChanges(ctx context.Context, es *v1alpha1.ElastiService, req ctrl.Request, obj interface{}) error {\n\tr.Logger.Info(\"ScaleTargetRef changes detected\", zap.String(\"es\", req.String()), zap.Any(\"scaleTargetRef\", es.Spec.ScaleTargetRef))\n\n\t// Gather target object info (replicas, selector) from the updated resource\n\tupdatedObj, err := r.getUpdateObjInfo(ctx, obj, req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get scale for target resource: %w\", err)\n\t}\n\n\t// Extract replica information from the resource\n\tready, err := r.isTargetReady(ctx, updatedObj)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get target ready status: %w\", err)\n\t}\n\n\t// Determine mode based on replica status\n\t// If NOT ready, switch to proxy mode\n\t// else, switch to serve mode\n\tif !ready {\n\t\tr.Logger.Info(\"ScaleTargetRef has 0 replicas or not ready, switching to proxy mode\",\n\t\t\tzap.String(\"kind\", es.Spec.ScaleTargetRef.Kind),\n\t\t\tzap.String(\"name\", es.Spec.ScaleTargetRef.Name),\n\t\t\tzap.String(\"es\", req.String()))\n\t\tif err := r.switchMode(ctx, req, values.ProxyMode); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to switch to proxy mode: %w\", err)\n\t\t}\n\t} else {\n\t\tr.Logger.Info(\"ScaleTargetRef has ready replicas and is healthy, switching to serve mode\",\n\t\t\tzap.String(\"kind\", es.Spec.ScaleTargetRef.Kind),\n\t\t\tzap.String(\"name\", es.Spec.ScaleTargetRef.Name),\n\t\t\tzap.String(\"es\", req.String()))\n\t\tif err := r.switchMode(ctx, req, values.ServeMode); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to switch to serve mode: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}",
    "start_line": 137,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.handleScaleTargetRefChanges",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.handleScaleTargetRefChanges"
  },
  "operator.internal.controller.opsInformer.updateObjInfo": {
    "id": "operator.internal.controller.opsInformer.updateObjInfo",
    "name": "updateObjInfo",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "type updateObjInfo struct {\n\tspecReplicas   int64\n\tstatusReplicas int64\n\tselector       map[string]interface{}\n\tnamespace      string\n\tname           string\n}",
    "start_line": 176,
    "end_line": 182,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct updateObjInfo",
    "component_id": "operator.internal.controller.opsInformer.updateObjInfo"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.getUpdateObjInfo": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getUpdateObjInfo",
    "name": "ElastiServiceReconciler.getUpdateObjInfo",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) getUpdateObjInfo(_ context.Context, obj interface{}, req ctrl.Request) (*updateObjInfo, error) {\n\t// Convert to unstructured to work with any resource type\n\tobjInfo, ok := obj.(*unstructured.Unstructured)\n\tif !ok {\n\t\tr.Logger.Error(\"Failed to convert ScaleTargetRef to unstructured\")\n\t\treturn nil, fmt.Errorf(\"failed to convert ScaleTargetRef to unstructured\")\n\t}\n\n\tscaleObj := &updateObjInfo{\n\t\tspecReplicas:   0,\n\t\tstatusReplicas: 0,\n\t\tselector:       nil,\n\t\tnamespace:      req.Namespace,\n\t\tname:           req.Name,\n\t}\n\n\tspecReplicasVal, found, err := unstructured.NestedInt64(objInfo.Object, \"spec\", \"replicas\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get replicas from spec, %w\", err)\n\t} else if !found {\n\t\t// If replicas are not found and no error, we can assume the resource is not ready\n\t\tr.Logger.Warn(\"spec replicas not found\")\n\t\treturn scaleObj, nil\n\t}\n\tscaleObj.specReplicas = specReplicasVal\n\n\tstatusReplicasVal, found, err := unstructured.NestedInt64(objInfo.Object, \"status\", \"replicas\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get replicas from spec, %w\", err)\n\t} else if !found {\n\t\t// If replicas are not found and no error, we can assume the resource is not ready\n\t\tr.Logger.Warn(\"status replicas not found\")\n\t\treturn scaleObj, nil\n\t}\n\tscaleObj.statusReplicas = statusReplicasVal\n\n\tselectorVal, found, err := unstructured.NestedMap(objInfo.Object, \"spec\", \"selector\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get selector from spec, %w\", err)\n\t} else if !found {\n\t\t// If selector is not found and no error, we can assume the resource is not ready\n\t\tr.Logger.Warn(\"selector not found\")\n\t\treturn scaleObj, nil\n\t}\n\tscaleObj.selector = selectorVal\n\n\treturn scaleObj, nil\n}",
    "start_line": 184,
    "end_line": 231,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getUpdateObjInfo",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.getUpdateObjInfo"
  },
  "operator.internal.controller.opsInformer.ElastiServiceReconciler.isTargetReady": {
    "id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.isTargetReady",
    "name": "ElastiServiceReconciler.isTargetReady",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsInformer.go",
    "relative_path": "operator/internal/controller/opsInformer.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) isTargetReady(ctx context.Context, obj *updateObjInfo) (bool, error) {\n\tif obj.specReplicas <= 0 || obj.statusReplicas <= 0 {\n\t\treturn false, nil\n\t} else if obj.selector == nil {\n\t\tr.Logger.Warn(\"selector is empty\", zap.Any(\"obj\", obj))\n\t\treturn false, nil\n\t}\n\n\tlabelSelector := &metav1.LabelSelector{}\n\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(obj.selector, labelSelector); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to convert selector map to LabelSelector, %w\", err)\n\t}\n\n\t// Get ready replicas of a pod using selector and namespace\n\tselector, err := metav1.LabelSelectorAsSelector(labelSelector)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to convert label selector to selector, %w\", err)\n\t}\n\n\tpodList := &corev1.PodList{}\n\tlistOptions := []client.ListOption{\n\t\tclient.InNamespace(obj.namespace),\n\t\tclient.MatchingLabelsSelector{Selector: selector},\n\t}\n\n\tif err := r.List(ctx, podList, listOptions...); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to list pods for label selector, %w\", err)\n\t}\n\n\t// Default to healthy unless we have specific health checks\n\tready := false\n\tfor _, pod := range podList.Items {\n\t\t// Skip terminating pods\n\t\tif pod.DeletionTimestamp != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, condition := range pod.Status.Conditions {\n\t\t\tif condition.Type == corev1.PodReady && condition.Status == corev1.ConditionTrue {\n\t\t\t\tready = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif ready {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ready, nil\n}",
    "start_line": 234,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.isTargetReady",
    "component_id": "operator.internal.controller.opsInformer.ElastiServiceReconciler.isTargetReady"
  },
  "operator.internal.controller.opsModes.ElastiServiceReconciler.getMutexForSwitchMode": {
    "id": "operator.internal.controller.opsModes.ElastiServiceReconciler.getMutexForSwitchMode",
    "name": "ElastiServiceReconciler.getMutexForSwitchMode",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsModes.go",
    "relative_path": "operator/internal/controller/opsModes.go",
    "depends_on": [],
    "source_code": "func (r *ElastiServiceReconciler) getMutexForSwitchMode(key string) *sync.Mutex {\n\tl, _ := r.SwitchModeLocks.LoadOrStore(key, &sync.Mutex{})\n\treturn l.(*sync.Mutex)\n}",
    "start_line": 18,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.getMutexForSwitchMode",
    "component_id": "operator.internal.controller.opsModes.ElastiServiceReconciler.getMutexForSwitchMode"
  },
  "operator.internal.controller.opsModes.ElastiServiceReconciler.switchMode": {
    "id": "operator.internal.controller.opsModes.ElastiServiceReconciler.switchMode",
    "name": "ElastiServiceReconciler.switchMode",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsModes.go",
    "relative_path": "operator/internal/controller/opsModes.go",
    "depends_on": [
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.updateCRDStatus",
      "operator.internal.controller.opsModes.ElastiServiceReconciler.getMutexForSwitchMode",
      "operator.internal.controller.opsModes.ElastiServiceReconciler.enableServeMode",
      "operator.internal.controller.opsModes.ElastiServiceReconciler.enableProxyMode",
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.getCRD"
    ],
    "source_code": "func (r *ElastiServiceReconciler) switchMode(ctx context.Context, req ctrl.Request, mode string) error {\n\t{\n\t\tr.Logger.Debug(fmt.Sprintf(\"[Switching to %s Mode]\", strings.ToUpper(mode)), zap.String(\"es\", req.NamespacedName.String()))\n\t\tmutex := r.getMutexForSwitchMode(req.NamespacedName.String())\n\t\tmutex.Lock()\n\t\tdefer mutex.Unlock()\n\t}\n\n\tes, err := r.getCRD(ctx, req.NamespacedName)\n\tif err != nil {\n\t\tr.Logger.Error(\"Failed to get CRD\", zap.String(\"es\", req.NamespacedName.String()), zap.Error(err))\n\t\treturn fmt.Errorf(\"failed to get CRD: %w\", err)\n\t}\n\n\t//nolint: errcheck\n\tdefer r.updateCRDStatus(ctx, req.NamespacedName, mode)\n\tswitch mode {\n\tcase values.ServeMode:\n\t\tif err = r.enableServeMode(ctx, es); err != nil {\n\t\t\tr.Logger.Error(\"Failed to enable SERVE mode\", zap.String(\"es\", req.NamespacedName.String()), zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t\tr.Logger.Info(\"[SERVE mode enabled]\", zap.String(\"es\", req.NamespacedName.String()))\n\tcase values.ProxyMode:\n\t\tif err = r.enableProxyMode(ctx, req, es); err != nil {\n\t\t\tr.Logger.Error(\"Failed to enable PROXY mode\", zap.String(\"es\", req.NamespacedName.String()), zap.Error(err))\n\t\t\treturn err\n\t\t}\n\t\tr.Logger.Info(\"[PROXY mode enabled]\", zap.String(\"es\", req.NamespacedName.String()))\n\tdefault:\n\t\tr.Logger.Error(\"Invalid mode\", zap.String(\"mode\", mode), zap.String(\"es\", req.NamespacedName.String()))\n\t}\n\treturn nil\n}",
    "start_line": 23,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.switchMode",
    "component_id": "operator.internal.controller.opsModes.ElastiServiceReconciler.switchMode"
  },
  "operator.internal.controller.opsModes.ElastiServiceReconciler.enableProxyMode": {
    "id": "operator.internal.controller.opsModes.ElastiServiceReconciler.enableProxyMode",
    "name": "ElastiServiceReconciler.enableProxyMode",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsModes.go",
    "relative_path": "operator/internal/controller/opsModes.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get",
      "operator.internal.controller.opsCRD.ElastiServiceReconciler.watchPublicService",
      "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.createOrUpdateEndpointsliceToResolver",
      "operator.internal.controller.opsServices.ElastiServiceReconciler.checkAndCreatePrivateService"
    ],
    "source_code": "func (r *ElastiServiceReconciler) enableProxyMode(ctx context.Context, req ctrl.Request, es *v1alpha1.ElastiService) error {\n\ttargetNamespacedName := types.NamespacedName{\n\t\tName:      es.Spec.Service,\n\t\tNamespace: es.Namespace,\n\t}\n\ttargetSVC := &v1.Service{}\n\tif err := r.Get(ctx, targetNamespacedName, targetSVC); err != nil {\n\t\treturn fmt.Errorf(\"failed to get target service: %w\", err)\n\t}\n\tPVTName, err := r.checkAndCreatePrivateService(ctx, targetSVC, es)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to check and create private service: %w\", err)\n\t}\n\tr.Logger.Info(\"1. Checked and created private service\", zap.String(\"public service\", targetSVC.Name), zap.String(\"private service\", PVTName))\n\n\tif err = r.createOrUpdateEndpointsliceToResolver(ctx, targetSVC); err != nil {\n\t\treturn fmt.Errorf(\"failed to create or update endpointslice to resolver: %w \", err)\n\t}\n\tr.Logger.Info(\"2. Created or updated endpointslice to resolver\", zap.String(\"service\", targetSVC.Name))\n\n\t// Check if Public Service is present, and has not changed from the values in CRDDirectory\n\tif err := r.watchPublicService(ctx, es, req); err != nil {\n\t\treturn fmt.Errorf(\"failed to add watch on public service: %w\", err)\n\t}\n\tr.Logger.Info(\"3. Added watch on public service\", zap.String(\"service\", targetSVC.Name))\n\n\treturn nil\n}",
    "start_line": 59,
    "end_line": 86,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.enableProxyMode",
    "component_id": "operator.internal.controller.opsModes.ElastiServiceReconciler.enableProxyMode"
  },
  "operator.internal.controller.opsModes.ElastiServiceReconciler.enableServeMode": {
    "id": "operator.internal.controller.opsModes.ElastiServiceReconciler.enableServeMode",
    "name": "ElastiServiceReconciler.enableServeMode",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsModes.go",
    "relative_path": "operator/internal/controller/opsModes.go",
    "depends_on": [
      "operator.internal.controller.opsEndpointslices.ElastiServiceReconciler.deleteEndpointsliceToResolver"
    ],
    "source_code": "func (r *ElastiServiceReconciler) enableServeMode(ctx context.Context, es *v1alpha1.ElastiService) error {\n\ttargetNamespacedName := types.NamespacedName{\n\t\tName:      es.Spec.Service,\n\t\tNamespace: es.Namespace,\n\t}\n\tif err := r.deleteEndpointsliceToResolver(ctx, targetNamespacedName); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete endpointslice to resolver: %w\", err)\n\t}\n\tr.Logger.Info(\"1. Deleted endpointslice to resolver\", zap.String(\"service\", targetNamespacedName.String()))\n\treturn nil\n}",
    "start_line": 88,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.enableServeMode",
    "component_id": "operator.internal.controller.opsModes.ElastiServiceReconciler.enableServeMode"
  },
  "operator.internal.controller.opsServices.ElastiServiceReconciler.deletePrivateService": {
    "id": "operator.internal.controller.opsServices.ElastiServiceReconciler.deletePrivateService",
    "name": "ElastiServiceReconciler.deletePrivateService",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsServices.go",
    "relative_path": "operator/internal/controller/opsServices.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get",
      "pkg.utils.utils.GetPrivateServiceName"
    ],
    "source_code": "func (r *ElastiServiceReconciler) deletePrivateService(ctx context.Context, publichServiceNamespacedName types.NamespacedName) (err error) {\n\tprivateServiceNamespacedName := publichServiceNamespacedName\n\tprivateServiceNamespacedName.Name = utils.GetPrivateServiceName(publichServiceNamespacedName.Name)\n\tprivateSVC := &v1.Service{}\n\tif err := r.Get(ctx, privateServiceNamespacedName, privateSVC); err != nil && !errors.IsNotFound(err) {\n\t\treturn fmt.Errorf(\"failed to get private service: %w\", err)\n\t} else if errors.IsNotFound(err) {\n\t\treturn nil\n\t}\n\n\tif err := r.Delete(ctx, privateSVC); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete private service: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 18,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.deletePrivateService",
    "component_id": "operator.internal.controller.opsServices.ElastiServiceReconciler.deletePrivateService"
  },
  "operator.internal.controller.opsServices.ElastiServiceReconciler.checkAndCreatePrivateService": {
    "id": "operator.internal.controller.opsServices.ElastiServiceReconciler.checkAndCreatePrivateService",
    "name": "ElastiServiceReconciler.checkAndCreatePrivateService",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsServices.go",
    "relative_path": "operator/internal/controller/opsServices.go",
    "depends_on": [
      "operator.api.v1alpha1.zz_generated.deepcopy.AutoscalerSpec.DeepCopy",
      "resolver.internal.handler.handler.bufferPool.Get",
      "pkg.utils.utils.GetPrivateServiceName"
    ],
    "source_code": "func (r *ElastiServiceReconciler) checkAndCreatePrivateService(ctx context.Context, publicSVC *v1.Service, es *v1alpha1.ElastiService) (privateServiceName string, err error) {\n\tprivateServiceName = utils.GetPrivateServiceName(publicSVC.Name)\n\tprivateServiceNamespacedName := types.NamespacedName{Name: privateServiceName, Namespace: publicSVC.Namespace}\n\t// See if private service already exist\n\tprivateSVC := &v1.Service{}\n\tif err := r.Get(ctx, privateServiceNamespacedName, privateSVC); err != nil && !errors.IsNotFound(err) {\n\t\tr.Logger.Error(\"Failed to get private service\", zap.Error(err))\n\t} else if errors.IsNotFound(err) {\n\t\tr.Logger.Info(\"Private service not found, creating one\", zap.String(\"private-service\", privateServiceNamespacedName.String()))\n\t} else {\n\t\tr.Logger.Info(\"Private service already exists\", zap.String(\"private-service\", privateServiceNamespacedName.String()))\n\t\treturn privateServiceName, nil\n\t}\n\n\tprivateSVC = publicSVC.DeepCopy()\n\tprivateSVC.SetName(privateServiceName)\n\t// We must remove the cluster IP and node port, as it already exists for the public service\n\tprivateSVC.Spec.ClusterIP = \"\"\n\tprivateSVC.Spec.ClusterIPs = nil\n\tfor port := range privateSVC.Spec.Ports {\n\t\tprivateSVC.Spec.Ports[port].NodePort = 0\n\t}\n\t// We also need to remove the resourceVersion\n\tprivateSVC.ResourceVersion = \"\"\n\n\t// Make sure the private service is owned by the ElastiService\n\tif err := controllerutil.SetControllerReference(es, privateSVC, r.Scheme); err != nil {\n\t\treturn privateServiceName, fmt.Errorf(\"checkAndCreatePrivateService: %w\", err)\n\t}\n\terr = r.Create(ctx, privateSVC)\n\tif err != nil {\n\t\tr.Logger.Error(\"Failed to create private service\", zap.String(\"private-service\", privateServiceNamespacedName.String()), zap.Error(err))\n\t\treturn privateServiceName, fmt.Errorf(\"checkAndCreatePrivateService: %w\", err)\n\t}\n\treturn privateServiceName, nil\n}",
    "start_line": 34,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.checkAndCreatePrivateService",
    "component_id": "operator.internal.controller.opsServices.ElastiServiceReconciler.checkAndCreatePrivateService"
  },
  "operator.internal.controller.opsServices.ElastiServiceReconciler.handlePublicServiceChanges": {
    "id": "operator.internal.controller.opsServices.ElastiServiceReconciler.handlePublicServiceChanges",
    "name": "ElastiServiceReconciler.handlePublicServiceChanges",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/opsServices.go",
    "relative_path": "operator/internal/controller/opsServices.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get",
      "pkg.k8shelper.utils.UnstructuredToResource",
      "pkg.utils.utils.GetPrivateServiceName"
    ],
    "source_code": "func (r *ElastiServiceReconciler) handlePublicServiceChanges(ctx context.Context, obj interface{}, serviceName, _ string) error {\n\tpublicSVC := &v1.Service{}\n\terr := k8shelper.UnstructuredToResource(obj, publicSVC)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to convert unstructured to service: %w\", err)\n\t}\n\n\t// Check if the service is same as mentioned in CRD\n\tif publicSVC.Name != serviceName {\n\t\treturn fmt.Errorf(\"public service is not same as mentioned in CRD; informer misconfigured\")\n\t}\n\t// Get Private Service\n\tPVTName := utils.GetPrivateServiceName(publicSVC.Name)\n\tprivateServiceNamespacedName := types.NamespacedName{Name: PVTName, Namespace: publicSVC.Namespace}\n\tprivateSVC := &v1.Service{}\n\tif err := r.Get(ctx, privateServiceNamespacedName, privateSVC); err != nil && !errors.IsNotFound(err) {\n\t\treturn fmt.Errorf(\"failed to get private service: %w\", err)\n\t} else if errors.IsNotFound(err) {\n\t\treturn fmt.Errorf(\"private service not found: %w\", err)\n\t}\n\n\t// Sync the changes in private service\n\tprivateSVC.Spec.Selector = publicSVC.Spec.Selector\n\tprivateSVC.Spec.Ports = make([]v1.ServicePort, len(publicSVC.Spec.Ports))\n\tcopy(privateSVC.Spec.Ports, publicSVC.Spec.Ports)\n\tfor port := range privateSVC.Spec.Ports {\n\t\tprivateSVC.Spec.Ports[port].NodePort = 0\n\t}\n\n\t// Update the private service\n\tif err := r.Update(ctx, privateSVC); err != nil {\n\t\treturn fmt.Errorf(\"failed to update private service: %w\", err)\n\t}\n\n\treturn nil\n}",
    "start_line": 72,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ElastiServiceReconciler.handlePublicServiceChanges",
    "component_id": "operator.internal.controller.opsServices.ElastiServiceReconciler.handlePublicServiceChanges"
  },
  "operator.internal.controller.suite_test.TestControllers": {
    "id": "operator.internal.controller.suite_test.TestControllers",
    "name": "TestControllers",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/controller/suite_test.go",
    "relative_path": "operator/internal/controller/suite_test.go",
    "depends_on": [],
    "source_code": "func TestControllers(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Controller Suite\", Label(\"controller\"))\n}",
    "start_line": 59,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function TestControllers",
    "component_id": "operator.internal.controller.suite_test.TestControllers"
  },
  "operator.internal.crddirectory.directory.Directory": {
    "id": "operator.internal.crddirectory.directory.Directory",
    "name": "Directory",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/crddirectory/directory.go",
    "relative_path": "operator/internal/crddirectory/directory.go",
    "depends_on": [],
    "source_code": "type Directory struct {\n\tServices sync.Map\n\tLogger   *zap.Logger\n}",
    "start_line": 11,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Directory",
    "component_id": "operator.internal.crddirectory.directory.Directory"
  },
  "operator.internal.crddirectory.directory.CRDDetails": {
    "id": "operator.internal.crddirectory.directory.CRDDetails",
    "name": "CRDDetails",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/crddirectory/directory.go",
    "relative_path": "operator/internal/crddirectory/directory.go",
    "depends_on": [],
    "source_code": "type CRDDetails struct {\n\tCRDName string\n\tSpec    v1alpha1.ElastiServiceSpec\n\tStatus  v1alpha1.ElastiServiceStatus\n}",
    "start_line": 16,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct CRDDetails",
    "component_id": "operator.internal.crddirectory.directory.CRDDetails"
  },
  "operator.internal.crddirectory.directory.InitDirectory": {
    "id": "operator.internal.crddirectory.directory.InitDirectory",
    "name": "InitDirectory",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/crddirectory/directory.go",
    "relative_path": "operator/internal/crddirectory/directory.go",
    "depends_on": [],
    "source_code": "func InitDirectory(logger *zap.Logger) {\n\tdirectoryMutexOnce.Do(func() {\n\t\tCRDDirectory = &Directory{\n\t\t\tLogger: logger.Named(\"CRDDirectory\"),\n\t\t}\n\t})\n}",
    "start_line": 26,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function InitDirectory",
    "component_id": "operator.internal.crddirectory.directory.InitDirectory"
  },
  "operator.internal.crddirectory.directory.AddCRD": {
    "id": "operator.internal.crddirectory.directory.AddCRD",
    "name": "AddCRD",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/crddirectory/directory.go",
    "relative_path": "operator/internal/crddirectory/directory.go",
    "depends_on": [],
    "source_code": "func AddCRD(serviceName string, crdDetails *CRDDetails) {\n\tif CRDDirectory == nil {\n\t\tpanic(\"CRDDirectory not initialized\")\n\t}\n\tCRDDirectory.Services.Store(serviceName, crdDetails)\n}",
    "start_line": 34,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function AddCRD",
    "component_id": "operator.internal.crddirectory.directory.AddCRD"
  },
  "operator.internal.crddirectory.directory.RemoveCRD": {
    "id": "operator.internal.crddirectory.directory.RemoveCRD",
    "name": "RemoveCRD",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/crddirectory/directory.go",
    "relative_path": "operator/internal/crddirectory/directory.go",
    "depends_on": [],
    "source_code": "func RemoveCRD(serviceName string) {\n\tif CRDDirectory == nil {\n\t\tpanic(\"CRDDirectory not initialized\")\n\t}\n\tCRDDirectory.Services.Delete(serviceName)\n}",
    "start_line": 41,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function RemoveCRD",
    "component_id": "operator.internal.crddirectory.directory.RemoveCRD"
  },
  "operator.internal.crddirectory.directory.GetCRD": {
    "id": "operator.internal.crddirectory.directory.GetCRD",
    "name": "GetCRD",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/crddirectory/directory.go",
    "relative_path": "operator/internal/crddirectory/directory.go",
    "depends_on": [],
    "source_code": "func GetCRD(serviceName string) (*CRDDetails, bool) {\n\tif CRDDirectory == nil {\n\t\tpanic(\"CRDDirectory not initialized\")\n\t}\n\tvalue, ok := CRDDirectory.Services.Load(serviceName)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\tCRDDirectory.Logger.Info(\"Service found in directory\", zap.String(\"service\", serviceName))\n\treturn value.(*CRDDetails), true\n}",
    "start_line": 48,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function GetCRD",
    "component_id": "operator.internal.crddirectory.directory.GetCRD"
  },
  "operator.internal.elastiserver.elastiServer.Server": {
    "id": "operator.internal.elastiserver.elastiServer.Server",
    "name": "Server",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/elastiserver/elastiServer.go",
    "relative_path": "operator/internal/elastiserver/elastiServer.go",
    "depends_on": [],
    "source_code": "type (\n\tResponse struct {\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// Server is used to receive communication from Resolver, or any future components\n\t// It is used by components about certain events, like when resolver receive the request\n\t// for a service, that service is scaled up if it's at 0 replicas\n\tServer struct {\n\t\tlogger       *zap.Logger\n\t\tscaleHandler *scaling.ScaleHandler\n\t\t// rescaleDuration is the duration to wait before checking to rescaling the target\n\t\trescaleDuration time.Duration\n\t}\n)",
    "start_line": 28,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Server",
    "component_id": "operator.internal.elastiserver.elastiServer.Server"
  },
  "operator.internal.elastiserver.elastiServer.NewServer": {
    "id": "operator.internal.elastiserver.elastiServer.NewServer",
    "name": "NewServer",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/elastiserver/elastiServer.go",
    "relative_path": "operator/internal/elastiserver/elastiServer.go",
    "depends_on": [],
    "source_code": "func NewServer(logger *zap.Logger, scaleHandler *scaling.ScaleHandler, rescaleDuration time.Duration) *Server {\n\t// Get Ops client\n\treturn &Server{\n\t\tlogger:       logger.Named(\"elastiServer\"),\n\t\tscaleHandler: scaleHandler,\n\t\t// rescaleDuration is the duration to wait before checking to rescaling the target\n\t\trescaleDuration: rescaleDuration,\n\t}\n}",
    "start_line": 44,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewServer",
    "component_id": "operator.internal.elastiserver.elastiServer.NewServer"
  },
  "operator.internal.elastiserver.elastiServer.Server.Start": {
    "id": "operator.internal.elastiserver.elastiServer.Server.Start",
    "name": "Server.Start",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/elastiserver/elastiServer.go",
    "relative_path": "operator/internal/elastiserver/elastiServer.go",
    "depends_on": [],
    "source_code": "func (s *Server) Start(port string) error {\n\tmux := http.NewServeMux()\n\tsentryHandler := sentryhttp.New(sentryhttp.Options{})\n\tmux.Handle(\"/metrics\", sentryHandler.Handle(promhttp.Handler()))\n\tmux.Handle(\"/informer/incoming-request\", sentryHandler.HandleFunc(s.resolverReqHandler))\n\n\tserver := &http.Server{\n\t\tAddr:              fmt.Sprintf(\":%s\", strings.TrimPrefix(port, \":\")),\n\t\tHandler:           mux,\n\t\tReadHeaderTimeout: 2 * time.Second,\n\t\tReadTimeout:       30 * time.Second,\n\t\tWriteTimeout:      30 * time.Second,\n\t}\n\n\t// Graceful shutdown handling\n\tdone := make(chan bool)\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-quit\n\t\ts.logger.Info(\"Server is shutting down...\")\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n\t\tdefer cancel()\n\n\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\ts.logger.Error(\"Could not gracefully shutdown the server\", zap.Error(err))\n\t\t}\n\t\tclose(done)\n\t}()\n\n\ts.logger.Info(\"Starting ElastiServer\", zap.String(\"port\", port))\n\tif err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\ts.logger.Error(\"Failed to start ElastiServer\", zap.Error(err))\n\t\treturn fmt.Errorf(\"failed to start ElastiServer: %w\", err)\n\t}\n\n\t<-done\n\ts.logger.Info(\"Server stopped\")\n\treturn nil\n}",
    "start_line": 55,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Server.Start",
    "component_id": "operator.internal.elastiserver.elastiServer.Server.Start"
  },
  "operator.internal.elastiserver.elastiServer.Server.resolverReqHandler": {
    "id": "operator.internal.elastiserver.elastiServer.Server.resolverReqHandler",
    "name": "Server.resolverReqHandler",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/elastiserver/elastiServer.go",
    "relative_path": "operator/internal/elastiserver/elastiServer.go",
    "depends_on": [
      "operator.internal.elastiserver.elastiServer.Server.scaleTargetForService",
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close",
      "resolver.internal.handler.writer.responseWriter.WriteHeader",
      "resolver.internal.handler.writer.responseWriter.Header",
      "pkg.logger.logger.CustomCore.Write"
    ],
    "source_code": "func (s *Server) resolverReqHandler(w http.ResponseWriter, req *http.Request) {\n\tdefer func() {\n\t\tif err := req.Body.Close(); err != nil {\n\t\t\ts.logger.Error(\"Failed to close request body\", zap.Error(err))\n\t\t}\n\t}()\n\n\tif req.Method != http.MethodPost {\n\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\tvar body messages.RequestCount\n\tif err := json.NewDecoder(req.Body).Decode(&body); err != nil {\n\t\ts.logger.Error(\"Failed to decode request body\", zap.Error(err))\n\t\thttp.Error(w, \"Invalid request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ts.logger.Info(\"Received request from Resolver\", zap.Any(\"body\", body))\n\n\tresponse := Response{\n\t\tMessage: \"Request received successfully!\",\n\t}\n\tjsonResponse, err := json.Marshal(response)\n\tif err != nil {\n\t\ts.logger.Error(\"Failed to marshal response\", zap.Error(err))\n\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\n\tif _, err = w.Write(jsonResponse); err != nil {\n\t\ts.logger.Error(\"Failed to write response\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif err = s.scaleTargetForService(req.Context(), body.Svc, body.Namespace); err != nil {\n\t\ts.logger.Error(\"Failed to scale target\",\n\t\t\tzap.Error(err),\n\t\t\tzap.String(\"service\", body.Svc),\n\t\t\tzap.String(\"namespace\", body.Namespace))\n\t\treturn\n\t}\n\n\ts.logger.Info(\"Request fulfilled successfully\",\n\t\tzap.String(\"service\", body.Svc),\n\t\tzap.String(\"namespace\", body.Namespace))\n}",
    "start_line": 98,
    "end_line": 147,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Server.resolverReqHandler",
    "component_id": "operator.internal.elastiserver.elastiServer.Server.resolverReqHandler"
  },
  "operator.internal.elastiserver.elastiServer.Server.scaleTargetForService": {
    "id": "operator.internal.elastiserver.elastiServer.Server.scaleTargetForService",
    "name": "Server.scaleTargetForService",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/elastiserver/elastiServer.go",
    "relative_path": "operator/internal/elastiserver/elastiServer.go",
    "depends_on": [
      "pkg.scaling.scale_handler.ScaleHandler.Scale",
      "pkg.scaling.scale_handler.ScaleHandler.UpdateLastScaledUpTime",
      "operator.internal.crddirectory.directory.GetCRD",
      "operator.api.v1alpha1.elastiservice_types.ElastiServiceSpec.GetScaleTargetRef",
      "pkg.scaling.scale_handler.ScaleHandler.UpdateKedaScaledObjectPausedState",
      "pkg.k8shelper.utils.APIVersionStrToGVK"
    ],
    "source_code": "func (s *Server) scaleTargetForService(ctx context.Context, serviceName, namespace string) error {\n\tnamespacedName := types.NamespacedName{Namespace: namespace, Name: serviceName}\n\n\tdefer s.logger.Debug(\"Scale target lock released\", zap.String(\"service\", namespacedName.String()))\n\ts.logger.Debug(\"Scale target lock taken\", zap.String(\"service\", namespacedName.String()))\n\n\tcrd, found := crddirectory.GetCRD(namespacedName.String())\n\tif !found {\n\t\treturn fmt.Errorf(\"scaleTargetForService - error: failed to get CRD details from directory, namespacedName: %s\", namespacedName)\n\t}\n\tif err := s.scaleHandler.UpdateLastScaledUpTime(ctx, crd.CRDName, namespace); err != nil {\n\t\ts.logger.Error(\"failed to update LastScaledUpTime\", zap.String(\"service\", namespacedName.String()), zap.Error(err))\n\t}\n\n\t// Unpause the Keda ScaledObject if it's paused\n\tif crd.Spec.Autoscaler != nil && strings.ToLower(crd.Spec.Autoscaler.Type) == \"keda\" {\n\t\tif err := s.scaleHandler.UpdateKedaScaledObjectPausedState(ctx, crd.Spec.Autoscaler.Name, namespace, false); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update Keda ScaledObject for service %s: %w\", namespacedName.String(), err)\n\t\t}\n\t}\n\n\tscaleTargetRef := crd.Spec.GetScaleTargetRef()\n\n\ttargetGVK, err := k8shelper.APIVersionStrToGVK(scaleTargetRef.APIVersion, scaleTargetRef.Kind)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse API version: %w\", err)\n\t}\n\n\tif _, err := s.scaleHandler.Scale(ctx,\n\t\tnamespace,\n\t\ttargetGVK,\n\t\tscaleTargetRef.Name,\n\t\tcrd.Spec.MinTargetReplicas,\n\t); err != nil {\n\t\tprom.TargetScaleCounter.WithLabelValues(serviceName, namespace, crd.Spec.ScaleTargetRef.Kind+\"-\"+crd.Spec.ScaleTargetRef.Name, err.Error()).Inc()\n\t\treturn fmt.Errorf(\"scaleTargetForService - error: %w, targetRefKind: %s, targetRefName: %s\", err, crd.Spec.ScaleTargetRef.Kind, crd.Spec.ScaleTargetRef.Name)\n\t}\n\tprom.TargetScaleCounter.WithLabelValues(serviceName, namespace, crd.Spec.ScaleTargetRef.Kind+\"-\"+crd.Spec.ScaleTargetRef.Name, \"success\").Inc()\n\n\treturn nil\n}",
    "start_line": 149,
    "end_line": 189,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Server.scaleTargetForService",
    "component_id": "operator.internal.elastiserver.elastiServer.Server.scaleTargetForService"
  },
  "operator.internal.informer.informer.RequestWatch": {
    "id": "operator.internal.informer.informer.RequestWatch",
    "name": "RequestWatch",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "type (\n\t// Manager helps manage lifecycle of informer\n\tManager struct {\n\t\tclient              *kubernetes.Clientset\n\t\tdynamicClient       *dynamic.DynamicClient\n\t\tlogger              *zap.Logger\n\t\tinformers           sync.Map\n\t\tresolver            info\n\t\tresyncPeriod        time.Duration\n\t\thealthCheckDuration time.Duration\n\t\thealthCheckStopChan chan struct{}\n\t}\n\n\tinfo struct {\n\t\tInformer cache.SharedInformer\n\t\tStopCh   chan struct{}\n\t\tReq      *RequestWatch\n\t}\n\n\t// RequestWatch is the request body sent to the informer\n\tRequestWatch struct {\n\t\tReq                  ctrl.Request\n\t\tResourceName         string\n\t\tResourceNamespace    string\n\t\tGroupVersionResource *schema.GroupVersionResource\n\t\tHandlers             cache.ResourceEventHandlerFuncs\n\t}\n)",
    "start_line": 32,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct RequestWatch",
    "component_id": "operator.internal.informer.informer.RequestWatch"
  },
  "operator.internal.informer.informer.NewInformerManager": {
    "id": "operator.internal.informer.informer.NewInformerManager",
    "name": "NewInformerManager",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "func NewInformerManager(logger *zap.Logger, kConfig *rest.Config) *Manager {\n\tclientSet, err := kubernetes.NewForConfig(kConfig)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\tdynamicClient, err := dynamic.NewForConfig(kConfig)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\n\treturn &Manager{\n\t\tclient:        clientSet,\n\t\tdynamicClient: dynamicClient,\n\t\tlogger:        logger.Named(\"InformerManager\"),\n\t\t// ResyncPeriod is the proactive resync we do, even when no events are received by the informer.\n\t\tresyncPeriod:        5 * time.Minute,\n\t\thealthCheckDuration: 5 * time.Second,\n\t\thealthCheckStopChan: make(chan struct{}),\n\t}\n}",
    "start_line": 62,
    "end_line": 81,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewInformerManager",
    "component_id": "operator.internal.informer.informer.NewInformerManager"
  },
  "operator.internal.informer.informer.Manager.InitializeResolverInformer": {
    "id": "operator.internal.informer.informer.Manager.InitializeResolverInformer",
    "name": "Manager.InitializeResolverInformer",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "pkg.config.config.GetResolverConfig",
      "operator.internal.informer.informer.Manager.getKeyFromRequestWatch"
    ],
    "source_code": "func (m *Manager) InitializeResolverInformer(handlers cache.ResourceEventHandlerFuncs) error {\n\tdeploymentGVR := schema.GroupVersionResource{\n\t\tGroup:    \"apps\",\n\t\tVersion:  \"v1\",\n\t\tResource: \"deployments\",\n\t}\n\n\tresolverConfig := config.GetResolverConfig()\n\n\tm.resolver.Informer = cache.NewSharedInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(_ metav1.ListOptions) (kRuntime.Object, error) {\n\t\t\t\treturn m.dynamicClient.Resource(deploymentGVR).Namespace(resolverConfig.Namespace).List(context.Background(), metav1.ListOptions{\n\t\t\t\t\tFieldSelector: \"metadata.name=\" + resolverConfig.DeploymentName,\n\t\t\t\t})\n\t\t\t},\n\t\t\tWatchFunc: func(_ metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\treturn m.dynamicClient.Resource(deploymentGVR).Namespace(resolverConfig.Namespace).Watch(context.Background(), metav1.ListOptions{\n\t\t\t\t\tFieldSelector: \"metadata.name=\" + resolverConfig.DeploymentName,\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t&unstructured.Unstructured{},\n\t\tm.resyncPeriod,\n\t)\n\n\t_, err := m.resolver.Informer.AddEventHandler(handlers)\n\tif err != nil {\n\t\tm.logger.Error(\"Failed to add event handler\", zap.Error(err))\n\t\treturn fmt.Errorf(\"failed to add event handler: %w\", err)\n\t}\n\n\tm.resolver.StopCh = make(chan struct{})\n\tgo m.resolver.Informer.Run(m.resolver.StopCh)\n\n\tif !cache.WaitForCacheSync(m.resolver.StopCh, m.resolver.Informer.HasSynced) {\n\t\tm.logger.Error(\"Failed to sync informer\", zap.String(\"key\", m.getKeyFromRequestWatch(m.resolver.Req)))\n\t\treturn errors.New(\"failed to sync resolver informer\")\n\t}\n\tm.logger.Info(\"Resolver informer started\")\n\treturn nil\n}",
    "start_line": 83,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.InitializeResolverInformer",
    "component_id": "operator.internal.informer.informer.Manager.InitializeResolverInformer"
  },
  "operator.internal.informer.informer.Manager.Start": {
    "id": "operator.internal.informer.informer.Manager.Start",
    "name": "Manager.Start",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "func (m *Manager) Start() {\n\tm.logger.Info(\"Starting InformerManager\")\n\tgo wait.Until(m.monitorInformers, m.healthCheckDuration, m.healthCheckStopChan)\n}",
    "start_line": 128,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.Start",
    "component_id": "operator.internal.informer.informer.Manager.Start"
  },
  "operator.internal.informer.informer.Manager.Stop": {
    "id": "operator.internal.informer.informer.Manager.Stop",
    "name": "Manager.Stop",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.StopInformer",
      "operator.internal.informer.informer.Manager.getKeyFromRequestWatch"
    ],
    "source_code": "func (m *Manager) Stop() {\n\tm.logger.Info(\"Stopping InformerManager\")\n\t// Loop through all the informers and stop them\n\tm.informers.Range(func(_, value interface{}) bool {\n\t\tinfo, ok := value.(info)\n\t\tif ok {\n\t\t\terr := m.StopInformer(m.getKeyFromRequestWatch(info.Req))\n\t\t\tif err != nil {\n\t\t\t\tm.logger.Error(\"failed to stop informer\", zap.Error(err))\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n\t// Stop the health watch\n\tclose(m.healthCheckStopChan)\n\tm.logger.Info(\"InformerManager stopped\")\n}",
    "start_line": 134,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.Stop",
    "component_id": "operator.internal.informer.informer.Manager.Stop"
  },
  "operator.internal.informer.informer.Manager.StopForCRD": {
    "id": "operator.internal.informer.informer.Manager.StopForCRD",
    "name": "Manager.StopForCRD",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.Add",
      "operator.internal.informer.informer.Manager.StopInformer",
      "operator.internal.informer.informer.Manager.getKeyFromRequestWatch"
    ],
    "source_code": "func (m *Manager) StopForCRD(crdName string, namespace string) {\n\t// Loop through all the informers and stop them\n\tvar wg sync.WaitGroup\n\tm.informers.Range(func(key, value interface{}) bool {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tkeyStr := key.(string)\n\t\t\tif strings.HasPrefix(keyStr, fmt.Sprintf(\"%s/%s/\", strings.ToLower(crdName), strings.ToLower(namespace))) {\n\t\t\t\tinfo, ok := value.(info)\n\t\t\t\tif ok {\n\t\t\t\t\tif err := m.StopInformer(m.getKeyFromRequestWatch(info.Req)); err != nil {\n\t\t\t\t\t\tm.logger.Error(\"Failed to stop informer\", zap.Error(err))\n\t\t\t\t\t}\n\t\t\t\t\tm.logger.Info(\"Stopped informer\", zap.String(\"key\", keyStr))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\treturn true\n\t})\n\twg.Wait()\n}",
    "start_line": 153,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.StopForCRD",
    "component_id": "operator.internal.informer.informer.Manager.StopForCRD"
  },
  "operator.internal.informer.informer.Manager.StopInformer": {
    "id": "operator.internal.informer.informer.Manager.StopInformer",
    "name": "Manager.StopInformer",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "func (m *Manager) StopInformer(key string) (err error) {\n\tdefer func() {\n\t\terrStr := values.Success\n\t\tif err != nil {\n\t\t\terrStr = err.Error()\n\t\t}\n\t\tprom.InformerCounter.WithLabelValues(key, \"stop\", errStr).Inc()\n\t}()\n\tvalue, ok := m.informers.Load(key)\n\tif !ok {\n\t\treturn fmt.Errorf(\"informer not found, already stopped for key: %s\", key)\n\t}\n\n\t// We need to verify if the informer exists in the map\n\tinformerInfo, ok := value.(info)\n\tif !ok {\n\t\treturn fmt.Errorf(\"failed to cast WatchInfo for key: %s\", key)\n\t}\n\n\t// Close the informer, delete it from the map\n\tclose(informerInfo.StopCh)\n\tm.informers.Delete(key)\n\tprom.InformerGauge.WithLabelValues(key).Dec()\n\treturn nil\n}",
    "start_line": 178,
    "end_line": 202,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.StopInformer",
    "component_id": "operator.internal.informer.informer.Manager.StopInformer"
  },
  "operator.internal.informer.informer.Manager.monitorInformers": {
    "id": "operator.internal.informer.informer.Manager.monitorInformers",
    "name": "Manager.monitorInformers",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.getKeyFromRequestWatch",
      "operator.internal.informer.informer.Manager.StopInformer",
      "operator.internal.informer.informer.Manager.enableInformer"
    ],
    "source_code": "func (m *Manager) monitorInformers() {\n\tm.informers.Range(func(key, value interface{}) bool {\n\t\tinfo, ok := value.(info)\n\t\tif ok {\n\t\t\tif !info.Informer.HasSynced() {\n\t\t\t\tm.logger.Info(\"Informer not synced\", zap.String(\"key\", key.(string)))\n\t\t\t\terr := m.StopInformer(m.getKeyFromRequestWatch(info.Req))\n\t\t\t\tif err != nil {\n\t\t\t\t\tm.logger.Error(\"Error in stopping informer\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\terr = m.enableInformer(info.Req)\n\t\t\t\tif err != nil {\n\t\t\t\t\tm.logger.Error(\"Error in enabling informer\", zap.Error(err))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}",
    "start_line": 204,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.monitorInformers",
    "component_id": "operator.internal.informer.informer.Manager.monitorInformers"
  },
  "operator.internal.informer.informer.Manager.Add": {
    "id": "operator.internal.informer.informer.Manager.Add",
    "name": "Manager.Add",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.verifyTargetExist",
      "operator.internal.informer.informer.Manager.getKeyFromRequestWatch",
      "operator.internal.informer.informer.Manager.enableInformer"
    ],
    "source_code": "func (m *Manager) Add(req *RequestWatch) (err error) {\n\tkey := m.getKeyFromRequestWatch(req)\n\tdefer func() {\n\t\terrStr := values.Success\n\t\tif err != nil {\n\t\t\terrStr = err.Error()\n\t\t}\n\t\tprom.InformerCounter.WithLabelValues(key, \"add\", errStr).Inc()\n\t}()\n\tm.logger.Info(\"Adding informer\",\n\t\tzap.String(\"group\", req.GroupVersionResource.Group),\n\t\tzap.String(\"version\", req.GroupVersionResource.Version),\n\t\tzap.String(\"resource\", req.GroupVersionResource.Resource),\n\t\tzap.String(\"resourceName\", req.ResourceName),\n\t\tzap.String(\"resourceNamespace\", req.ResourceNamespace),\n\t\tzap.String(\"crd\", req.Req.String()),\n\t)\n\n\t// Proceed only if the informer is not already running, we verify by checking the map\n\tif _, ok := m.informers.Load(key); ok {\n\t\tm.logger.Info(\"Informer already running\", zap.String(\"key\", key))\n\t\treturn nil\n\t}\n\n\t//TODO: Check if the resource exists\n\tif err = m.verifyTargetExist(req); err != nil {\n\t\treturn fmt.Errorf(\"target not found: %w\", err)\n\t}\n\n\tif err = m.enableInformer(req); err != nil {\n\t\treturn fmt.Errorf(\"failed to enable to informer: %w\", err)\n\t}\n\tprom.InformerGauge.WithLabelValues(key).Inc()\n\treturn nil\n}",
    "start_line": 225,
    "end_line": 259,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.Add",
    "component_id": "operator.internal.informer.informer.Manager.Add"
  },
  "operator.internal.informer.informer.Manager.enableInformer": {
    "id": "operator.internal.informer.informer.Manager.enableInformer",
    "name": "Manager.enableInformer",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.getKeyFromRequestWatch"
    ],
    "source_code": "func (m *Manager) enableInformer(req *RequestWatch) error {\n\tctx := context.Background()\n\t// Create an informer for the resource\n\tinformer := cache.NewSharedInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(_ metav1.ListOptions) (kRuntime.Object, error) {\n\t\t\t\treturn m.dynamicClient.Resource(*req.GroupVersionResource).Namespace(req.ResourceNamespace).List(ctx, metav1.ListOptions{\n\t\t\t\t\tFieldSelector: \"metadata.name=\" + req.ResourceName,\n\t\t\t\t})\n\t\t\t},\n\t\t\tWatchFunc: func(_ metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\treturn m.dynamicClient.Resource(*req.GroupVersionResource).Namespace(req.ResourceNamespace).Watch(ctx, metav1.ListOptions{\n\t\t\t\t\tFieldSelector: \"metadata.name=\" + req.ResourceName,\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t&unstructured.Unstructured{},\n\t\tm.resyncPeriod,\n\t)\n\t// We pass the handlers we received as a parameter\n\t_, err := informer.AddEventHandler(req.Handlers)\n\tif err != nil {\n\t\tm.logger.Error(\"Error creating informer handler\", zap.Error(err))\n\t\treturn fmt.Errorf(\"enableInformer: %w\", err)\n\t}\n\t// This channel is used to stop the informer\n\t// We add it in the informers map, so we can stop it when required\n\tinformerStop := make(chan struct{})\n\tgo informer.Run(informerStop)\n\t// Store the informer in the map\n\t// This is used to manage the lifecycle of the informer\n\t// Recover it in case it's not syncing, this is why we also store the handlers\n\t// Stop it when the CRD or the operator is deleted\n\tkey := m.getKeyFromRequestWatch(req)\n\tm.informers.Store(key, info{\n\t\tInformer: informer,\n\t\tStopCh:   informerStop,\n\t\tReq:      req,\n\t})\n\n\t// Wait for the cache to sync\n\tif !cache.WaitForCacheSync(informerStop, informer.HasSynced) {\n\t\tm.logger.Error(\"Failed to sync informer\", zap.String(\"key\", key))\n\t\treturn errors.New(\"failed to sync informer\")\n\t}\n\tm.logger.Info(\"Informer started\", zap.String(\"key\", key))\n\treturn nil\n}",
    "start_line": 262,
    "end_line": 309,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.enableInformer",
    "component_id": "operator.internal.informer.informer.Manager.enableInformer"
  },
  "operator.internal.informer.informer.Manager.getKeyFromRequestWatch": {
    "id": "operator.internal.informer.informer.Manager.getKeyFromRequestWatch",
    "name": "Manager.getKeyFromRequestWatch",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "func (m *Manager) getKeyFromRequestWatch(req *RequestWatch) string {\n\treturn fmt.Sprintf(\"%s/%s/%s/%s\",\n\t\tstrings.ToLower(req.Req.Name),                      // CRD Name\n\t\tstrings.ToLower(req.ResourceNamespace),             // Namespace\n\t\tstrings.ToLower(req.GroupVersionResource.Resource), // Resource Type\n\t\tstrings.ToLower(req.ResourceName))                  // Resource Name\n}",
    "start_line": 313,
    "end_line": 319,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.getKeyFromRequestWatch",
    "component_id": "operator.internal.informer.informer.Manager.getKeyFromRequestWatch"
  },
  "operator.internal.informer.informer.KeyParams": {
    "id": "operator.internal.informer.informer.KeyParams",
    "name": "KeyParams",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "type KeyParams struct {\n\tNamespace    string\n\tCRDName      string\n\tResourceType string\n\tResourceName string\n}",
    "start_line": 321,
    "end_line": 326,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct KeyParams",
    "component_id": "operator.internal.informer.informer.KeyParams"
  },
  "operator.internal.informer.informer.Manager.GetKey": {
    "id": "operator.internal.informer.informer.Manager.GetKey",
    "name": "Manager.GetKey",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [],
    "source_code": "func (m *Manager) GetKey(param KeyParams) string {\n\treturn fmt.Sprintf(\"%s/%s/%s/%s\",\n\t\tstrings.ToLower(param.CRDName),      // CRD Name\n\t\tstrings.ToLower(param.Namespace),    // Namespace\n\t\tstrings.ToLower(param.ResourceType), // Resource Type\n\t\tstrings.ToLower(param.ResourceName)) // Resource Name\n}",
    "start_line": 329,
    "end_line": 335,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.GetKey",
    "component_id": "operator.internal.informer.informer.Manager.GetKey"
  },
  "operator.internal.informer.informer.Manager.verifyTargetExist": {
    "id": "operator.internal.informer.informer.Manager.verifyTargetExist",
    "name": "Manager.verifyTargetExist",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/operator/internal/informer/informer.go",
    "relative_path": "operator/internal/informer/informer.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get"
    ],
    "source_code": "func (m *Manager) verifyTargetExist(req *RequestWatch) error {\n\tif _, err := m.dynamicClient.Resource(*req.GroupVersionResource).Namespace(req.ResourceNamespace).Get(context.Background(), req.ResourceName, metav1.GetOptions{}); err != nil {\n\t\treturn fmt.Errorf(\"resource doesn't exist: %w | resource name: %v | resource type: %v | resource namespace: %v\", err, req.ResourceName, req.GroupVersionResource.Resource, req.ResourceNamespace)\n\t}\n\treturn nil\n}",
    "start_line": 338,
    "end_line": 343,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Manager.verifyTargetExist",
    "component_id": "operator.internal.informer.informer.Manager.verifyTargetExist"
  },
  "pkg.config.config.Config": {
    "id": "pkg.config.config.Config",
    "name": "Config",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [],
    "source_code": "type Config struct {\n\tNamespace      string\n\tDeploymentName string\n\tServiceName    string\n\tPort           int32\n}",
    "start_line": 23,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Config",
    "component_id": "pkg.config.config.Config"
  },
  "pkg.config.config.ResolverConfig": {
    "id": "pkg.config.config.ResolverConfig",
    "name": "ResolverConfig",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [
      "pkg.config.config.Config"
    ],
    "source_code": "type ResolverConfig struct {\n\tConfig\n\n\tReverseProxyPort int32\n}",
    "start_line": 31,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ResolverConfig",
    "component_id": "pkg.config.config.ResolverConfig"
  },
  "pkg.config.config.GetKubernetesClusterDomain": {
    "id": "pkg.config.config.GetKubernetesClusterDomain",
    "name": "GetKubernetesClusterDomain",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [
      "pkg.config.config.getEnvStringOrPanic"
    ],
    "source_code": "func GetKubernetesClusterDomain() string {\n\treturn getEnvStringOrPanic(EnvKubernetesClusterDomain)\n}",
    "start_line": 38,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function GetKubernetesClusterDomain",
    "component_id": "pkg.config.config.GetKubernetesClusterDomain"
  },
  "pkg.config.config.GetResolverConfig": {
    "id": "pkg.config.config.GetResolverConfig",
    "name": "GetResolverConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [
      "pkg.config.config.getEnvPortOrPanic",
      "pkg.config.config.getEnvStringOrPanic"
    ],
    "source_code": "func GetResolverConfig() ResolverConfig {\n\treturn ResolverConfig{\n\t\tConfig: Config{\n\t\t\tNamespace:      getEnvStringOrPanic(EnvResolverNamespace),\n\t\t\tDeploymentName: getEnvStringOrPanic(EnvResolverDeploymentName),\n\t\t\tServiceName:    getEnvStringOrPanic(EnvResolverServiceName),\n\t\t\tPort:           getEnvPortOrPanic(EnvResolverPort),\n\t\t},\n\n\t\tReverseProxyPort: getEnvPortOrPanic(EnvResolverProxyPort),\n\t}\n}",
    "start_line": 43,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function GetResolverConfig",
    "component_id": "pkg.config.config.GetResolverConfig"
  },
  "pkg.config.config.GetOperatorConfig": {
    "id": "pkg.config.config.GetOperatorConfig",
    "name": "GetOperatorConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [
      "pkg.config.config.getEnvPortOrPanic",
      "pkg.config.config.getEnvStringOrPanic"
    ],
    "source_code": "func GetOperatorConfig() Config {\n\treturn Config{\n\t\tNamespace:      getEnvStringOrPanic(EnvOperatorNamespace),\n\t\tDeploymentName: getEnvStringOrPanic(EnvOperatorDeploymentName),\n\t\tServiceName:    getEnvStringOrPanic(EnvOperatorServiceName),\n\t\tPort:           getEnvPortOrPanic(EnvOperatorPort),\n\t}\n}",
    "start_line": 57,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function GetOperatorConfig",
    "component_id": "pkg.config.config.GetOperatorConfig"
  },
  "pkg.config.config.getEnvStringOrPanic": {
    "id": "pkg.config.config.getEnvStringOrPanic",
    "name": "getEnvStringOrPanic",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [],
    "source_code": "func getEnvStringOrPanic(envName string) string {\n\tenvValue := os.Getenv(envName)\n\tif envValue == \"\" {\n\t\tpanic(\"required env value not set: \" + envName)\n\t}\n\n\treturn envValue\n}",
    "start_line": 67,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getEnvStringOrPanic",
    "component_id": "pkg.config.config.getEnvStringOrPanic"
  },
  "pkg.config.config.getEnvPortOrPanic": {
    "id": "pkg.config.config.getEnvPortOrPanic",
    "name": "getEnvPortOrPanic",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/config/config.go",
    "relative_path": "pkg/config/config.go",
    "depends_on": [
      "pkg.config.config.getEnvStringOrPanic"
    ],
    "source_code": "func getEnvPortOrPanic(envName string) int32 {\n\tenvValue := getEnvStringOrPanic(envName)\n\n\tport, err := strconv.ParseInt(envValue, 10, 32)\n\tif err != nil {\n\t\tpanic(\"required env value is not integer: \" + envName)\n\t}\n\n\tif port < 1 || port > 65535 {\n\t\tpanic(fmt.Sprintf(\"port out of range for %s: %d (want 1..65535)\", envName, port))\n\t}\n\n\treturn int32(port)\n}",
    "start_line": 77,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getEnvPortOrPanic",
    "component_id": "pkg.config.config.getEnvPortOrPanic"
  },
  "pkg.k8shelper.ops.Ops": {
    "id": "pkg.k8shelper.ops.Ops",
    "name": "Ops",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/k8shelper/ops.go",
    "relative_path": "pkg/k8shelper/ops.go",
    "depends_on": [],
    "source_code": "type Ops struct {\n\tkClient        *kubernetes.Clientset\n\tkDynamicClient *dynamic.DynamicClient\n\tlogger         *zap.Logger\n}",
    "start_line": 17,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Ops",
    "component_id": "pkg.k8shelper.ops.Ops"
  },
  "pkg.k8shelper.ops.NewOps": {
    "id": "pkg.k8shelper.ops.NewOps",
    "name": "NewOps",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/k8shelper/ops.go",
    "relative_path": "pkg/k8shelper/ops.go",
    "depends_on": [],
    "source_code": "func NewOps(logger *zap.Logger, config *rest.Config) *Ops {\n\tkClient, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\tkDynamicClient, err := dynamic.NewForConfig(config)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\treturn &Ops{\n\t\tlogger:         logger.Named(\"k8sOps\"),\n\t\tkClient:        kClient,\n\t\tkDynamicClient: kDynamicClient,\n\t}\n}",
    "start_line": 24,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewOps",
    "component_id": "pkg.k8shelper.ops.NewOps"
  },
  "pkg.k8shelper.ops.Ops.CheckIfServiceEndpointSliceActive": {
    "id": "pkg.k8shelper.ops.Ops.CheckIfServiceEndpointSliceActive",
    "name": "Ops.CheckIfServiceEndpointSliceActive",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/k8shelper/ops.go",
    "relative_path": "pkg/k8shelper/ops.go",
    "depends_on": [
      "pkg.logger.logger.MaskMiddle"
    ],
    "source_code": "func (k *Ops) CheckIfServiceEndpointSliceActive(ns, svc string) (bool, error) {\n\tendpointSlices, err := k.kClient.DiscoveryV1().EndpointSlices(ns).List(context.TODO(), metav1.ListOptions{\n\t\tLabelSelector: discoveryv1.LabelServiceName + \"=\" + svc,\n\t})\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"CheckIfServiceEndpointSliceActive - GET: %w\", err)\n\t}\n\n\tfor _, slice := range endpointSlices.Items {\n\t\tfor _, endpoint := range slice.Endpoints {\n\t\t\t// According to K8s docs: \"ready\" should be marked if endpoint is serving and not terminating\n\t\t\t// So checking ready alone should be sufficient for most use cases\n\t\t\t// nil should be interpreted as \"true\"\n\t\t\tif endpoint.Conditions.Ready == nil || *endpoint.Conditions.Ready {\n\t\t\t\tk.logger.Debug(\"Service endpoint is active\", zap.String(\"service\", logger.MaskMiddle(svc, 3, 3)), zap.String(\"namespace\", logger.MaskMiddle(ns, 3, 3)))\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}",
    "start_line": 41,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Ops.CheckIfServiceEndpointSliceActive",
    "component_id": "pkg.k8shelper.ops.Ops.CheckIfServiceEndpointSliceActive"
  },
  "pkg.k8shelper.utils.UnstructuredToResource": {
    "id": "pkg.k8shelper.utils.UnstructuredToResource",
    "name": "UnstructuredToResource",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/k8shelper/utils.go",
    "relative_path": "pkg/k8shelper/utils.go",
    "depends_on": [],
    "source_code": "func UnstructuredToResource(obj interface{}, resource interface{}) error {\n\tunstructuredObj := obj.(*unstructured.Unstructured)\n\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), resource)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"UnstructuredToResource: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 12,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function UnstructuredToResource",
    "component_id": "pkg.k8shelper.utils.UnstructuredToResource"
  },
  "pkg.k8shelper.utils.KindToResource": {
    "id": "pkg.k8shelper.utils.KindToResource",
    "name": "KindToResource",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/k8shelper/utils.go",
    "relative_path": "pkg/k8shelper/utils.go",
    "depends_on": [],
    "source_code": "func KindToResource(kind string) string {\n\tk := strings.ToLower(kind)\n\t// tolerate legacy already-plural inputs\n\tif strings.HasSuffix(k, \"s\") {\n\t\treturn k\n\t}\n\treturn k + \"s\"\n}",
    "start_line": 24,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function KindToResource",
    "component_id": "pkg.k8shelper.utils.KindToResource"
  },
  "pkg.k8shelper.utils.APIVersionStrToGVK": {
    "id": "pkg.k8shelper.utils.APIVersionStrToGVK",
    "name": "APIVersionStrToGVK",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/k8shelper/utils.go",
    "relative_path": "pkg/k8shelper/utils.go",
    "depends_on": [],
    "source_code": "func APIVersionStrToGVK(apiVersion string, kind string) (schema.GroupVersionKind, error) {\n\tgv, err := schema.ParseGroupVersion(apiVersion)\n\tif err != nil {\n\t\treturn schema.GroupVersionKind{}, fmt.Errorf(\"failed to parse API version: %w\", err)\n\t}\n\treturn schema.GroupVersionKind{\n\t\tGroup:   gv.Group,\n\t\tVersion: gv.Version,\n\t\tKind:    kind,\n\t}, nil\n}",
    "start_line": 34,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function APIVersionStrToGVK",
    "component_id": "pkg.k8shelper.utils.APIVersionStrToGVK"
  },
  "pkg.logger.logger.MaskMiddle": {
    "id": "pkg.logger.logger.MaskMiddle",
    "name": "MaskMiddle",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/logger/logger.go",
    "relative_path": "pkg/logger/logger.go",
    "depends_on": [],
    "source_code": "func MaskMiddle(input string, unmaskedPrefix, unmaskedSuffix int) string {\n\tif unmaskedPrefix < 0 {\n\t\tunmaskedPrefix = 0\n\t}\n\tif unmaskedSuffix < 0 {\n\t\tunmaskedSuffix = 0\n\t}\n\n\trunes := []rune(input)\n\tn := len(runes)\n\tif n <= unmaskedPrefix+unmaskedSuffix {\n\t\treturn strings.Repeat(\"*\", n)\n\t}\n\n\tprefix := string(runes[:unmaskedPrefix])\n\tsuffix := string(runes[n-unmaskedSuffix:])\n\tmasked := strings.Repeat(\"*\", n-unmaskedPrefix-unmaskedSuffix)\n\n\treturn prefix + masked + suffix\n}",
    "start_line": 13,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function MaskMiddle",
    "component_id": "pkg.logger.logger.MaskMiddle"
  },
  "pkg.logger.logger.NewLogger": {
    "id": "pkg.logger.logger.NewLogger",
    "name": "NewLogger",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/logger/logger.go",
    "relative_path": "pkg/logger/logger.go",
    "depends_on": [],
    "source_code": "func NewLogger(env string, sentryEnabled bool) (*zap.Logger, error) {\n\tvar config zap.Config\n\n\tif env == \"prod\" {\n\t\tencoderCfg := zap.NewProductionEncoderConfig()\n\t\tencoderCfg.TimeKey = \"timestamp\"\n\t\tencoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder\n\n\t\tconfig = zap.NewProductionConfig()\n\t\tconfig.EncoderConfig = encoderCfg\n\t} else {\n\t\tencoderCfg := zap.NewDevelopmentEncoderConfig()\n\t\tencoderCfg.EncodeLevel = zapcore.CapitalColorLevelEncoder\n\t\tencoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder\n\t\tencoderCfg.EncodeDuration = zapcore.StringDurationEncoder\n\t\tencoderCfg.StacktraceKey = \"\" // removes stack trace from error logs\n\n\t\tconfig = zap.Config{\n\t\t\tLevel:            zap.NewAtomicLevelAt(zap.DebugLevel),\n\t\t\tDevelopment:      true,\n\t\t\tEncoding:         \"console\",\n\t\t\tEncoderConfig:    encoderCfg,\n\t\t\tOutputPaths:      []string{\"stdout\"},\n\t\t\tErrorOutputPaths: []string{\"stderr\"},\n\t\t}\n\t}\n\n\tlogger, err := config.Build()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating logger: %w\", err)\n\t}\n\n\tif sentryEnabled {\n\t\treturn zap.New(&CustomCore{Core: logger.Core()}), nil\n\t}\n\treturn logger, nil\n}",
    "start_line": 34,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewLogger",
    "component_id": "pkg.logger.logger.NewLogger"
  },
  "pkg.logger.logger.CustomCore": {
    "id": "pkg.logger.logger.CustomCore",
    "name": "CustomCore",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/logger/logger.go",
    "relative_path": "pkg/logger/logger.go",
    "depends_on": [],
    "source_code": "type CustomCore struct {\n\tzapcore.Core\n}",
    "start_line": 72,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct CustomCore",
    "component_id": "pkg.logger.logger.CustomCore"
  },
  "pkg.logger.logger.CustomCore.Check": {
    "id": "pkg.logger.logger.CustomCore.Check",
    "name": "CustomCore.Check",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/logger/logger.go",
    "relative_path": "pkg/logger/logger.go",
    "depends_on": [],
    "source_code": "func (c *CustomCore) Check(entry zapcore.Entry, checked *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\tif c.Enabled(entry.Level) {\n\t\treturn checked.AddCore(entry, c)\n\t}\n\treturn checked\n}",
    "start_line": 76,
    "end_line": 81,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method CustomCore.Check",
    "component_id": "pkg.logger.logger.CustomCore.Check"
  },
  "pkg.logger.logger.CustomCore.Write": {
    "id": "pkg.logger.logger.CustomCore.Write",
    "name": "CustomCore.Write",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/logger/logger.go",
    "relative_path": "pkg/logger/logger.go",
    "depends_on": [
      "pkg.logger.logger.CustomCore.Write"
    ],
    "source_code": "func (c *CustomCore) Write(entry zapcore.Entry, fields []zapcore.Field) error {\n\tif entry.Level >= zapcore.ErrorLevel {\n\t\tsentry.WithScope(func(scope *sentry.Scope) {\n\t\t\tcontext := make(sentry.Context) // map[string]interface{}\n\t\t\tvar err error\n\n\t\t\t// Convert Zap fields to Sentry context\n\t\t\tfor _, field := range fields {\n\t\t\t\tswitch field.Type {\n\t\t\t\tcase zapcore.StringType:\n\t\t\t\t\tcontext[field.Key] = field.String\n\t\t\t\tcase zapcore.Int64Type, zapcore.Int32Type, zapcore.Int16Type, zapcore.Int8Type:\n\t\t\t\t\tcontext[field.Key] = field.Integer\n\t\t\t\tcase zapcore.ErrorType:\n\t\t\t\t\tfieldErr := field.Interface.(error)\n\t\t\t\t\tcontext[field.Key] = fieldErr.Error()\n\t\t\t\t\tif err == nil { // Using only the first error\n\t\t\t\t\t\terr = fieldErr\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tcontext[field.Key] = field.String\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscope.SetLevel(sentry.LevelError)\n\t\t\tscope.SetContext(\"details\", context)\n\n\t\t\tstacktrace := sentry.NewStacktrace()\n\t\t\tstacktrace.Frames = stacktrace.Frames[:len(stacktrace.Frames)-4]\n\n\t\t\texception := sentry.Exception{\n\t\t\t\tType:       entry.Message,\n\t\t\t\tStacktrace: stacktrace,\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\texception.Value = err.Error()\n\t\t\t} else {\n\t\t\t\texception.Value = entry.Message\n\t\t\t}\n\n\t\t\tevent := &sentry.Event{\n\t\t\t\tMessage: entry.Message,\n\t\t\t\tLevel:   sentry.LevelError,\n\t\t\t\tException: []sentry.Exception{\n\t\t\t\t\texception,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tsentry.CaptureEvent(event)\n\t\t})\n\t}\n\terr := c.Core.Write(entry, fields)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write entry: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 83,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method CustomCore.Write",
    "component_id": "pkg.logger.logger.CustomCore.Write"
  },
  "pkg.messages.host.Host": {
    "id": "pkg.messages.host.Host",
    "name": "Host",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/messages/host.go",
    "relative_path": "pkg/messages/host.go",
    "depends_on": [],
    "source_code": "type Host struct {\n\tIncomingHost   string\n\tNamespace      string\n\tSourceService  string\n\tTargetService  string\n\tSourceHost     string\n\tTargetHost     string\n\tTrafficAllowed bool\n}",
    "start_line": 4,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Host",
    "component_id": "pkg.messages.host.Host"
  },
  "pkg.messages.operator.RequestCount": {
    "id": "pkg.messages.operator.RequestCount",
    "name": "RequestCount",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/messages/operator.go",
    "relative_path": "pkg/messages/operator.go",
    "depends_on": [],
    "source_code": "type RequestCount struct {\n\tCount     int    `json:\"count\"`\n\tSvc       string `json:\"svc\"`\n\tNamespace string `json:\"namespace\"`\n}",
    "start_line": 3,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct RequestCount",
    "component_id": "pkg.messages.operator.RequestCount"
  },
  "pkg.scaling.scale_handler.ScaleHandler": {
    "id": "pkg.scaling.scale_handler.ScaleHandler",
    "name": "ScaleHandler",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "type ScaleHandler struct {\n\tkClient        *kubernetes.Clientset\n\tkDynamicClient *dynamic.DynamicClient\n\tEventRecorder  record.EventRecorder\n\n\tscaleLocks sync.Map\n\n\tscaleClient scale.ScalesGetter\n\trestMapper  *restmapper.DeferredDiscoveryRESTMapper\n\n\tlogger         *zap.Logger\n\twatchNamespace string\n}",
    "start_line": 47,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct ScaleHandler",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler"
  },
  "pkg.scaling.scale_handler.ScaleHandler.getMutexForScale": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.getMutexForScale",
    "name": "ScaleHandler.getMutexForScale",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "func (h *ScaleHandler) getMutexForScale(key string) *sync.Mutex {\n\tl, _ := h.scaleLocks.LoadOrStore(key, &sync.Mutex{})\n\treturn l.(*sync.Mutex)\n}",
    "start_line": 62,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.getMutexForScale",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.getMutexForScale"
  },
  "pkg.scaling.scale_handler.NewScaleHandler": {
    "id": "pkg.scaling.scale_handler.NewScaleHandler",
    "name": "NewScaleHandler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "func NewScaleHandler(logger *zap.Logger, config *rest.Config, watchNamespace string, eventRecorder record.EventRecorder) *ScaleHandler {\n\tkClient, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\n\tkDynamicClient, err := dynamic.NewForConfig(config)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\n\t// Setup a cached discovery + deferred RESTMapper\n\tcachedDisc := discocache.NewMemCacheClient(kClient.Discovery())\n\trestMapper := restmapper.NewDeferredDiscoveryRESTMapper(cachedDisc)\n\tkindResolver := scale.NewDiscoveryScaleKindResolver(cachedDisc)\n\n\tscaleClient, err := scale.NewForConfig(config, restMapper, dynamic.LegacyAPIPathResolverFunc, kindResolver)\n\tif err != nil {\n\t\tlogger.Fatal(\"Error connecting with kubernetes\", zap.Error(err))\n\t}\n\n\treturn &ScaleHandler{\n\t\tlogger:         logger.Named(\"ScaleHandler\"),\n\t\tkClient:        kClient,\n\t\tkDynamicClient: kDynamicClient,\n\t\tscaleClient:    scaleClient,\n\t\trestMapper:     restMapper,\n\t\twatchNamespace: watchNamespace,\n\t\tEventRecorder:  eventRecorder,\n\t}\n}",
    "start_line": 68,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewScaleHandler",
    "component_id": "pkg.scaling.scale_handler.NewScaleHandler"
  },
  "pkg.scaling.scale_handler.ScaleHandler.StartScaleDownWatcher": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.StartScaleDownWatcher",
    "name": "ScaleHandler.StartScaleDownWatcher",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "pkg.scaling.scale_handler.ScaleHandler.checkAndScale",
      "operator.internal.informer.informer.Manager.Stop"
    ],
    "source_code": "func (h *ScaleHandler) StartScaleDownWatcher(ctx context.Context) {\n\tpollingInterval := 30 * time.Second\n\tif envInterval := os.Getenv(\"POLLING_VARIABLE\"); envInterval != \"\" {\n\t\tduration, err := time.ParseDuration(envInterval)\n\t\tif err != nil {\n\t\t\th.logger.Warn(\"Invalid POLLING_VARIABLE value, using default 30s\", zap.Error(err))\n\t\t} else {\n\t\t\tpollingInterval = duration\n\t\t}\n\t}\n\tticker := time.NewTicker(pollingInterval)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tticker.Stop()\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tif err := h.checkAndScale(ctx); err != nil {\n\t\t\t\t\th.logger.Error(\"failed to run the scale down check\", zap.Error(err))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}",
    "start_line": 100,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.StartScaleDownWatcher",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.StartScaleDownWatcher"
  },
  "pkg.scaling.scale_handler.ScaleHandler.checkAndScale": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.checkAndScale",
    "name": "ScaleHandler.checkAndScale",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "pkg.scaling.scale_handler.ScaleHandler.calculateScaleDirection",
      "pkg.scaling.scale_handler.ScaleHandler.handleScaleFromZero",
      "pkg.scaling.scale_handler.ScaleHandler.handleScaleToZero",
      "pkg.scaling.scale_handler.resolveCooldownPeriod"
    ],
    "source_code": "func (h *ScaleHandler) checkAndScale(ctx context.Context) error {\n\telastiServiceList, err := h.kDynamicClient.Resource(values.ElastiServiceGVR).Namespace(h.watchNamespace).List(ctx, metav1.ListOptions{})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list ElastiServices: %w\", err)\n\t}\n\n\tfor _, item := range elastiServiceList.Items {\n\t\tes := &v1alpha1.ElastiService{}\n\t\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(item.Object, es); err != nil {\n\t\t\th.logger.Error(\"failed to convert unstructured to ElastiService\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tcooldownPeriod := resolveCooldownPeriod(es)\n\n\t\tscaleDirection, err := h.calculateScaleDirection(ctx, cooldownPeriod, es)\n\t\tif err != nil {\n\t\t\th.logger.Error(\"failed to calculate scale direction\", zap.String(\"service\", es.Spec.Service), zap.String(\"namespace\", es.Namespace), zap.Error(err))\n\t\t\tcontinue\n\t\t} else if scaleDirection == NoScale {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch scaleDirection {\n\t\tcase ScaleDown:\n\t\t\terr := h.handleScaleToZero(ctx, es)\n\t\t\tif err != nil {\n\t\t\t\th.logger.Error(\"failed to scale target to zero\", zap.String(\"service\", es.Spec.Service), zap.String(\"namespace\", es.Namespace), zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase ScaleUp:\n\t\t\terr := h.handleScaleFromZero(ctx, es)\n\t\t\tif err != nil {\n\t\t\t\th.logger.Error(\"failed to scale target from zero\", zap.String(\"service\", es.Spec.Service), zap.String(\"namespace\", es.Namespace), zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
    "start_line": 127,
    "end_line": 166,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.checkAndScale",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.checkAndScale"
  },
  "pkg.scaling.scale_handler.ScaleHandler.calculateScaleDirection": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.calculateScaleDirection",
    "name": "ScaleHandler.calculateScaleDirection",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "operator.internal.informer.informer.Manager.Add",
      "pkg.scaling.scale_handler.ScaleHandler.createScalerForTrigger",
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close",
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.IsHealthy",
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleToZero"
    ],
    "source_code": "func (h *ScaleHandler) calculateScaleDirection(ctx context.Context, cooldownPeriod time.Duration, es *v1alpha1.ElastiService) (ScaleDirection, error) {\n\tif len(es.Spec.Triggers) == 0 {\n\t\th.logger.Info(\"No triggers found, skipping scale to zero\", zap.String(\"namespace\", es.Namespace), zap.String(\"service\", es.Spec.Service))\n\t\treturn \"\", fmt.Errorf(\"no triggers found\")\n\t}\n\n\t// Check that the ElastiService was created at least cooldownPeriod ago\n\tif es.CreationTimestamp.Time.Add(cooldownPeriod).After(time.Now()) {\n\t\th.logger.Debug(\"Skipping scaling decision as ElastiService was created too recently\",\n\t\t\tzap.String(\"service\", es.Spec.Service),\n\t\t\tzap.Duration(\"cooldown\", cooldownPeriod),\n\t\t\tzap.Time(\"creation timestamp\", es.CreationTimestamp.Time))\n\t\treturn NoScale, nil\n\t}\n\n\tfor _, trigger := range es.Spec.Triggers {\n\t\tscaler, err := h.createScalerForTrigger(&trigger, cooldownPeriod)\n\t\tif err != nil {\n\t\t\th.logger.Warn(\"failed to create scaler\", zap.String(\"namespace\", es.Namespace), zap.String(\"service\", es.Spec.Service), zap.Error(err))\n\t\t\treturn \"\", fmt.Errorf(\"failed to create scaler: %w\", err)\n\t\t}\n\t\tdefer scaler.Close(ctx)\n\n\t\t// TODO: Cache the health of the scaler if the server address has already been checked\n\t\thealthy, err := scaler.IsHealthy(ctx)\n\t\tif err != nil {\n\t\t\th.logger.Warn(\n\t\t\t\t\"failed to check scaler health\",\n\t\t\t\tzap.String(\"namespace\", es.Namespace),\n\t\t\t\tzap.String(\"service\", es.Spec.Service),\n\t\t\t\tzap.String(\"scaler\", trigger.Type),\n\t\t\t\tzap.Duration(\"cooldownPeriod\", cooldownPeriod),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t\treturn \"\", fmt.Errorf(\"scaler: %s, cooldownPeriod: %s, is not healthy\", trigger.Type, cooldownPeriod)\n\t\t}\n\t\tif !healthy {\n\t\t\th.logger.Warn(\"scaler is not healthy, skipping scale to zero\", zap.String(\"namespace\", es.Namespace), zap.String(\"service\", es.Spec.Service))\n\t\t\treturn NoScale, nil\n\t\t}\n\n\t\tscaleToZero, err := scaler.ShouldScaleToZero(ctx)\n\t\tif err != nil {\n\t\t\th.logger.Warn(\"failed to check scaler\", zap.String(\"namespace\", es.Namespace), zap.String(\"service\", es.Spec.Service), zap.Error(err))\n\t\t\treturn \"\", fmt.Errorf(\"failed to check scaler: %w\", err)\n\t\t}\n\n\t\tif !scaleToZero {\n\t\t\treturn ScaleUp, nil\n\t\t}\n\t}\n\n\treturn ScaleDown, nil\n}",
    "start_line": 168,
    "end_line": 221,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.calculateScaleDirection",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.calculateScaleDirection"
  },
  "pkg.scaling.scale_handler.ScaleHandler.handleScaleToZero": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.handleScaleToZero",
    "name": "ScaleHandler.handleScaleToZero",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "pkg.scaling.scale_handler.resolveCooldownPeriod",
      "pkg.scaling.scale_handler.ScaleHandler.Scale",
      "operator.api.v1alpha1.elastiservice_types.ElastiService.GetSpec",
      "pkg.scaling.scale_handler.ScaleHandler.UpdateKedaScaledObjectPausedState",
      "pkg.k8shelper.utils.APIVersionStrToGVK"
    ],
    "source_code": "func (h *ScaleHandler) handleScaleToZero(ctx context.Context, es *v1alpha1.ElastiService) error {\n\t// If the cooldown period is not met, we skip the scale down\n\tcooldownPeriod := resolveCooldownPeriod(es)\n\tspec := es.GetSpec()\n\tif es.Status.LastScaledUpTime != nil {\n\t\tif time.Since(es.Status.LastScaledUpTime.Time) < cooldownPeriod {\n\t\t\th.logger.Debug(\"Skipping scale down as minimum cooldownPeriod not met\",\n\t\t\t\tzap.String(\"service\", spec.Service),\n\t\t\t\tzap.Duration(\"cooldown\", cooldownPeriod),\n\t\t\t\tzap.Time(\"last scaled up time\", es.Status.LastScaledUpTime.Time))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Pause the KEDA ScaledObject\n\tif spec.Autoscaler != nil && strings.ToLower(spec.Autoscaler.Type) == \"keda\" {\n\t\terr := h.UpdateKedaScaledObjectPausedState(ctx, spec.Autoscaler.Name, es.Namespace, true)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update Keda ScaledObject for service %s: %w\", spec.Service, err)\n\t\t}\n\t}\n\n\ttargetGVK, err := k8shelper.APIVersionStrToGVK(spec.ScaleTargetRef.APIVersion, spec.ScaleTargetRef.Kind)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse API version: %w\", err)\n\t}\n\tif _, err := h.Scale(ctx,\n\t\tes.Namespace,\n\t\ttargetGVK,\n\t\tspec.ScaleTargetRef.Name,\n\t\t0,\n\t); err != nil {\n\t\treturn fmt.Errorf(\"failed to scale target to zero: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 223,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.handleScaleToZero",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.handleScaleToZero"
  },
  "pkg.scaling.scale_handler.resolveCooldownPeriod": {
    "id": "pkg.scaling.scale_handler.resolveCooldownPeriod",
    "name": "resolveCooldownPeriod",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "func resolveCooldownPeriod(es *v1alpha1.ElastiService) time.Duration {\n\tcooldownPeriod := time.Second * time.Duration(es.Spec.CooldownPeriod)\n\tif cooldownPeriod == 0 {\n\t\tcooldownPeriod = values.DefaultCooldownPeriod\n\t}\n\treturn cooldownPeriod\n}",
    "start_line": 260,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function resolveCooldownPeriod",
    "component_id": "pkg.scaling.scale_handler.resolveCooldownPeriod"
  },
  "pkg.scaling.scale_handler.ScaleHandler.handleScaleFromZero": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.handleScaleFromZero",
    "name": "ScaleHandler.handleScaleFromZero",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "pkg.scaling.scale_handler.ScaleHandler.Scale",
      "pkg.scaling.scale_handler.ScaleHandler.UpdateLastScaledUpTime",
      "operator.api.v1alpha1.elastiservice_types.ElastiService.GetSpec",
      "pkg.scaling.scale_handler.ScaleHandler.UpdateKedaScaledObjectPausedState",
      "pkg.k8shelper.utils.APIVersionStrToGVK"
    ],
    "source_code": "func (h *ScaleHandler) handleScaleFromZero(ctx context.Context, es *v1alpha1.ElastiService) error {\n\tspec := es.GetSpec()\n\t// We update the last scaled up time every time we evaluate that the trigger evaluates to scale-up. This means even if the scale-up is not successful, we update the last scaled up time to avoid the cooldown period increment\n\tif err := h.UpdateLastScaledUpTime(ctx, es.Name, es.Namespace); err != nil {\n\t\th.logger.Error(\"Failed to update LastScaledUpTime\", zap.Error(err), zap.String(\"service\", spec.Service), zap.String(\"namespace\", es.Namespace))\n\t}\n\n\t// Unpause the KEDA ScaledObject if it's paused\n\tif spec.Autoscaler != nil && strings.ToLower(spec.Autoscaler.Type) == \"keda\" {\n\t\terr := h.UpdateKedaScaledObjectPausedState(ctx, spec.Autoscaler.Name, es.Namespace, false)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update Keda ScaledObject for service %s in namespace %s: %w\", spec.Service, es.Namespace, err)\n\t\t}\n\t}\n\n\ttargetGVK, err := k8shelper.APIVersionStrToGVK(spec.ScaleTargetRef.APIVersion, spec.ScaleTargetRef.Kind)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse API version: %w\", err)\n\t}\n\tif _, err := h.Scale(ctx,\n\t\tes.Namespace,\n\t\ttargetGVK,\n\t\tspec.ScaleTargetRef.Name,\n\t\tspec.MinTargetReplicas,\n\t); err != nil {\n\t\treturn fmt.Errorf(\"failed to scale target from zero: %w\", err)\n\t}\n\n\treturn nil\n}",
    "start_line": 268,
    "end_line": 297,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.handleScaleFromZero",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.handleScaleFromZero"
  },
  "pkg.scaling.scale_handler.ScaleHandler.createScalerForTrigger": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.createScalerForTrigger",
    "name": "ScaleHandler.createScalerForTrigger",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "pkg.scaling.scalers.prometheus_scaler.NewPrometheusScaler"
    ],
    "source_code": "func (h *ScaleHandler) createScalerForTrigger(trigger *v1alpha1.ScaleTrigger, cooldownPeriod time.Duration) (scalers.Scaler, error) {\n\tvar scaler scalers.Scaler\n\tvar err error\n\n\tswitch trigger.Type {\n\tcase \"prometheus\":\n\t\tscaler, err = scalers.NewPrometheusScaler(trigger.Metadata, cooldownPeriod)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported trigger type: %s\", trigger.Type)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create scaler: %w\", err)\n\t}\n\treturn scaler, nil\n}",
    "start_line": 299,
    "end_line": 314,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.createScalerForTrigger",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.createScalerForTrigger"
  },
  "pkg.scaling.scale_handler.ScaleHandler.Scale": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.Scale",
    "name": "ScaleHandler.Scale",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get",
      "pkg.scaling.scale_handler.ScaleHandler.getMutexForScale",
      "pkg.k8shelper.utils.KindToResource",
      "pkg.scaling.scale_handler.ScaleHandler.createEvent"
    ],
    "source_code": "func (h *ScaleHandler) Scale(ctx context.Context,\n\tnamespace string,\n\ttargetGVK schema.GroupVersionKind,\n\ttargetName string,\n\tdesiredReplicas int32) (bool, error) {\n\t// Get mutex for the target\n\tmutex := h.getMutexForScale(namespace + \"/\" + targetGVK.Kind + \"/\" + targetName)\n\tmutex.Lock()\n\tdefer mutex.Unlock()\n\th.logger.Debug(\"Scaling\", zap.String(\"kind\", targetGVK.Kind), zap.String(\"namespace\", namespace), zap.String(\"name\", targetName), zap.Int32(\"desired replicas\", desiredReplicas))\n\n\t// Get the scale object\n\tgroupResource := schema.GroupResource{\n\t\tGroup:    targetGVK.Group,\n\t\tResource: k8shelper.KindToResource(targetGVK.Kind),\n\t}\n\n\tvar err error\n\tvar currentScale *autoscalingv1.Scale\n\tfor i := 0; i < 2; i++ {\n\t\tcurrentScale, err = h.scaleClient.Scales(namespace).Get(ctx, groupResource, targetName, metav1.GetOptions{})\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif meta.IsNoMatchError(err) {\n\t\t\th.logger.Info(\"retrying scale operation after resetting RESTMapper cache due to NoMatchError\",\n\t\t\t\tzap.String(\"kind\", targetGVK.Kind),\n\t\t\t\tzap.String(\"namespace\", namespace),\n\t\t\t\tzap.String(\"name\", targetName),\n\t\t\t\tzap.Error(err))\n\t\t\th.restMapper.Reset()\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tif err != nil {\n\t\th.createEvent(namespace, targetName, \"Error\", \"FailedToScale\", fmt.Sprintf(\"Failed to scale to %d replicas for %s/%s: %v\", desiredReplicas, targetGVK.Kind, targetName, err))\n\t\treturn false, fmt.Errorf(\"failed to get scale for %s/%s (%s): %w\", targetGVK.Kind, targetName, namespace, err)\n\t}\n\n\t// Check if already at desired replicas\n\tif currentScale.Status.Replicas == desiredReplicas {\n\t\th.logger.Info(\"No scale required. Target already at desired replicas\",\n\t\t\tzap.String(\"kind\", targetGVK.Kind),\n\t\t\tzap.String(\"namespace\", namespace),\n\t\t\tzap.String(\"name\", targetName),\n\t\t\tzap.Int32(\"replicas\", desiredReplicas))\n\t\treturn false, nil\n\t}\n\n\t// Check if already scaled beyond desired (for scale up operations)\n\tif desiredReplicas > 0 && currentScale.Status.Replicas > desiredReplicas {\n\t\th.logger.Info(\"No scale required. Target already scaled beyond desired replicas\",\n\t\t\tzap.String(\"kind\", targetGVK.Kind),\n\t\t\tzap.String(\"namespace\", namespace),\n\t\t\tzap.String(\"name\", targetName),\n\t\t\tzap.Int32(\"current replicas\", currentScale.Status.Replicas),\n\t\t\tzap.Int32(\"desired replicas\", desiredReplicas))\n\t\treturn false, nil\n\t}\n\n\tcurrentScale.Spec.Replicas = desiredReplicas\n\tif _, err := h.scaleClient.Scales(namespace).Update(ctx, groupResource, currentScale, metav1.UpdateOptions{}); err != nil {\n\t\th.createEvent(namespace, targetName, \"Warning\", \"FailedToScale\", fmt.Sprintf(\"Failed to scale %d replicas for %s/%s: %v\", desiredReplicas, targetGVK.Kind, targetName, err))\n\t\treturn false, fmt.Errorf(\"failed to update scale for %s/%s (%s): %w\", targetGVK.Kind, targetName, namespace, err)\n\t}\n\n\th.createEvent(namespace, targetName, \"Normal\", \"SuccessToScale\", fmt.Sprintf(\"Successfully scaled %d replicas for %s/%s\", desiredReplicas, targetGVK.Kind, targetName))\n\th.logger.Info(\"Target scaled\", zap.String(\"kind\", targetGVK.Kind), zap.String(\"namespace\", namespace), zap.String(\"name\", targetName), zap.Int32(\"replicas\", desiredReplicas))\n\treturn true, nil\n}",
    "start_line": 316,
    "end_line": 387,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.Scale",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.Scale"
  },
  "pkg.scaling.scale_handler.ScaleHandler.UpdateKedaScaledObjectPausedState": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.UpdateKedaScaledObjectPausedState",
    "name": "ScaleHandler.UpdateKedaScaledObjectPausedState",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "func (h *ScaleHandler) UpdateKedaScaledObjectPausedState(ctx context.Context, scaledObjectName, namespace string, paused bool) error {\n\tvar patchBytes []byte\n\tif paused {\n\t\t// When pausing, set both annotations: paused=true and paused-replicas=\"0\"\n\t\tpatchBytes = []byte(fmt.Sprintf(`{\"metadata\": {\"annotations\": {\"%s\": \"%s\", \"%s\": \"0\"}}}`,\n\t\t\tkedaPausedAnnotation,\n\t\t\tstrconv.FormatBool(paused),\n\t\t\tkedaPausedReplicasAnnotation))\n\t} else {\n\t\t// When unpausing, set paused=false and remove the paused-replicas annotation\n\t\tpatchBytes = []byte(fmt.Sprintf(`{\"metadata\": {\"annotations\": {\"%s\": \"%s\", \"%s\": null}}}`,\n\t\t\tkedaPausedAnnotation,\n\t\t\tstrconv.FormatBool(paused),\n\t\t\tkedaPausedReplicasAnnotation))\n\t}\n\n\t_, err := h.kDynamicClient.Resource(values.ScaledObjectGVR).Namespace(namespace).Patch(\n\t\tctx,\n\t\tscaledObjectName,\n\t\ttypes.MergePatchType,\n\t\tpatchBytes,\n\t\tmetav1.PatchOptions{},\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to patch ScaledObject: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 389,
    "end_line": 416,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.UpdateKedaScaledObjectPausedState",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.UpdateKedaScaledObjectPausedState"
  },
  "pkg.scaling.scale_handler.ScaleHandler.UpdateLastScaledUpTime": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.UpdateLastScaledUpTime",
    "name": "ScaleHandler.UpdateLastScaledUpTime",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "func (h *ScaleHandler) UpdateLastScaledUpTime(ctx context.Context, crdName, namespace string) error {\n\th.logger.Debug(\"Updating LastScaledUpTime\", zap.String(\"service\", crdName), zap.String(\"namespace\", namespace))\n\tnow := metav1.Now()\n\tpatchBytes := []byte(fmt.Sprintf(`{\"status\": {\"lastScaledUpTime\": \"%s\"}}`, now.Format(time.RFC3339Nano)))\n\n\t_, err := h.kDynamicClient.Resource(values.ElastiServiceGVR).\n\t\tNamespace(namespace).\n\t\tPatch(ctx, crdName, types.MergePatchType, patchBytes, metav1.PatchOptions{}, \"status\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to patch ElastiService status: %w\", err)\n\t}\n\treturn nil\n}",
    "start_line": 418,
    "end_line": 430,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.UpdateLastScaledUpTime",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.UpdateLastScaledUpTime"
  },
  "pkg.scaling.scale_handler.ScaleHandler.createEvent": {
    "id": "pkg.scaling.scale_handler.ScaleHandler.createEvent",
    "name": "ScaleHandler.createEvent",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scale_handler.go",
    "relative_path": "pkg/scaling/scale_handler.go",
    "depends_on": [],
    "source_code": "func (h *ScaleHandler) createEvent(namespace, name, eventType, reason, message string) {\n\th.logger.Info(\"createEvent\", zap.String(\"eventType\", eventType), zap.String(\"reason\", reason), zap.String(\"message\", message))\n\tref := &v1.ObjectReference{\n\t\tAPIVersion: \"elasti.truefoundry.com/v1alpha1\",\n\t\tKind:       \"ElastiService\",\n\t\tName:       name,\n\t\tNamespace:  namespace,\n\t}\n\th.EventRecorder.Event(ref, eventType, reason, message)\n}",
    "start_line": 433,
    "end_line": 442,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ScaleHandler.createEvent",
    "component_id": "pkg.scaling.scale_handler.ScaleHandler.createEvent"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusScaler": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler",
    "name": "prometheusScaler",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [],
    "source_code": "type prometheusScaler struct {\n\thttpClient           *http.Client\n\tmetadata             *prometheusMetadata\n\tcooldownPeriod       time.Duration\n\tdefaultServerAddress string\n\tdefaultHeaders       map[string]string\n}",
    "start_line": 22,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct prometheusScaler",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusMetadata": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusMetadata",
    "name": "prometheusMetadata",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [],
    "source_code": "type prometheusMetadata struct {\n\tServerAddress string            `json:\"serverAddress\"`\n\tQuery         string            `json:\"query\"`\n\tThreshold     float64           `json:\"threshold,string\"`\n\tUptimeFilter  string            `json:\"uptimeFilter\"`\n\tHeaders       map[string]string `json:\"headers\"`\n}",
    "start_line": 30,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct prometheusMetadata",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusMetadata"
  },
  "pkg.scaling.scalers.prometheus_scaler.NewPrometheusScaler": {
    "id": "pkg.scaling.scalers.prometheus_scaler.NewPrometheusScaler",
    "name": "NewPrometheusScaler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [
      "pkg.scaling.scalers.prometheus_scaler.fetchDefaultHeaders",
      "pkg.scaling.scalers.prometheus_scaler.parsePrometheusMetadata"
    ],
    "source_code": "func NewPrometheusScaler(metadata json.RawMessage, cooldownPeriod time.Duration) (Scaler, error) {\n\tparsedMetadata, err := parsePrometheusMetadata(metadata)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating prometheus scaler: %w\", err)\n\t}\n\n\tclient := &http.Client{\n\t\tTimeout: httpClientTimeout,\n\t}\n\n\treturn &prometheusScaler{\n\t\tmetadata:             parsedMetadata,\n\t\thttpClient:           client,\n\t\tcooldownPeriod:       cooldownPeriod,\n\t\tdefaultServerAddress: os.Getenv(\"PROMETHEUS_TRIGGER_SERVER_ADDRESS\"),\n\t\tdefaultHeaders:       fetchDefaultHeaders(),\n\t}, nil\n}",
    "start_line": 49,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewPrometheusScaler",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.NewPrometheusScaler"
  },
  "pkg.scaling.scalers.prometheus_scaler.fetchDefaultHeaders": {
    "id": "pkg.scaling.scalers.prometheus_scaler.fetchDefaultHeaders",
    "name": "fetchDefaultHeaders",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [],
    "source_code": "func fetchDefaultHeaders() map[string]string {\n\theaders := make(map[string]string)\n\n\tauthorizationHeader := os.Getenv(\"PROMETHEUS_TRIGGER_AUTHORIZATION_HEADER\")\n\tif authorizationHeader != \"\" {\n\t\theaders[\"Authorization\"] = authorizationHeader\n\t}\n\n\treturn headers\n}",
    "start_line": 68,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetchDefaultHeaders",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.fetchDefaultHeaders"
  },
  "pkg.scaling.scalers.prometheus_scaler.parsePrometheusMetadata": {
    "id": "pkg.scaling.scalers.prometheus_scaler.parsePrometheusMetadata",
    "name": "parsePrometheusMetadata",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [],
    "source_code": "func parsePrometheusMetadata(jsonMetadata json.RawMessage) (*prometheusMetadata, error) {\n\tmetadata := &prometheusMetadata{}\n\terr := json.Unmarshal(jsonMetadata, metadata)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse metadata: %w\", err)\n\t}\n\treturn metadata, nil\n}",
    "start_line": 79,
    "end_line": 86,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parsePrometheusMetadata",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.parsePrometheusMetadata"
  },
  "pkg.scaling.scalers.prometheus_scaler.queryEscape": {
    "id": "pkg.scaling.scalers.prometheus_scaler.queryEscape",
    "name": "queryEscape",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [],
    "source_code": "func queryEscape(query string) string {\n\tqueryEscaped := url.QueryEscape(query)\n\tplusEscaped := strings.ReplaceAll(queryEscaped, \"+\", \"%20\")\n\n\treturn plusEscaped\n}",
    "start_line": 89,
    "end_line": 94,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function queryEscape",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.queryEscape"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.executePromQuery": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.executePromQuery",
    "name": "prometheusScaler.executePromQuery",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [
      "pkg.scaling.scalers.prometheus_scaler.queryEscape",
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close"
    ],
    "source_code": "func (s *prometheusScaler) executePromQuery(ctx context.Context, query string) (float64, error) {\n\tt := time.Now().UTC().Format(time.RFC3339)\n\tqueryEscaped := queryEscape(query)\n\tserverAddress := s.defaultServerAddress\n\tif s.metadata.ServerAddress != \"\" {\n\t\tserverAddress = s.metadata.ServerAddress\n\t}\n\tif serverAddress == \"\" {\n\t\treturn -1, fmt.Errorf(\"prometheus serverAddress not configured\")\n\t}\n\tqueryURL := fmt.Sprintf(\"%s/api/v1/query?query=%s&time=%s\", serverAddress, queryEscaped, t)\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", queryURL, nil)\n\tif err != nil {\n\t\treturn -1, fmt.Errorf(\"failed to create HTTP request: %w\", err)\n\t}\n\n\t// Apply default headers, then per-trigger metadata headers (which can override defaults)\n\tfor key, value := range s.defaultHeaders {\n\t\treq.Header.Set(key, value)\n\t}\n\tfor key, value := range s.metadata.Headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tresp, err := s.httpClient.Do(req)\n\tif err != nil {\n\t\treturn -1, fmt.Errorf(\"failed to execute HTTP request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn -1, fmt.Errorf(\"unexpected HTTP status: %s\", resp.Status)\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&promQueryResponse); err != nil {\n\t\treturn -1, fmt.Errorf(\"failed to decode Prometheus response: %w\", err)\n\t}\n\n\tvar v float64 = -1\n\n\tif len(promQueryResponse.Data.Result) == 0 {\n\t\treturn -1, fmt.Errorf(\"prometheus query %s, result is empty, prometheus metrics 'prometheus' target may be lost\", query)\n\t} else if len(promQueryResponse.Data.Result) > 1 {\n\t\treturn -1, fmt.Errorf(\"prometheus query %s returned multiple elements\", query)\n\t}\n\n\tvalueLen := len(promQueryResponse.Data.Result[0].Value)\n\tif valueLen == 0 {\n\t\treturn -1, fmt.Errorf(\"prometheus query %s, value list in result is empty, prometheus metrics 'prometheus' target may be lost\", s.metadata.Query)\n\t} else if valueLen < 2 {\n\t\treturn -1, fmt.Errorf(\"prometheus query %s didn't return enough values\", s.metadata.Query)\n\t}\n\n\tval := promQueryResponse.Data.Result[0].Value[1]\n\tif val != nil {\n\t\tstr := val.(string)\n\t\tv, err = strconv.ParseFloat(str, 64)\n\t\tif err != nil {\n\t\t\treturn -1, fmt.Errorf(\"failed to parse metric value: %w\", err)\n\t\t}\n\t}\n\n\tif math.IsInf(v, 0) {\n\t\treturn -1, fmt.Errorf(\"prometheus query returns %f\", v)\n\t}\n\n\treturn v, nil\n}",
    "start_line": 96,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method prometheusScaler.executePromQuery",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.executePromQuery"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleToZero": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleToZero",
    "name": "prometheusScaler.ShouldScaleToZero",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.executePromQuery"
    ],
    "source_code": "func (s *prometheusScaler) ShouldScaleToZero(ctx context.Context) (bool, error) {\n\tmetricValue, err := s.executePromQuery(ctx, s.metadata.Query)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to execute prometheus query %s: %w\", s.metadata.Query, err)\n\t}\n\n\tif metricValue == -1 {\n\t\treturn false, nil\n\t}\n\tif metricValue < s.metadata.Threshold {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}",
    "start_line": 166,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method prometheusScaler.ShouldScaleToZero",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleToZero"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleFromZero": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleFromZero",
    "name": "prometheusScaler.ShouldScaleFromZero",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.executePromQuery"
    ],
    "source_code": "func (s *prometheusScaler) ShouldScaleFromZero(ctx context.Context) (bool, error) {\n\tmetricValue, err := s.executePromQuery(ctx, s.metadata.Query)\n\tif err != nil {\n\t\treturn true, fmt.Errorf(\"failed to execute prometheus query %s: %w\", s.metadata.Query, err)\n\t}\n\tif metricValue == -1 {\n\t\treturn true, nil\n\t}\n\n\tif metricValue >= s.metadata.Threshold {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}",
    "start_line": 181,
    "end_line": 194,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method prometheusScaler.ShouldScaleFromZero",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.ShouldScaleFromZero"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close",
    "name": "prometheusScaler.Close",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [],
    "source_code": "func (s *prometheusScaler) Close(_ context.Context) error {\n\tif s.httpClient != nil {\n\t\ts.httpClient.CloseIdleConnections()\n\t}\n\treturn nil\n}",
    "start_line": 196,
    "end_line": 201,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method prometheusScaler.Close",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close"
  },
  "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.IsHealthy": {
    "id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.IsHealthy",
    "name": "prometheusScaler.IsHealthy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/prometheus_scaler.go",
    "relative_path": "pkg/scaling/scalers/prometheus_scaler.go",
    "depends_on": [
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.executePromQuery"
    ],
    "source_code": "func (s *prometheusScaler) IsHealthy(ctx context.Context) (bool, error) {\n\tuptimeFilter := s.metadata.UptimeFilter\n\tif uptimeFilter == \"\" {\n\t\tuptimeFilter = defaultUptimeFilter\n\t}\n\n\tcooldownPeriodSeconds := int(math.Ceil(s.cooldownPeriod.Seconds()))\n\tfinalUptimeQuery := fmt.Sprintf(uptimeQuery, uptimeFilter, cooldownPeriodSeconds)\n\n\tmetricValue, err := s.executePromQuery(\n\t\tctx,\n\t\tfinalUptimeQuery,\n\t)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to execute prometheus query %s: %w\", finalUptimeQuery, err)\n\t}\n\treturn metricValue == 1, nil\n}",
    "start_line": 203,
    "end_line": 220,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method prometheusScaler.IsHealthy",
    "component_id": "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.IsHealthy"
  },
  "pkg.scaling.scalers.scaler.Scaler": {
    "id": "pkg.scaling.scalers.scaler.Scaler",
    "name": "Scaler",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/scaling/scalers/scaler.go",
    "relative_path": "pkg/scaling/scalers/scaler.go",
    "depends_on": [],
    "source_code": "type Scaler interface {\n\tIsHealthy(ctx context.Context) (bool, error)\n\tShouldScaleToZero(ctx context.Context) (bool, error)\n\tShouldScaleFromZero(ctx context.Context) (bool, error)\n\tClose(ctx context.Context) error\n}",
    "start_line": 7,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "interface",
    "base_classes": null,
    "class_name": null,
    "display_name": "interface Scaler",
    "component_id": "pkg.scaling.scalers.scaler.Scaler"
  },
  "pkg.utils.utils.GetPrivateServiceName": {
    "id": "pkg.utils.utils.GetPrivateServiceName",
    "name": "GetPrivateServiceName",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/utils/utils.go",
    "relative_path": "pkg/utils/utils.go",
    "depends_on": [
      "pkg.logger.logger.CustomCore.Write"
    ],
    "source_code": "func GetPrivateServiceName(publicSVCName string) string {\n\thash := sha256.New()\n\thash.Write([]byte(publicSVCName))\n\thashed := hex.EncodeToString(hash.Sum(nil))\n\tpvtName := prefix + publicSVCName + privateServicePostfix + \"-\" + hashed[:10]\n\treturn pvtName\n}",
    "start_line": 18,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function GetPrivateServiceName",
    "component_id": "pkg.utils.utils.GetPrivateServiceName"
  },
  "pkg.utils.utils.GetEndpointSliceToResolverName": {
    "id": "pkg.utils.utils.GetEndpointSliceToResolverName",
    "name": "GetEndpointSliceToResolverName",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/pkg/utils/utils.go",
    "relative_path": "pkg/utils/utils.go",
    "depends_on": [
      "pkg.logger.logger.CustomCore.Write"
    ],
    "source_code": "func GetEndpointSliceToResolverName(serviceName string) string {\n\thash := sha256.New()\n\thash.Write([]byte(serviceName))\n\thashed := hex.EncodeToString(hash.Sum(nil))\n\treturn prefix + serviceName + endpointSlicePostfix + \"-\" + hashed[:10]\n}",
    "start_line": 27,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function GetEndpointSliceToResolverName",
    "component_id": "pkg.utils.utils.GetEndpointSliceToResolverName"
  },
  "resolver.cmd.main.config": {
    "id": "resolver.cmd.main.config",
    "name": "config",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/cmd/main.go",
    "relative_path": "resolver/cmd/main.go",
    "depends_on": [],
    "source_code": "type config struct {\n\tMaxIdleProxyConns        int `split_words:\"true\" default:\"1000\"`\n\tMaxIdleProxyConnsPerHost int `split_words:\"true\" default:\"100\"`\n\t// ReqTimeout is the timeout for each request\n\tReqTimeout int `split_words:\"true\" default:\"600\"`\n\t// TrafficReEnableDuration is the duration for which the traffic is disabled for a host\n\t// This is also duration for which we don't recheck readiness of the service\n\tTrafficReEnableDuration int `split_words:\"true\" default:\"30\"`\n\t// OperatorRetryDuration is the duration for which we don't inform the operator\n\t// about the traffic on the same host\n\tOperatorRetryDuration int `split_words:\"true\" default:\"30\"`\n\t// QueueRetryDuration is the duration after we retry the requests in queue\n\tQueueRetryDuration int `split_words:\"true\" default:\"5\"`\n\t// QueueSize is the size of the queue\n\tQueueSize int `split_words:\"true\" default:\"100\"`\n\t// MaxQueueConcurrency is the maximum number of concurrent requests\n\tMaxQueueConcurrency int `split_words:\"true\" default:\"10\"`\n\t// InitialCapacity is the initial capacity of the semaphore\n\tInitialCapacity int `split_words:\"true\" default:\"100\"`\n\t// HeaderForHost is the header to look for to get the host\n\tHeaderForHost string `split_words:\"true\" default:\"Host\"`\n\t// Sentry config\n\tSentryDsn string `split_words:\"true\" default:\"\"`\n\tSentryEnv string `envconfig:\"SENTRY_ENVIRONMENT\" default:\"\"`\n\t// H2C\n\tEnableH2C bool `envconfig:\"ENABLE_H2C\" default:\"false\"`\n}",
    "start_line": 30,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct config",
    "component_id": "resolver.cmd.main.config"
  },
  "resolver.cmd.main.main": {
    "id": "resolver.cmd.main.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/cmd/main.go",
    "relative_path": "resolver/cmd/main.go",
    "depends_on": [
      "resolver.internal.handler.handler.NewHandler",
      "resolver.internal.throttler.throttler.NewThrottler",
      "resolver.internal.throttler.transport.NewProxyAutoTransport",
      "resolver.internal.hostmanager.hostManager.NewHostManager",
      "resolver.internal.operator.RPCClient.NewOperatorClient",
      "pkg.k8shelper.ops.NewOps",
      "pkg.config.config.GetResolverConfig",
      "pkg.logger.logger.NewLogger"
    ],
    "source_code": "func main() {\n\tvar env config\n\tif err := envconfig.Process(\"\", &env); err != nil {\n\t\tlog.Fatal(\"Failed to process env: \", err)\n\t}\n\n\tsentryEnabled := env.SentryDsn != \"\"\n\tif sentryEnabled {\n\t\tfmt.Println(\"Initializing Sentry\")\n\t\tif err := sentry.Init(sentry.ClientOptions{\n\t\t\tDsn:              env.SentryDsn,\n\t\t\tEnableTracing:    false,\n\t\t\tTracesSampleRate: 1.0,\n\t\t\tEnvironment:      env.SentryEnv,\n\t\t}); err != nil {\n\t\t\tfmt.Println(\"Sentry initialization failed:\", err)\n\t\t}\n\t}\n\n\tlogger, err := logger.NewLogger(\"dev\", sentryEnabled)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to get logger: \", err)\n\t}\n\tif sentryEnabled {\n\t\tdefer sentry.Flush(2 * time.Second)\n\t}\n\n\tconfig, err := rest.InClusterConfig()\n\tif err != nil {\n\t\tlogger.Fatal(\"Error fetching cluster config\", zap.Error(err))\n\t}\n\n\t// Get components required for the handler\n\tk8sUtil := k8shelper.NewOps(logger, config)\n\tnewOperatorRPC := operator.NewOperatorClient(logger, time.Duration(env.OperatorRetryDuration)*time.Second)\n\tnewHostManager := hostmanager.NewHostManager(logger, time.Duration(env.TrafficReEnableDuration)*time.Second, env.HeaderForHost)\n\tnewTransport := throttler.NewProxyAutoTransport(env.MaxIdleProxyConns, env.MaxIdleProxyConnsPerHost)\n\tnewThrottler := throttler.NewThrottler(&throttler.Params{\n\t\tQueueRetryDuration:      time.Duration(env.QueueRetryDuration) * time.Second,\n\t\tK8sUtil:                 k8sUtil,\n\t\tQueueDepth:              env.QueueSize,\n\t\tMaxConcurrency:          env.MaxQueueConcurrency,\n\t\tInitialCapacity:         env.InitialCapacity,\n\t\tTrafficReEnableDuration: time.Duration(env.TrafficReEnableDuration) * time.Second,\n\t\tLogger:                  logger,\n\t})\n\n\t// Create an instance of sentryhttp\n\tsentryHandler := sentryhttp.New(sentryhttp.Options{})\n\n\t// Create a handler\n\trequestHandler := handler.NewHandler(&handler.Params{\n\t\tLogger:      logger,\n\t\tReqTimeout:  time.Duration(env.ReqTimeout) * time.Second,\n\t\tOperatorRPC: newOperatorRPC,\n\t\tHostManager: newHostManager,\n\t\tThrottler:   newThrottler,\n\t\tTransport:   newTransport,\n\t})\n\n\t// Handle all the incoming requests\n\treverseProxyPort := fmt.Sprintf(\":%d\", elasti_config.GetResolverConfig().ReverseProxyPort)\n\treverseProxyServerMux := http.NewServeMux()\n\treverseProxyServerMux.Handle(\"/\", sentryHandler.HandleFunc(requestHandler.ServeHTTP))\n\n\treverseProxyServer := &http.Server{\n\t\tAddr:              reverseProxyPort,\n\t\tHandler:           reverseProxyServerMux,\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t}\n\n\tif env.EnableH2C {\n\t\th2s := &http2.Server{}\n\t\treverseProxyServer.Handler = h2c.NewHandler(reverseProxyServerMux, h2s)\n\t}\n\n\tlogger.Info(\"Reverse Proxy Server starting at \", zap.String(\"port\", reverseProxyPort))\n\tgo func() {\n\t\tif err := reverseProxyServer.ListenAndServe(); err != nil {\n\t\t\tlogger.Fatal(\"ListenAndServe Failed: \", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Handle all the incoming internal request like from prometheus that are not related to the reverse proxy\n\tinternalPort := fmt.Sprintf(\":%d\", elasti_config.GetResolverConfig().Port)\n\tinternalServeMux := http.NewServeMux()\n\tinternalServeMux.Handle(\"/metrics\", promhttp.Handler())\n\tinternalServeMux.Handle(\"/queue-status\", sentryHandler.HandleFunc(requestHandler.GetQueueStatus))\n\tinternalServer := &http.Server{\n\t\tAddr:              internalPort,\n\t\tHandler:           internalServeMux,\n\t\tReadHeaderTimeout: 2 * time.Second,\n\t}\n\tlogger.Info(\"Internal Server starting at \", zap.String(\"port\", internalPort))\n\tif err := internalServer.ListenAndServe(); err != nil {\n\t\tlogger.Fatal(\"ListenAndServe Failed: \", zap.Error(err))\n\t}\n}",
    "start_line": 58,
    "end_line": 155,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "resolver.cmd.main.main"
  },
  "resolver.internal.handler.handler.HostManager": {
    "id": "resolver.internal.handler.handler.HostManager",
    "name": "HostManager",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [],
    "source_code": "type (\n\t// Handler is the reverse proxy handler\n\tHandler struct {\n\t\tlogger      *zap.Logger\n\t\tthrottler   *throttler.Throttler\n\t\ttransport   http.RoundTripper\n\t\tbufferPool  httputil.BufferPool\n\t\ttimeout     time.Duration\n\t\toperatorRPC Operator\n\t\thostManager HostManager\n\t}\n\n\t// Params is the configuration for the handler\n\tParams struct {\n\t\tLogger      *zap.Logger\n\t\tReqTimeout  time.Duration\n\t\tOperatorRPC Operator\n\t\tHostManager HostManager\n\t\tThrottler   *throttler.Throttler\n\t\tTransport   http.RoundTripper\n\t}\n\n\t// Operator is to communicate with the operator\n\tOperator interface {\n\t\tSendIncomingRequestInfo(ns, svc string)\n\t}\n\n\t// HostManager is to manage the hosts, and their traffic\n\tHostManager interface {\n\t\tGetHost(req *http.Request) (*messages.Host, error)\n\t\tDisableTrafficForHost(service string)\n\t}\n)",
    "start_line": 23,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "interface",
    "base_classes": null,
    "class_name": null,
    "display_name": "interface HostManager",
    "component_id": "resolver.internal.handler.handler.HostManager"
  },
  "resolver.internal.handler.handler.NewHandler": {
    "id": "resolver.internal.handler.handler.NewHandler",
    "name": "NewHandler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.NewBufferPool"
    ],
    "source_code": "func NewHandler(hc *Params) *Handler {\n\treturn &Handler{\n\t\tthrottler:   hc.Throttler,\n\t\tlogger:      hc.Logger.With(zap.String(\"component\", \"handler\")),\n\t\ttransport:   hc.Transport,\n\t\tbufferPool:  NewBufferPool(),\n\t\ttimeout:     hc.ReqTimeout,\n\t\toperatorRPC: hc.OperatorRPC,\n\t\thostManager: hc.HostManager,\n\t}\n}",
    "start_line": 58,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewHandler",
    "component_id": "resolver.internal.handler.handler.NewHandler"
  },
  "resolver.internal.handler.handler.Response": {
    "id": "resolver.internal.handler.handler.Response",
    "name": "Response",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [],
    "source_code": "type Response struct {\n\tMessage string `json:\"message\"`\n}",
    "start_line": 70,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Response",
    "component_id": "resolver.internal.handler.handler.Response"
  },
  "resolver.internal.handler.handler.QueueStatusResponse": {
    "id": "resolver.internal.handler.handler.QueueStatusResponse",
    "name": "QueueStatusResponse",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [],
    "source_code": "type QueueStatusResponse struct {\n\tQueueStatus int `json:\"queueStatus\"`\n}",
    "start_line": 74,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct QueueStatusResponse",
    "component_id": "resolver.internal.handler.handler.QueueStatusResponse"
  },
  "resolver.internal.handler.handler.Handler.ServeHTTP": {
    "id": "resolver.internal.handler.handler.Handler.ServeHTTP",
    "name": "Handler.ServeHTTP",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.writer.newResponseWriter",
      "resolver.internal.handler.handler.Handler.handleAnyRequest"
    ],
    "source_code": "func (h *Handler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tstart := time.Now()\n\tcustomWriter := newResponseWriter(w)\n\thost, err := h.handleAnyRequest(customWriter, req)\n\tvar responseStatus, errorMessage string\n\tif err != nil {\n\t\terrorMessage = err.Error()\n\t}\n\tresponseStatus = http.StatusText(customWriter.statusCode)\n\tduration := time.Since(start).Seconds()\n\tprom.IncomingRequestHistogram.WithLabelValues(\n\t\thost.SourceService,\n\t\thost.TargetService,\n\t\thost.SourceHost,\n\t\thost.TargetHost,\n\t\thost.Namespace,\n\t\treq.Method,\n\t\treq.RequestURI,\n\t\tresponseStatus,\n\t\terrorMessage,\n\t).Observe(duration)\n}",
    "start_line": 78,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Handler.ServeHTTP",
    "component_id": "resolver.internal.handler.handler.Handler.ServeHTTP"
  },
  "resolver.internal.handler.handler.Handler.handleAnyRequest": {
    "id": "resolver.internal.handler.handler.Handler.handleAnyRequest",
    "name": "Handler.handleAnyRequest",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.hostmanager.hostManager.HostManager.DisableTrafficForHost",
      "resolver.internal.handler.writer.responseWriter.WriteHeader",
      "pkg.logger.logger.MaskMiddle",
      "resolver.internal.hostmanager.hostManager.HostManager.GetHost",
      "resolver.internal.handler.handler.Handler.ProxyRequest",
      "pkg.logger.logger.CustomCore.Write",
      "resolver.internal.throttler.throttler.Throttler.Try",
      "resolver.internal.handler.writer.responseWriter.Header",
      "resolver.internal.operator.RPCClient.Client.SendIncomingRequestInfo"
    ],
    "source_code": "func (h *Handler) handleAnyRequest(w http.ResponseWriter, req *http.Request) (*messages.Host, error) {\n\thost, err := h.hostManager.GetHost(req)\n\tif err != nil {\n\t\thttp.Error(w, \"Error getting host\", http.StatusInternalServerError)\n\t\th.logger.Error(\"error getting host\", zap.Error(err))\n\t\treturn host, fmt.Errorf(\"error getting host: %w\", err)\n\t}\n\th.logger.Debug(\"request received\", zap.Any(\"host\", logger.MaskMiddle(host.IncomingHost, 4, 4)))\n\n\tprom.QueuedRequestGauge.WithLabelValues(host.SourceService, host.Namespace).Inc()\n\tdefer prom.QueuedRequestGauge.WithLabelValues(host.SourceService, host.Namespace).Dec()\n\n\t// This closes the connections, in case the host is scaled up by the controller.\n\tif !host.TrafficAllowed {\n\t\th.logger.Info(\"Traffic not allowed\", zap.Any(\"host\", logger.MaskMiddle(host.IncomingHost, 4, 4)))\n\t\tw.Header().Set(\"Connection\", \"close\")\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusForbidden)\n\t\t_, err := w.Write([]byte(`{\"error\": \"traffic is switched\"}`))\n\t\tif err != nil {\n\t\t\th.logger.Error(\"Error writing response\", zap.Error(err))\n\t\t\treturn host, fmt.Errorf(\"error writing response: %w\", err)\n\t\t}\n\t\treturn host, fmt.Errorf(\"traffic not allowed by resolver\")\n\t}\n\n\t// Inform the controller about the incoming request\n\tgo h.operatorRPC.SendIncomingRequestInfo(host.Namespace, host.SourceService)\n\n\t// Send request to throttler\n\tctx, cancel := context.WithTimeout(context.Background(), h.timeout)\n\tdefer cancel()\n\tif tryErr := h.throttler.Try(ctx, host,\n\t\tfunc(count int) error {\n\t\t\terr := h.ProxyRequest(w, req, host, count)\n\t\t\tif err != nil {\n\t\t\t\th.logger.Error(\"Error proxying request\", zap.Error(err))\n\t\t\t\thub := sentry.GetHubFromContext(req.Context())\n\t\t\t\thub.CaptureException(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\th.hostManager.DisableTrafficForHost(host.IncomingHost)\n\t\t\treturn nil\n\t\t}, func() {\n\t\t\th.operatorRPC.SendIncomingRequestInfo(host.Namespace, host.SourceService)\n\t\t}); tryErr != nil {\n\t\t// NOTE: Below line throws a CWE, but we identified it as false positive\n\t\t// As we just pass host information like namespace and service name, it is safe to ignore this\n\t\t// See: https://github.com/truefoundry/KubeElasti/pull/177\n\t\th.logger.Error(\"throttler try error: \", zap.Error(tryErr))\n\t\thub := sentry.GetHubFromContext(req.Context())\n\t\tif hub != nil {\n\t\t\thub.CaptureException(tryErr)\n\t\t}\n\n\t\tif errors.Is(tryErr, context.DeadlineExceeded) {\n\t\t\thttp.Error(w, \"request timeout\", http.StatusRequestTimeout)\n\t\t\treturn host, fmt.Errorf(\"throttler try error: %w\", tryErr)\n\t\t}\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn host, fmt.Errorf(\"throttler try error: %w\", tryErr)\n\t}\n\treturn host, nil\n}",
    "start_line": 102,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Handler.handleAnyRequest",
    "component_id": "resolver.internal.handler.handler.Handler.handleAnyRequest"
  },
  "resolver.internal.handler.handler.Handler.ProxyRequest": {
    "id": "resolver.internal.handler.handler.Handler.ProxyRequest",
    "name": "Handler.ProxyRequest",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.Handler.ServeHTTP",
      "resolver.internal.handler.writer.responseWriter.WriteHeader",
      "pkg.logger.logger.CustomCore.Write",
      "resolver.internal.handler.handler.bufferPool.Get",
      "resolver.internal.handler.handler.Handler.NewHeaderPruningReverseProxy",
      "resolver.internal.handler.writer.responseWriter.Header"
    ],
    "source_code": "func (h *Handler) ProxyRequest(w http.ResponseWriter, req *http.Request, host *messages.Host, count int) (rErr error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\trErr = fmt.Errorf(\"panic in ProxyRequest: %w\", r.(error))\n\t\t}\n\t}()\n\ttargetURL, err := url.Parse(host.TargetHost + req.RequestURI)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing target URL: %w\", err)\n\t}\n\n\tproxy := h.NewHeaderPruningReverseProxy(targetURL)\n\tproxy.BufferPool = h.bufferPool\n\tproxy.Transport = h.transport\n\tproxy.ErrorHandler = func(wErr http.ResponseWriter, reqErr *http.Request, err error) {\n\t\th.logger.Error(\"reverse proxy error\", zap.Error(err), zap.String(\"url\", reqErr.URL.String()))\n\t\tif wErr.Header().Get(\"Content-Type\") == \"\" {\n\t\t\twErr.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\t\twErr.WriteHeader(http.StatusBadGateway)\n\t\t\t_, err = wErr.Write([]byte(\"Bad Gateway\"))\n\t\t\tif err != nil {\n\t\t\t\th.logger.Error(\"error writing response\", zap.Error(err))\n\t\t\t}\n\t\t}\n\t}\n\th.logger.Info(\"Request proxied\", zap.Int(\"Retry Count\", count))\n\tproxy.ServeHTTP(w, req)\n\treturn nil\n}",
    "start_line": 167,
    "end_line": 195,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Handler.ProxyRequest",
    "component_id": "resolver.internal.handler.handler.Handler.ProxyRequest"
  },
  "resolver.internal.handler.handler.Handler.NewHeaderPruningReverseProxy": {
    "id": "resolver.internal.handler.handler.Handler.NewHeaderPruningReverseProxy",
    "name": "Handler.NewHeaderPruningReverseProxy",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get"
    ],
    "source_code": "func (h *Handler) NewHeaderPruningReverseProxy(target *url.URL) *httputil.ReverseProxy {\n\treturn &httputil.ReverseProxy{\n\t\tDirector: func(req *http.Request) {\n\t\t\toriginalHost := req.Host // Save the original host\n\t\t\treq.URL = target\n\t\t\treq.Header.Set(\"X-Forwarded-Host\", originalHost)\n\n\t\t\t// Forward the authority header which is important for HTTP/2 and gRPC\n\t\t\t// In HTTP/2, :authority should contain the host and optionally the port\n\t\t\t// It's equivalent to the Host header in HTTP/1.1\n\t\t\tif req.Header.Get(\":authority\") != \"\" {\n\t\t\t\t// Use originalHost which should already be in the correct format (host:port if non-default port)\n\t\t\t\treq.Header.Set(\":authority\", originalHost)\n\t\t\t}\n\n\t\t\t// This ensures the target service sees the original host\n\t\t\treq.Host = originalHost\n\t\t},\n\t}\n}",
    "start_line": 199,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Handler.NewHeaderPruningReverseProxy",
    "component_id": "resolver.internal.handler.handler.Handler.NewHeaderPruningReverseProxy"
  },
  "resolver.internal.handler.handler.Handler.GetQueueStatus": {
    "id": "resolver.internal.handler.handler.Handler.GetQueueStatus",
    "name": "Handler.GetQueueStatus",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get",
      "resolver.internal.throttler.throttler.Throttler.GetQueueSize",
      "resolver.internal.handler.writer.responseWriter.Header"
    ],
    "source_code": "func (h *Handler) GetQueueStatus(w http.ResponseWriter, r *http.Request) {\n\tnamespace := r.URL.Query().Get(\"namespace\")\n\tservice := r.URL.Query().Get(\"service\")\n\n\tqueueSize := h.throttler.GetQueueSize(namespace, service)\n\tresponse := QueueStatusResponse{}\n\n\tif queueSize > 0 {\n\t\tresponse.QueueStatus = 1\n\t} else {\n\t\tresponse.QueueStatus = 0\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\terr := json.NewEncoder(w).Encode(response)\n\tif err != nil {\n\t\th.logger.Error(\"Failed to encode queue size response\",\n\t\t\tzap.Error(err),\n\t\t\tzap.String(\"namespace\", namespace),\n\t\t\tzap.String(\"service\", service),\n\t\t)\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}",
    "start_line": 220,
    "end_line": 244,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Handler.GetQueueStatus",
    "component_id": "resolver.internal.handler.handler.Handler.GetQueueStatus"
  },
  "resolver.internal.handler.handler.bufferPool": {
    "id": "resolver.internal.handler.handler.bufferPool",
    "name": "bufferPool",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [],
    "source_code": "type bufferPool struct {\n\tpool *sync.Pool\n}",
    "start_line": 246,
    "end_line": 248,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct bufferPool",
    "component_id": "resolver.internal.handler.handler.bufferPool"
  },
  "resolver.internal.handler.handler.bufferPool.Get": {
    "id": "resolver.internal.handler.handler.bufferPool.Get",
    "name": "bufferPool.Get",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Get"
    ],
    "source_code": "func (b *bufferPool) Get() []byte {\n\tbuf := b.pool.Get()\n\tif buf == nil {\n\t\t// Use the default buffer size as defined in the ReverseProxy itself.\n\t\treturn make([]byte, 32*1024)\n\t}\n\n\treturn *buf.(*[]byte)\n}",
    "start_line": 252,
    "end_line": 260,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method bufferPool.Get",
    "component_id": "resolver.internal.handler.handler.bufferPool.Get"
  },
  "resolver.internal.handler.handler.bufferPool.Put": {
    "id": "resolver.internal.handler.handler.bufferPool.Put",
    "name": "bufferPool.Put",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [
      "resolver.internal.handler.handler.bufferPool.Put"
    ],
    "source_code": "func (b *bufferPool) Put(buffer []byte) {\n\tb.pool.Put(&buffer)\n}",
    "start_line": 263,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method bufferPool.Put",
    "component_id": "resolver.internal.handler.handler.bufferPool.Put"
  },
  "resolver.internal.handler.handler.NewBufferPool": {
    "id": "resolver.internal.handler.handler.NewBufferPool",
    "name": "NewBufferPool",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/handler.go",
    "relative_path": "resolver/internal/handler/handler.go",
    "depends_on": [],
    "source_code": "func NewBufferPool() httputil.BufferPool {\n\treturn &bufferPool{\n\t\t// We don't use the New function of sync.Pool here to avoid an unnecessary\n\t\t// allocation when creating the slices. They are implicitly created in the\n\t\t// Get function below.\n\t\tpool: &sync.Pool{},\n\t}\n}",
    "start_line": 267,
    "end_line": 274,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewBufferPool",
    "component_id": "resolver.internal.handler.handler.NewBufferPool"
  },
  "resolver.internal.handler.writer.responseWriter": {
    "id": "resolver.internal.handler.writer.responseWriter",
    "name": "responseWriter",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/writer.go",
    "relative_path": "resolver/internal/handler/writer.go",
    "depends_on": [],
    "source_code": "type responseWriter struct {\n\thttp.ResponseWriter\n\tstatusCode int\n\tbody       []byte\n}",
    "start_line": 8,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct responseWriter",
    "component_id": "resolver.internal.handler.writer.responseWriter"
  },
  "resolver.internal.handler.writer.newResponseWriter": {
    "id": "resolver.internal.handler.writer.newResponseWriter",
    "name": "newResponseWriter",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/writer.go",
    "relative_path": "resolver/internal/handler/writer.go",
    "depends_on": [],
    "source_code": "func newResponseWriter(w http.ResponseWriter) *responseWriter {\n\treturn &responseWriter{ResponseWriter: w, statusCode: 0}\n}",
    "start_line": 14,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function newResponseWriter",
    "component_id": "resolver.internal.handler.writer.newResponseWriter"
  },
  "resolver.internal.handler.writer.responseWriter.WriteHeader": {
    "id": "resolver.internal.handler.writer.responseWriter.WriteHeader",
    "name": "responseWriter.WriteHeader",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/writer.go",
    "relative_path": "resolver/internal/handler/writer.go",
    "depends_on": [
      "resolver.internal.handler.writer.responseWriter.WriteHeader"
    ],
    "source_code": "func (rw *responseWriter) WriteHeader(statusCode int) {\n\trw.statusCode = statusCode\n\trw.ResponseWriter.WriteHeader(statusCode)\n}",
    "start_line": 18,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method responseWriter.WriteHeader",
    "component_id": "resolver.internal.handler.writer.responseWriter.WriteHeader"
  },
  "resolver.internal.handler.writer.responseWriter.Write": {
    "id": "resolver.internal.handler.writer.responseWriter.Write",
    "name": "responseWriter.Write",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/writer.go",
    "relative_path": "resolver/internal/handler/writer.go",
    "depends_on": [
      "pkg.logger.logger.CustomCore.Write"
    ],
    "source_code": "func (rw *responseWriter) Write(b []byte) (int, error) {\n\trw.body = append(rw.body, b...)\n\tres, err := rw.ResponseWriter.Write(b)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"Write: %w\", err)\n\t}\n\n\treturn res, nil\n}",
    "start_line": 23,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method responseWriter.Write",
    "component_id": "resolver.internal.handler.writer.responseWriter.Write"
  },
  "resolver.internal.handler.writer.responseWriter.Header": {
    "id": "resolver.internal.handler.writer.responseWriter.Header",
    "name": "responseWriter.Header",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/handler/writer.go",
    "relative_path": "resolver/internal/handler/writer.go",
    "depends_on": [
      "resolver.internal.handler.writer.responseWriter.Header"
    ],
    "source_code": "func (rw *responseWriter) Header() http.Header {\n\treturn rw.ResponseWriter.Header()\n}",
    "start_line": 33,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method responseWriter.Header",
    "component_id": "resolver.internal.handler.writer.responseWriter.Header"
  },
  "resolver.internal.hostmanager.hostManager.HostManager": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager",
    "name": "HostManager",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [],
    "source_code": "type HostManager struct {\n\tlogger                  *zap.Logger\n\thosts                   sync.Map\n\ttrafficReEnableDuration time.Duration\n\theaderForHost           string\n}",
    "start_line": 23,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct HostManager",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager"
  },
  "resolver.internal.hostmanager.hostManager.NewHostManager": {
    "id": "resolver.internal.hostmanager.hostManager.NewHostManager",
    "name": "NewHostManager",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [],
    "source_code": "func NewHostManager(logger *zap.Logger, trafficReEnableDuration time.Duration, headerForHost string) *HostManager {\n\treturn &HostManager{\n\t\tlogger:                  logger.With(zap.String(\"component\", \"hostManager\")),\n\t\thosts:                   sync.Map{},\n\t\ttrafficReEnableDuration: trafficReEnableDuration,\n\t\theaderForHost:           headerForHost,\n\t}\n}",
    "start_line": 31,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewHostManager",
    "component_id": "resolver.internal.hostmanager.hostManager.NewHostManager"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.GetHost": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.GetHost",
    "name": "HostManager.GetHost",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [
      "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingWildcardIfNeeded",
      "pkg.utils.utils.GetPrivateServiceName",
      "resolver.internal.hostmanager.hostManager.HostManager.extractNamespaceAndService",
      "resolver.internal.hostmanager.hostManager.HostManager.addHTTPIfNeeded",
      "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingPathIfNeeded",
      "resolver.internal.hostmanager.hostManager.HostManager.replaceServiceName"
    ],
    "source_code": "func (hm *HostManager) GetHost(req *http.Request) (*messages.Host, error) {\n\tincomingHost := req.Host\n\tif values, ok := req.Header[hm.headerForHost]; ok {\n\t\tincomingHost = values[0]\n\t}\n\thost, ok := hm.hosts.Load(incomingHost)\n\tif !ok {\n\t\tsourceService, namespace, err := hm.extractNamespaceAndService(incomingHost)\n\t\tif err != nil {\n\t\t\tprom.HostExtractionCounter.WithLabelValues(\"error\", incomingHost, hm.headerForHost, err.Error()).Inc()\n\t\t\treturn &messages.Host{}, err\n\t\t}\n\t\ttargetService := utils.GetPrivateServiceName(sourceService)\n\t\tsourceHost := hm.removeTrailingWildcardIfNeeded(incomingHost)\n\t\tsourceHost = hm.removeTrailingPathIfNeeded(sourceHost)\n\t\tsourceHost = hm.addHTTPIfNeeded(sourceHost)\n\t\ttargetHost := hm.replaceServiceName(sourceHost, targetService)\n\t\ttargetHost = hm.addHTTPIfNeeded(targetHost)\n\t\tnewHost := &messages.Host{\n\t\t\tIncomingHost:   incomingHost,\n\t\t\tNamespace:      namespace,\n\t\t\tSourceService:  sourceService,\n\t\t\tTargetService:  targetService,\n\t\t\tSourceHost:     sourceHost,\n\t\t\tTargetHost:     targetHost,\n\t\t\tTrafficAllowed: true,\n\t\t}\n\t\thm.hosts.Store(incomingHost, newHost)\n\t\tprom.HostExtractionCounter.WithLabelValues(\"cache-miss\", incomingHost, hm.headerForHost, \"\").Inc()\n\t\treturn newHost, nil\n\t}\n\tprom.HostExtractionCounter.WithLabelValues(\"cache-hit\", incomingHost, hm.headerForHost, \"\").Inc()\n\treturn host.(*messages.Host), nil\n}",
    "start_line": 41,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.GetHost",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.GetHost"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.DisableTrafficForHost": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.DisableTrafficForHost",
    "name": "HostManager.DisableTrafficForHost",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [
      "pkg.logger.logger.MaskMiddle",
      "resolver.internal.hostmanager.hostManager.HostManager.enableTrafficForHost"
    ],
    "source_code": "func (hm *HostManager) DisableTrafficForHost(hostName string) {\n\tif host, ok := hm.hosts.Load(hostName); ok && host.(*messages.Host).TrafficAllowed {\n\t\thost.(*messages.Host).TrafficAllowed = false\n\t\thm.hosts.Store(hostName, host)\n\t\thm.logger.Debug(\"Disabled traffic for host\",\n\t\t\tzap.String(\"hostName\", logger.MaskMiddle(hostName, 4, 4)),\n\t\t\tzap.Duration(\"trafficReEnableDuration\", hm.trafficReEnableDuration))\n\t\tgo time.AfterFunc(hm.trafficReEnableDuration, func() {\n\t\t\thm.enableTrafficForHost(hostName)\n\t\t})\n\t\tprom.TrafficSwitchCounter.WithLabelValues(hostName, \"disabled\").Inc()\n\t}\n}",
    "start_line": 77,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.DisableTrafficForHost",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.DisableTrafficForHost"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.enableTrafficForHost": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.enableTrafficForHost",
    "name": "HostManager.enableTrafficForHost",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [
      "pkg.logger.logger.MaskMiddle"
    ],
    "source_code": "func (hm *HostManager) enableTrafficForHost(hostName string) {\n\tif host, ok := hm.hosts.Load(hostName); ok && !host.(*messages.Host).TrafficAllowed {\n\t\thost.(*messages.Host).TrafficAllowed = true\n\t\thm.hosts.Store(hostName, host)\n\t\thm.logger.Debug(\"Enabled traffic for host\", zap.Any(\"hostName\", logger.MaskMiddle(hostName, 4, 4)))\n\t\tprom.TrafficSwitchCounter.WithLabelValues(hostName, \"enabled\").Inc()\n\t}\n}",
    "start_line": 92,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.enableTrafficForHost",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.enableTrafficForHost"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.extractNamespaceAndService": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.extractNamespaceAndService",
    "name": "HostManager.extractNamespaceAndService",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [
      "pkg.logger.logger.MaskMiddle"
    ],
    "source_code": "func (hm *HostManager) extractNamespaceAndService(url string) (string, string, error) {\n\t// Define regular expression patterns for different Kubernetes internal URL formats\n\tpatterns := []string{\n\t\t`http://([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local:\\d+/\\*`,\n\t\t`([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local:\\d+/\\*`,\n\t\t`http://([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local:\\d+`,\n\t\t`([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local:\\d+`,\n\t\t`http://([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local`,\n\t\t`([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local`,\n\t\t`http://([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc`,\n\t\t`([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)\\.svc`,\n\t\t`http://([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)`,\n\t\t`([a-zA-Z0-9-]+)\\.([a-zA-Z0-9-]+)`,\n\t\t`http://([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local`,\n\t\t`([a-zA-Z0-9-]+)\\.svc\\.cluster\\.local`,\n\t\t`http://([a-zA-Z0-9-]+)\\.svc`,\n\t\t`([a-zA-Z0-9-]+)\\.svc`,\n\t\t`http://([a-zA-Z0-9-]+)`,\n\t\t`([a-zA-Z0-9-]+)`,\n\t}\n\tvar serviceName, namespace string\n\tfor _, pattern := range patterns {\n\t\tre := regexp.MustCompile(pattern)\n\t\tmatches := re.FindStringSubmatch(url)\n\t\tif len(matches) == 3 {\n\t\t\tserviceName = matches[1]\n\t\t\tnamespace = matches[2]\n\t\t\treturn serviceName, namespace, nil\n\t\t} else if len(matches) == 2 {\n\t\t\tserviceName = matches[1]\n\t\t\tnamespace = \"default\"\n\t\t\treturn serviceName, namespace, fmt.Errorf(\"namespace not found in URL: %s\", logger.MaskMiddle(url, 4, 4))\n\t\t}\n\t}\n\treturn \"\", \"\", fmt.Errorf(\"invalid Kubernetes URL: %s\", logger.MaskMiddle(url, 4, 4))\n}",
    "start_line": 101,
    "end_line": 136,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.extractNamespaceAndService",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.extractNamespaceAndService"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.addHTTPIfNeeded": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.addHTTPIfNeeded",
    "name": "HostManager.addHTTPIfNeeded",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [],
    "source_code": "func (hm *HostManager) addHTTPIfNeeded(serviceURL string) string {\n\tif !strings.HasPrefix(serviceURL, \"http://\") && !strings.HasPrefix(serviceURL, \"https://\") {\n\t\treturn \"http://\" + serviceURL\n\t}\n\treturn serviceURL\n}",
    "start_line": 139,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.addHTTPIfNeeded",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.addHTTPIfNeeded"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingWildcardIfNeeded": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingWildcardIfNeeded",
    "name": "HostManager.removeTrailingWildcardIfNeeded",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [],
    "source_code": "func (hm *HostManager) removeTrailingWildcardIfNeeded(serviceURL string) string {\n\tif strings.HasSuffix(serviceURL, \"/*\") {\n\t\treturn strings.TrimSuffix(serviceURL, \"/*\")\n\t}\n\treturn serviceURL\n}",
    "start_line": 147,
    "end_line": 152,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.removeTrailingWildcardIfNeeded",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingWildcardIfNeeded"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingPathIfNeeded": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingPathIfNeeded",
    "name": "HostManager.removeTrailingPathIfNeeded",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [],
    "source_code": "func (hm *HostManager) removeTrailingPathIfNeeded(serviceURL string) string {\n\tif idx := strings.Index(serviceURL, \"/\"); idx != -1 {\n\t\treturn serviceURL[:idx]\n\t}\n\treturn serviceURL\n}",
    "start_line": 154,
    "end_line": 159,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.removeTrailingPathIfNeeded",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.removeTrailingPathIfNeeded"
  },
  "resolver.internal.hostmanager.hostManager.HostManager.replaceServiceName": {
    "id": "resolver.internal.hostmanager.hostManager.HostManager.replaceServiceName",
    "name": "HostManager.replaceServiceName",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager.go",
    "relative_path": "resolver/internal/hostmanager/hostManager.go",
    "depends_on": [],
    "source_code": "func (hm *HostManager) replaceServiceName(serviceURL, newServiceName string) string {\n\tparts := strings.Split(serviceURL, \".\")\n\tif len(parts) < 3 {\n\t\treturn serviceURL\n\t}\n\tparts[0] = newServiceName\n\treturn strings.Join(parts, \".\")\n}",
    "start_line": 162,
    "end_line": 169,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method HostManager.replaceServiceName",
    "component_id": "resolver.internal.hostmanager.hostManager.HostManager.replaceServiceName"
  },
  "resolver.internal.hostmanager.hostManager_test.TestGetHost": {
    "id": "resolver.internal.hostmanager.hostManager_test.TestGetHost",
    "name": "TestGetHost",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/hostmanager/hostManager_test.go",
    "relative_path": "resolver/internal/hostmanager/hostManager_test.go",
    "depends_on": [
      "resolver.internal.hostmanager.hostManager.HostManager.GetHost",
      "resolver.internal.hostmanager.hostManager.NewHostManager"
    ],
    "source_code": "func TestGetHost(t *testing.T) {\n\tlogger, _ := zap.NewDevelopment()\n\thm := NewHostManager(logger, 10*time.Second, \"X-Envoy-Decorator-Operation\")\n\n\ttests := []struct {\n\t\tname          string\n\t\treq           *http.Request\n\t\texpectedHost  *messages.Host\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tname: \"Host in header\",\n\t\t\treq: &http.Request{\n\t\t\t\tHost: \"target.com\",\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"X-Envoy-Decorator-Operation\": []string{\"service.namespace.svc.cluster.local:8080/test/*\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedHost: &messages.Host{\n\t\t\t\tIncomingHost:   \"service.namespace.svc.cluster.local:8080/test/*\",\n\t\t\t\tNamespace:      \"namespace\",\n\t\t\t\tSourceService:  \"service\",\n\t\t\t\tTargetService:  \"elasti-service-pvt-9df6b026a8\",\n\t\t\t\tSourceHost:     \"http://service.namespace.svc.cluster.local:8080\",\n\t\t\t\tTargetHost:     \"http://elasti-service-pvt-9df6b026a8.namespace.svc.cluster.local:8080\",\n\t\t\t\tTrafficAllowed: true,\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\thost, err := hm.GetHost(tt.req)\n\t\t\tif tt.expectedError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tt.expectedHost, host)\n\t\t})\n\t}\n}",
    "start_line": 13,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function TestGetHost",
    "component_id": "resolver.internal.hostmanager.hostManager_test.TestGetHost"
  },
  "resolver.internal.operator.RPCClient.Client": {
    "id": "resolver.internal.operator.RPCClient.Client",
    "name": "Client",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/operator/RPCClient.go",
    "relative_path": "resolver/internal/operator/RPCClient.go",
    "depends_on": [],
    "source_code": "type Client struct {\n\tlogger *zap.Logger\n\t// retryDuration is the duration to wait before retrying the operator\n\tretryDuration time.Duration\n\t// serviceRPCLocks is to keep track of the locks for different services\n\tserviceRPCLocks sync.Map\n\t// operatorURL is the URL of the operator\n\toperatorURL string\n\t// incomingRequestEndpoint is the endpoint to send information about the incoming request\n\tincomingRequestEndpoint string\n\t// client is the http client\n\tclient http.Client\n}",
    "start_line": 22,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Client",
    "component_id": "resolver.internal.operator.RPCClient.Client"
  },
  "resolver.internal.operator.RPCClient.NewOperatorClient": {
    "id": "resolver.internal.operator.RPCClient.NewOperatorClient",
    "name": "NewOperatorClient",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/operator/RPCClient.go",
    "relative_path": "resolver/internal/operator/RPCClient.go",
    "depends_on": [
      "pkg.config.config.GetOperatorConfig",
      "pkg.config.config.GetKubernetesClusterDomain"
    ],
    "source_code": "func NewOperatorClient(logger *zap.Logger, retryDuration time.Duration) *Client {\n\toperatorConfig := config.GetOperatorConfig()\n\toperatorHost := operatorConfig.ServiceName + \".\" + operatorConfig.Namespace + \".svc.\" + config.GetKubernetesClusterDomain()\n\toperatorHostPort := net.JoinHostPort(operatorHost, strconv.Itoa(int(operatorConfig.Port)))\n\n\treturn &Client{\n\t\tlogger:                  logger.With(zap.String(\"component\", \"operatorRPC\")),\n\t\tretryDuration:           retryDuration,\n\t\toperatorURL:             \"http://\" + operatorHostPort,\n\t\tincomingRequestEndpoint: \"/informer/incoming-request\",\n\t\tclient:                  http.Client{},\n\t}\n}",
    "start_line": 37,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewOperatorClient",
    "component_id": "resolver.internal.operator.RPCClient.NewOperatorClient"
  },
  "resolver.internal.operator.RPCClient.Client.SendIncomingRequestInfo": {
    "id": "resolver.internal.operator.RPCClient.Client.SendIncomingRequestInfo",
    "name": "Client.SendIncomingRequestInfo",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/operator/RPCClient.go",
    "relative_path": "resolver/internal/operator/RPCClient.go",
    "depends_on": [
      "resolver.internal.operator.RPCClient.Client.releaseMutexForServiceRPC",
      "pkg.scaling.scalers.prometheus_scaler.prometheusScaler.Close",
      "resolver.internal.operator.RPCClient.Client.getMutexForServiceRPC"
    ],
    "source_code": "func (o *Client) SendIncomingRequestInfo(ns, svc string) {\n\tlock, taken := o.getMutexForServiceRPC(svc)\n\tif taken {\n\t\treturn\n\t}\n\tlock.Lock()\n\tdefer time.AfterFunc(o.retryDuration, func() {\n\t\to.releaseMutexForServiceRPC(svc)\n\t})\n\n\trequestBody := messages.RequestCount{\n\t\tCount:     1,\n\t\tSvc:       svc,\n\t\tNamespace: ns,\n\t}\n\tjsonData, err := json.Marshal(requestBody)\n\tif err != nil {\n\t\tprom.OperatorRPCCounter.WithLabelValues(err.Error()).Inc()\n\t\to.logger.Error(\"Error marshalling request body for operatorRPC\", zap.Error(err))\n\t\treturn\n\t}\n\turl := o.operatorURL + o.incomingRequestEndpoint\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tprom.OperatorRPCCounter.WithLabelValues(err.Error()).Inc()\n\t\to.logger.Error(\"Error creating request\", zap.Error(err))\n\t\treturn\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t//nolint:bodyclose\n\tresp, err := o.client.Do(req)\n\tif err != nil {\n\t\tprom.OperatorRPCCounter.WithLabelValues(err.Error()).Inc()\n\t\to.logger.Error(\"Error sending request\", zap.Error(err))\n\t\treturn\n\t}\n\tdefer func(Body io.ReadCloser) {\n\t\terr := Body.Close()\n\t\tif err != nil {\n\t\t\tprom.OperatorRPCCounter.WithLabelValues(err.Error()).Inc()\n\t\t\to.logger.Error(\"Error closing body\", zap.Error(err))\n\t\t}\n\t}(resp.Body)\n\tif resp.StatusCode != http.StatusOK {\n\t\tprom.OperatorRPCCounter.WithLabelValues(strconv.Itoa(resp.StatusCode)).Inc()\n\t\to.logger.Error(\"Request failed with status code\", zap.Int(\"status_code\", resp.StatusCode))\n\t\treturn\n\t}\n\tprom.OperatorRPCCounter.WithLabelValues(\"\").Inc()\n\to.logger.Info(\"Request sent to controller\", zap.Int(\"statusCode\", resp.StatusCode), zap.Any(\"body\", resp.Body))\n}",
    "start_line": 52,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Client.SendIncomingRequestInfo",
    "component_id": "resolver.internal.operator.RPCClient.Client.SendIncomingRequestInfo"
  },
  "resolver.internal.operator.RPCClient.Client.releaseMutexForServiceRPC": {
    "id": "resolver.internal.operator.RPCClient.Client.releaseMutexForServiceRPC",
    "name": "Client.releaseMutexForServiceRPC",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/operator/RPCClient.go",
    "relative_path": "resolver/internal/operator/RPCClient.go",
    "depends_on": [],
    "source_code": "func (o *Client) releaseMutexForServiceRPC(service string) {\n\tlock, loaded := o.serviceRPCLocks.Load(service)\n\tif !loaded {\n\t\treturn\n\t}\n\tlock.(*sync.Mutex).Unlock()\n\to.serviceRPCLocks.Delete(service)\n}",
    "start_line": 104,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Client.releaseMutexForServiceRPC",
    "component_id": "resolver.internal.operator.RPCClient.Client.releaseMutexForServiceRPC"
  },
  "resolver.internal.operator.RPCClient.Client.getMutexForServiceRPC": {
    "id": "resolver.internal.operator.RPCClient.Client.getMutexForServiceRPC",
    "name": "Client.getMutexForServiceRPC",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/operator/RPCClient.go",
    "relative_path": "resolver/internal/operator/RPCClient.go",
    "depends_on": [],
    "source_code": "func (o *Client) getMutexForServiceRPC(service string) (*sync.Mutex, bool) {\n\tm, loaded := o.serviceRPCLocks.LoadOrStore(service, &sync.Mutex{})\n\treturn m.(*sync.Mutex), loaded\n}",
    "start_line": 113,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Client.getMutexForServiceRPC",
    "component_id": "resolver.internal.operator.RPCClient.Client.getMutexForServiceRPC"
  },
  "resolver.internal.throttler.breaker.BreakerParams": {
    "id": "resolver.internal.throttler.breaker.BreakerParams",
    "name": "BreakerParams",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/breaker.go",
    "relative_path": "resolver/internal/throttler/breaker.go",
    "depends_on": [],
    "source_code": "type BreakerParams struct {\n\tQueueDepth      int\n\tMaxConcurrency  int\n\tInitialCapacity int\n\tLogger          *zap.Logger\n}",
    "start_line": 11,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct BreakerParams",
    "component_id": "resolver.internal.throttler.breaker.BreakerParams"
  },
  "resolver.internal.throttler.breaker.Breaker": {
    "id": "resolver.internal.throttler.breaker.Breaker",
    "name": "Breaker",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/breaker.go",
    "relative_path": "resolver/internal/throttler/breaker.go",
    "depends_on": [],
    "source_code": "type Breaker struct {\n\tlogger         *zap.Logger\n\tinFlight       atomic.Int64\n\ttotalSlots     int64\n\tmaxConcurrency uint16\n\tsem            *semaphore\n}",
    "start_line": 20,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Breaker",
    "component_id": "resolver.internal.throttler.breaker.Breaker"
  },
  "resolver.internal.throttler.breaker.NewBreaker": {
    "id": "resolver.internal.throttler.breaker.NewBreaker",
    "name": "NewBreaker",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/breaker.go",
    "relative_path": "resolver/internal/throttler/breaker.go",
    "depends_on": [
      "resolver.internal.throttler.semaphore.newSemaphore"
    ],
    "source_code": "func NewBreaker(params BreakerParams) *Breaker {\n\treturn &Breaker{\n\t\tmaxConcurrency: uint16(params.MaxConcurrency), //nolint: gosec\n\t\ttotalSlots:     int64(params.QueueDepth + params.MaxConcurrency),\n\t\tlogger:         params.Logger,\n\t\tsem:            newSemaphore(params.MaxConcurrency, params.InitialCapacity),\n\t}\n}",
    "start_line": 28,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewBreaker",
    "component_id": "resolver.internal.throttler.breaker.NewBreaker"
  },
  "resolver.internal.throttler.breaker.Breaker.Maybe": {
    "id": "resolver.internal.throttler.breaker.Breaker.Maybe",
    "name": "Breaker.Maybe",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/breaker.go",
    "relative_path": "resolver/internal/throttler/breaker.go",
    "depends_on": [
      "resolver.internal.throttler.breaker.Breaker.tryAcquireInFlightSlot",
      "resolver.internal.throttler.semaphore.semaphore.release",
      "resolver.internal.throttler.semaphore.semaphore.acquire",
      "resolver.internal.throttler.breaker.Breaker.releaseInFlightSlot"
    ],
    "source_code": "func (b *Breaker) Maybe(ctx context.Context, thunk func()) error {\n\t// We want to have a queue of requests\n\t// and a limited number of concurrent of requests taken from that queue\n\n\tif !b.tryAcquireInFlightSlot() {\n\t\treturn ErrRequestQueueFull\n\t}\n\n\tdefer b.releaseInFlightSlot()\n\n\tif err := b.sem.acquire(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t// Defer releasing capacity in the active.\n\t// It's safe to ignore the error returned by release since we\n\t// make sure the semaphore is only manipulated here and acquire\n\t// + release calls are equally paired.\n\tdefer b.sem.release()\n\n\tthunk()\n\treturn nil\n}",
    "start_line": 41,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Breaker.Maybe",
    "component_id": "resolver.internal.throttler.breaker.Breaker.Maybe"
  },
  "resolver.internal.throttler.breaker.Breaker.tryAcquireInFlightSlot": {
    "id": "resolver.internal.throttler.breaker.Breaker.tryAcquireInFlightSlot",
    "name": "Breaker.tryAcquireInFlightSlot",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/breaker.go",
    "relative_path": "resolver/internal/throttler/breaker.go",
    "depends_on": [],
    "source_code": "func (b *Breaker) tryAcquireInFlightSlot() bool {\n\t// We can't just use an atomic increment as we need to check if we're\n\t// \"allowed\" to increment first. Since a Load and a CompareAndSwap are\n\t// not done atomically, we need to retry until the CompareAndSwap succeeds\n\t// (it fails if we're raced to it) or if we don't fulfill the condition\n\t// anymore.\n\tfor {\n\t\tcur := b.inFlight.Load()\n\t\tif cur >= b.totalSlots {\n\t\t\tb.logger.Debug(\"Request above the total slots\", zap.Any(\"current\", cur), zap.Any(\"total slots\", b.totalSlots))\n\t\t\treturn false\n\t\t}\n\t\tif b.inFlight.CompareAndSwap(cur, cur+1) {\n\t\t\tb.logger.Debug(\"inFlight\", zap.Any(\"current load\", cur), zap.Any(\"current load increase\", cur+1))\n\t\t\treturn true\n\t\t}\n\t}\n}",
    "start_line": 65,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Breaker.tryAcquireInFlightSlot",
    "component_id": "resolver.internal.throttler.breaker.Breaker.tryAcquireInFlightSlot"
  },
  "resolver.internal.throttler.breaker.Breaker.releaseInFlightSlot": {
    "id": "resolver.internal.throttler.breaker.Breaker.releaseInFlightSlot",
    "name": "Breaker.releaseInFlightSlot",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/breaker.go",
    "relative_path": "resolver/internal/throttler/breaker.go",
    "depends_on": [],
    "source_code": "func (b *Breaker) releaseInFlightSlot() {\n\tfor {\n\t\tcur := b.inFlight.Load()\n\t\tb.inFlight.CompareAndSwap(cur, cur-1)\n\t\treturn\n\t}\n}",
    "start_line": 84,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Breaker.releaseInFlightSlot",
    "component_id": "resolver.internal.throttler.breaker.Breaker.releaseInFlightSlot"
  },
  "resolver.internal.throttler.semaphore.semaphore": {
    "id": "resolver.internal.throttler.semaphore.semaphore",
    "name": "semaphore",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [],
    "source_code": "type semaphore struct {\n\tstate atomic.Uint64\n\tqueue chan struct{}\n}",
    "start_line": 9,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct semaphore",
    "component_id": "resolver.internal.throttler.semaphore.semaphore"
  },
  "resolver.internal.throttler.semaphore.newSemaphore": {
    "id": "resolver.internal.throttler.semaphore.newSemaphore",
    "name": "newSemaphore",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [
      "resolver.internal.throttler.semaphore.semaphore.updateCapacity"
    ],
    "source_code": "func newSemaphore(maxCapacity, initialCapacity int) *semaphore {\n\tqueue := make(chan struct{}, maxCapacity)\n\tsem := &semaphore{queue: queue}\n\tsem.updateCapacity(initialCapacity)\n\treturn sem\n}",
    "start_line": 15,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function newSemaphore",
    "component_id": "resolver.internal.throttler.semaphore.newSemaphore"
  },
  "resolver.internal.throttler.semaphore.semaphore.acquire": {
    "id": "resolver.internal.throttler.semaphore.semaphore.acquire",
    "name": "semaphore.acquire",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [
      "resolver.internal.throttler.semaphore.unpack",
      "resolver.internal.throttler.semaphore.pack"
    ],
    "source_code": "func (s *semaphore) acquire(ctx context.Context) error {\n\tfor {\n\t\told := s.state.Load()\n\t\tcapacity, in := unpack(old)\n\n\t\tif in >= capacity {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn fmt.Errorf(\"acquire: %w\", ctx.Err())\n\t\t\tcase <-s.queue:\n\t\t\t}\n\t\t\t// Force reload state.\n\t\t\tcontinue\n\t\t}\n\n\t\tin++\n\t\tif s.state.CompareAndSwap(old, pack(capacity, in)) {\n\t\t\treturn nil\n\t\t}\n\t}\n}",
    "start_line": 23,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method semaphore.acquire",
    "component_id": "resolver.internal.throttler.semaphore.semaphore.acquire"
  },
  "resolver.internal.throttler.semaphore.semaphore.release": {
    "id": "resolver.internal.throttler.semaphore.semaphore.release",
    "name": "semaphore.release",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [
      "resolver.internal.throttler.semaphore.unpack",
      "resolver.internal.throttler.semaphore.pack"
    ],
    "source_code": "func (s *semaphore) release() {\n\tfor {\n\t\told := s.state.Load()\n\t\tcapacity, in := unpack(old)\n\n\t\tif in == 0 {\n\t\t\tpanic(\"release and acquire are not paired\")\n\t\t}\n\n\t\tin--\n\t\tif s.state.CompareAndSwap(old, pack(capacity, in)) {\n\t\t\tif in < capacity {\n\t\t\t\tselect {\n\t\t\t\tcase s.queue <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t\t// We generate more wakeups than we might need as we don't know\n\t\t\t\t\t// how many goroutines are waiting here. It is therefore okay\n\t\t\t\t\t// to drop the poke on the floor here as this case would mean we\n\t\t\t\t\t// have enough wakeups to wake up as many goroutines as this semaphore\n\t\t\t\t\t// can take, which is guaranteed to be enough.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "start_line": 48,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method semaphore.release",
    "component_id": "resolver.internal.throttler.semaphore.semaphore.release"
  },
  "resolver.internal.throttler.semaphore.semaphore.updateCapacity": {
    "id": "resolver.internal.throttler.semaphore.semaphore.updateCapacity",
    "name": "semaphore.updateCapacity",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [
      "resolver.internal.throttler.semaphore.unpack",
      "resolver.internal.throttler.semaphore.pack"
    ],
    "source_code": "func (s *semaphore) updateCapacity(size int) {\n\ts64 := uint64(size) //nolint: gosec\n\tfor {\n\t\told := s.state.Load()\n\t\tcapacity, in := unpack(old)\n\n\t\tif capacity == s64 {\n\t\t\t// Nothing to do, exit early.\n\t\t\treturn\n\t\t}\n\n\t\tif s.state.CompareAndSwap(old, pack(s64, in)) {\n\t\t\tif s64 > capacity {\n\t\t\t\tfor i := uint64(0); i < s64-capacity; i++ {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase s.queue <- struct{}{}:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// See comment in `release` for explanation of this case.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "start_line": 76,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method semaphore.updateCapacity",
    "component_id": "resolver.internal.throttler.semaphore.semaphore.updateCapacity"
  },
  "resolver.internal.throttler.semaphore.semaphore.Capacity": {
    "id": "resolver.internal.throttler.semaphore.semaphore.Capacity",
    "name": "semaphore.Capacity",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [
      "resolver.internal.throttler.semaphore.unpack"
    ],
    "source_code": "func (s *semaphore) Capacity() int {\n\tcapacity, _ := unpack(s.state.Load())\n\treturn int(capacity) //nolint: gosec\n}",
    "start_line": 103,
    "end_line": 106,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method semaphore.Capacity",
    "component_id": "resolver.internal.throttler.semaphore.semaphore.Capacity"
  },
  "resolver.internal.throttler.semaphore.unpack": {
    "id": "resolver.internal.throttler.semaphore.unpack",
    "name": "unpack",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [],
    "source_code": "func unpack(in uint64) (uint64, uint64) {\n\treturn in >> 32, in & 0xffffffff\n}",
    "start_line": 110,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function unpack",
    "component_id": "resolver.internal.throttler.semaphore.unpack"
  },
  "resolver.internal.throttler.semaphore.pack": {
    "id": "resolver.internal.throttler.semaphore.pack",
    "name": "pack",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/semaphore.go",
    "relative_path": "resolver/internal/throttler/semaphore.go",
    "depends_on": [],
    "source_code": "func pack(left, right uint64) uint64 {\n\treturn left<<32 | right\n}",
    "start_line": 117,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pack",
    "component_id": "resolver.internal.throttler.semaphore.pack"
  },
  "resolver.internal.throttler.throttler.Params": {
    "id": "resolver.internal.throttler.throttler.Params",
    "name": "Params",
    "component_type": "struct",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [],
    "source_code": "type (\n\tThrottler struct {\n\t\tlogger                  *zap.Logger\n\t\tbreaker                 *Breaker\n\t\tk8sUtil                 *k8shelper.Ops\n\t\tretryDuration           time.Duration\n\t\tTrafficReEnableDuration time.Duration\n\t\tserviceReadyMap         sync.Map\n\t\tqueueSizeMap            sync.Map\n\t}\n\n\tParams struct {\n\t\tQueueRetryDuration      time.Duration\n\t\tTrafficReEnableDuration time.Duration\n\t\tK8sUtil                 *k8shelper.Ops\n\t\tQueueDepth              int\n\t\tMaxConcurrency          int\n\t\tInitialCapacity         int\n\t\tLogger                  *zap.Logger\n\t}\n)",
    "start_line": 14,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "struct",
    "base_classes": null,
    "class_name": null,
    "display_name": "struct Params",
    "component_id": "resolver.internal.throttler.throttler.Params"
  },
  "resolver.internal.throttler.throttler.NewThrottler": {
    "id": "resolver.internal.throttler.throttler.NewThrottler",
    "name": "NewThrottler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [
      "resolver.internal.throttler.breaker.NewBreaker"
    ],
    "source_code": "func NewThrottler(param *Params) *Throttler {\n\tbreaker := NewBreaker(BreakerParams{\n\t\tQueueDepth:      param.QueueDepth,\n\t\tMaxConcurrency:  param.MaxConcurrency,\n\t\tInitialCapacity: param.InitialCapacity,\n\t\tLogger:          param.Logger,\n\t})\n\n\treturn &Throttler{\n\t\tlogger:                  param.Logger.With(zap.String(\"component\", \"throttler\")),\n\t\tbreaker:                 breaker,\n\t\tk8sUtil:                 param.K8sUtil,\n\t\tTrafficReEnableDuration: param.TrafficReEnableDuration,\n\t\tretryDuration:           param.QueueRetryDuration,\n\t}\n}",
    "start_line": 36,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewThrottler",
    "component_id": "resolver.internal.throttler.throttler.NewThrottler"
  },
  "resolver.internal.throttler.throttler.Throttler.Try": {
    "id": "resolver.internal.throttler.throttler.Throttler.Try",
    "name": "Throttler.Try",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [
      "resolver.internal.throttler.throttler.Throttler.incrementQueueSize",
      "resolver.internal.throttler.breaker.Breaker.Maybe",
      "resolver.internal.throttler.throttler.Throttler.checkIfServiceReady",
      "resolver.internal.throttler.throttler.Throttler.decrementQueueSize"
    ],
    "source_code": "func (t *Throttler) Try(ctx context.Context, host *messages.Host, resolve func(int) error, tryErrCallback func()) error {\n\treenqueue := true\n\ttryCount := 1\n\tvar tryErr error\n\n\tt.incrementQueueSize(host.Namespace, host.SourceService)\n\tdefer t.decrementQueueSize(host.Namespace, host.SourceService)\n\n\tfor reenqueue {\n\t\ttryErr = nil\n\t\tbreakErr := t.breaker.Maybe(ctx, func() {\n\t\t\tif isPodActive, err := t.checkIfServiceReady(host.Namespace, host.TargetService); err != nil {\n\t\t\t\ttryErr = err\n\t\t\t\tgo tryErrCallback()\n\t\t\t} else if isPodActive {\n\t\t\t\tif res := resolve(tryCount); res != nil {\n\t\t\t\t\ttryErr = fmt.Errorf(\"resolve error: %w\", res)\n\t\t\t\t}\n\t\t\t\t// We don't reenqueue if the POD is active, but request failed to resolve\n\t\t\t\treenqueue = false\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\ttryErr = fmt.Errorf(\"context done error: %w\", ctx.Err())\n\t\t\t\treenqueue = false\n\t\t\tdefault:\n\t\t\t\tif reenqueue {\n\t\t\t\t\ttryCount++\n\t\t\t\t\ttime.Sleep(t.retryDuration)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tif breakErr != nil {\n\t\t\treturn fmt.Errorf(\"breaker error: %w\", breakErr)\n\t\t}\n\t}\n\tif tryErr != nil {\n\t\treturn fmt.Errorf(\"thunk error: %w\", tryErr)\n\t}\n\treturn nil\n}",
    "start_line": 53,
    "end_line": 94,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Throttler.Try",
    "component_id": "resolver.internal.throttler.throttler.Throttler.Try"
  },
  "resolver.internal.throttler.throttler.Throttler.checkIfServiceReady": {
    "id": "resolver.internal.throttler.throttler.Throttler.checkIfServiceReady",
    "name": "Throttler.checkIfServiceReady",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [
      "pkg.k8shelper.ops.Ops.CheckIfServiceEndpointSliceActive"
    ],
    "source_code": "func (t *Throttler) checkIfServiceReady(namespace, service string) (bool, error) {\n\tkey := fmt.Sprintf(\"%s/%s\", namespace, service)\n\tif ready, ok := t.serviceReadyMap.Load(key); ok {\n\t\treturn ready.(bool), nil\n\t}\n\n\tisPodActive, err := t.k8sUtil.CheckIfServiceEndpointSliceActive(namespace, service)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to get target active endpoints: %w\", err)\n\t}\n\tif !isPodActive {\n\t\treturn false, fmt.Errorf(\"no active endpoints found for namespace: %v service: %v\", namespace, service)\n\t}\n\n\tt.serviceReadyMap.Store(key, true)\n\t// release the memory after sometime\n\ttime.AfterFunc(t.TrafficReEnableDuration, func() {\n\t\tt.serviceReadyMap.Delete(key)\n\t})\n\treturn true, nil\n}",
    "start_line": 96,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Throttler.checkIfServiceReady",
    "component_id": "resolver.internal.throttler.throttler.Throttler.checkIfServiceReady"
  },
  "resolver.internal.throttler.throttler.Throttler.GetQueueSize": {
    "id": "resolver.internal.throttler.throttler.Throttler.GetQueueSize",
    "name": "Throttler.GetQueueSize",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [],
    "source_code": "func (t *Throttler) GetQueueSize(namespace, service string) int {\n\tkey := fmt.Sprintf(\"%s/%s\", namespace, service)\n\tif size, ok := t.queueSizeMap.Load(key); ok {\n\t\treturn size.(int)\n\t}\n\treturn 0\n}",
    "start_line": 118,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Throttler.GetQueueSize",
    "component_id": "resolver.internal.throttler.throttler.Throttler.GetQueueSize"
  },
  "resolver.internal.throttler.throttler.Throttler.incrementQueueSize": {
    "id": "resolver.internal.throttler.throttler.Throttler.incrementQueueSize",
    "name": "Throttler.incrementQueueSize",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [
      "resolver.internal.throttler.throttler.Throttler.GetQueueSize"
    ],
    "source_code": "func (t *Throttler) incrementQueueSize(namespace, service string) {\n\tkey := fmt.Sprintf(\"%s/%s\", namespace, service)\n\tt.queueSizeMap.Store(key, t.GetQueueSize(namespace, service)+1)\n}",
    "start_line": 126,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Throttler.incrementQueueSize",
    "component_id": "resolver.internal.throttler.throttler.Throttler.incrementQueueSize"
  },
  "resolver.internal.throttler.throttler.Throttler.decrementQueueSize": {
    "id": "resolver.internal.throttler.throttler.Throttler.decrementQueueSize",
    "name": "Throttler.decrementQueueSize",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/throttler.go",
    "relative_path": "resolver/internal/throttler/throttler.go",
    "depends_on": [
      "resolver.internal.throttler.throttler.Throttler.GetQueueSize"
    ],
    "source_code": "func (t *Throttler) decrementQueueSize(namespace, service string) {\n\tkey := fmt.Sprintf(\"%s/%s\", namespace, service)\n\tt.queueSizeMap.Store(key, t.GetQueueSize(namespace, service)-1)\n}",
    "start_line": 131,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method Throttler.decrementQueueSize",
    "component_id": "resolver.internal.throttler.throttler.Throttler.decrementQueueSize"
  },
  "resolver.internal.throttler.transport.RoundTripperFunc.RoundTrip": {
    "id": "resolver.internal.throttler.transport.RoundTripperFunc.RoundTrip",
    "name": "RoundTripperFunc.RoundTrip",
    "component_type": "method",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/transport.go",
    "relative_path": "resolver/internal/throttler/transport.go",
    "depends_on": [],
    "source_code": "func (rt RoundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error) {\n\treturn rt(r)\n}",
    "start_line": 18,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method RoundTripperFunc.RoundTrip",
    "component_id": "resolver.internal.throttler.transport.RoundTripperFunc.RoundTrip"
  },
  "resolver.internal.throttler.transport.NewProxyAutoTransport": {
    "id": "resolver.internal.throttler.transport.NewProxyAutoTransport",
    "name": "NewProxyAutoTransport",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/transport.go",
    "relative_path": "resolver/internal/throttler/transport.go",
    "depends_on": [
      "resolver.internal.throttler.transport.newH2CTransport",
      "resolver.internal.throttler.transport.newHTTPTransport",
      "resolver.internal.throttler.transport.RoundTripperFunc.RoundTrip"
    ],
    "source_code": "func NewProxyAutoTransport(maxIdleProxyConns, maxIdleProxyConnsPerHost int) http.RoundTripper {\n\tv1 := newHTTPTransport(false /*disable keep-alives*/, true /*disable auto-compression*/, maxIdleProxyConns, maxIdleProxyConnsPerHost)\n\tv2 := newH2CTransport(true)\n\treturn RoundTripperFunc(func(r *http.Request) (*http.Response, error) {\n\t\tt := v1\n\t\tif r.ProtoMajor == 2 {\n\t\t\tt = v2\n\t\t}\n\t\treturn t.RoundTrip(r)\n\t})\n}",
    "start_line": 36,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewProxyAutoTransport",
    "component_id": "resolver.internal.throttler.transport.NewProxyAutoTransport"
  },
  "resolver.internal.throttler.transport.newHTTPTransport": {
    "id": "resolver.internal.throttler.transport.newHTTPTransport",
    "name": "newHTTPTransport",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/transport.go",
    "relative_path": "resolver/internal/throttler/transport.go",
    "depends_on": [],
    "source_code": "func newHTTPTransport(disableKeepAlives, disableCompression bool, maxIdle, maxIdlePerHost int) http.RoundTripper {\n\ttransport := http.DefaultTransport.(*http.Transport).Clone()\n\ttransport.DialContext = DialWithBackOff\n\ttransport.DisableKeepAlives = disableKeepAlives\n\ttransport.MaxIdleConns = maxIdle\n\ttransport.MaxIdleConnsPerHost = maxIdlePerHost\n\ttransport.ForceAttemptHTTP2 = false\n\ttransport.DisableCompression = disableCompression\n\treturn transport\n}",
    "start_line": 48,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function newHTTPTransport",
    "component_id": "resolver.internal.throttler.transport.newHTTPTransport"
  },
  "resolver.internal.throttler.transport.newH2CTransport": {
    "id": "resolver.internal.throttler.transport.newH2CTransport",
    "name": "newH2CTransport",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/transport.go",
    "relative_path": "resolver/internal/throttler/transport.go",
    "depends_on": [],
    "source_code": "func newH2CTransport(disableCompression bool) http.RoundTripper {\n\treturn &http2.Transport{\n\t\tAllowHTTP:          true,\n\t\tDisableCompression: disableCompression,\n\t\tDialTLS: func(netw, addr string, _ *tls.Config) (net.Conn, error) {\n\t\t\treturn DialWithBackOff(context.Background(),\n\t\t\t\tnetw, addr)\n\t\t},\n\t}\n}",
    "start_line": 59,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function newH2CTransport",
    "component_id": "resolver.internal.throttler.transport.newH2CTransport"
  },
  "resolver.internal.throttler.transport.NewBackoffDialer": {
    "id": "resolver.internal.throttler.transport.NewBackoffDialer",
    "name": "NewBackoffDialer",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/transport.go",
    "relative_path": "resolver/internal/throttler/transport.go",
    "depends_on": [
      "resolver.internal.throttler.transport.dialBackOffHelper"
    ],
    "source_code": "func NewBackoffDialer(backoffConfig wait.Backoff) func(context.Context, string, string) (net.Conn, error) {\n\treturn func(ctx context.Context, network, address string) (net.Conn, error) {\n\t\treturn dialBackOffHelper(ctx, network, address, backoffConfig, nil)\n\t}\n}",
    "start_line": 70,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function NewBackoffDialer",
    "component_id": "resolver.internal.throttler.transport.NewBackoffDialer"
  },
  "resolver.internal.throttler.transport.dialBackOffHelper": {
    "id": "resolver.internal.throttler.transport.dialBackOffHelper",
    "name": "dialBackOffHelper",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/CodeWiki/test_repos/KubeElasti/resolver/internal/throttler/transport.go",
    "relative_path": "resolver/internal/throttler/transport.go",
    "depends_on": [],
    "source_code": "func dialBackOffHelper(ctx context.Context, network, address string, bo wait.Backoff, tlsConf *tls.Config) (net.Conn, error) {\n\tdialer := &net.Dialer{\n\t\tTimeout:   bo.Duration, // Initial duration.\n\t\tKeepAlive: 5 * time.Second,\n\t\tDualStack: true,\n\t}\n\tstart := time.Now()\n\tfor {\n\t\tvar (\n\t\t\tc   net.Conn\n\t\t\terr error\n\t\t)\n\t\tif tlsConf == nil {\n\t\t\tc, err = dialer.DialContext(ctx, network, address)\n\t\t} else {\n\t\t\tc, err = tls.DialWithDialer(dialer, network, address, tlsConf)\n\t\t}\n\t\tif err != nil {\n\t\t\tvar errNet net.Error\n\t\t\tif errors.As(err, &errNet) && errNet.Timeout() {\n\t\t\t\tif bo.Steps < 1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdialer.Timeout = bo.Step()\n\t\t\t\ttime.Sleep(wait.Jitter(sleep, 1.0)) // Sleep with jitter.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"dialBackOffHelper: %w\", err)\n\t\t}\n\t\treturn c, nil\n\t}\n\telapsed := time.Since(start)\n\treturn nil, fmt.Errorf(\"%w %s after %.2fs\", ErrTimeoutDialing, address, elapsed.Seconds())\n}",
    "start_line": 76,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function dialBackOffHelper",
    "component_id": "resolver.internal.throttler.transport.dialBackOffHelper"
  }
}